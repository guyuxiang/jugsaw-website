{"componentChunkName":"component---src-templates-docs-tsx","path":"/km/developers/docs/smart-contracts/security/","result":{"data":{"siteData":{"siteMetadata":{"editContentUrl":"https://github.com/ethereum/ethereum-org-website/tree/dev/"}},"pageData":{"fields":{"slug":"/en/developers/docs/smart-contracts/security/"},"frontmatter":{"title":"Smart contract security","description":"An overview of guidelines for building secure Ethereum smart contracts","lang":"en","incomplete":null,"sidebarDepth":null,"isOutdated":null,"hideEditButton":null},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Smart contract security\",\n  \"description\": \"An overview of guidelines for building secure Ethereum smart contracts\",\n  \"lang\": \"en\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Smart contracts are extremely flexible, and capable of controlling large amounts of value and data, while running immutable logic based on code deployed on the blockchain. This has created a vibrant ecosystem of trustless and decentralized applications that provide many advantages over legacy systems. They also represent opportunities for attackers looking to profit by exploiting vulnerabilities in smart contracts.\"), mdx(\"p\", null, \"Public blockchains, like Ethereum, further complicate the issue of securing smart contracts. Deployed contract code \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"usually\"), \" cannot be changed to patch security flaws, while assets stolen from smart contracts are extremely difficult to track and mostly irrecoverable due to immutability.\"), mdx(\"p\", null, \"Although figures vary, it is estimated that the total amount of value stolen or lost due to security defects in smart contracts is easily over $1 billion. This includes high-profile incidents, such as the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/\"\n  }, \"DAO hack\"), \" (3.6M ETH stolen, worth over $1B in today\\u2019s prices), \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.coindesk.com/30-million-ether-reported-stolen-parity-wallet-breach\"\n  }, \"Parity multi-sig wallet hack\"), \" ($30M lost to hackers), and the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.theguardian.com/technology/2017/nov/08/cryptocurrency-300m-dollars-stolen-bug-ether\"\n  }, \"Parity frozen wallet issue\"), \" (over $300M in ETH locked forever).\"), mdx(\"p\", null, \"The aforementioned issues make it imperative for developers to invest effort in building secure, robust, and resilient smart contracts. Smart contract security is serious business, and one that every developer will do well to learn. This guide will cover security considerations for Ethereum developers and explore resources for improving smart contract security.\"), mdx(\"h2\", {\n    \"id\": \"prerequisites\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#prerequisites\",\n    \"aria-label\": \"prerequisites permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Prerequisites\"), mdx(\"p\", null, \"Make sure you\\u2019re familiar with the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/smart-contracts/\"\n  }, \"fundamentals of smart contract development\"), \" before tackling security.\"), mdx(\"h2\", {\n    \"id\": \"smart-contract-security-guidelines\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#smart-contract-security-guidelines\",\n    \"aria-label\": \"smart contract security guidelines permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Guidelines for building secure Ethereum smart contracts\"), mdx(\"h3\", {\n    \"id\": \"design-proper-access-controls\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#design-proper-access-controls\",\n    \"aria-label\": \"design proper access controls permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"1. Design proper access controls\"), mdx(\"p\", null, \"In smart contracts, functions marked \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"external\"), \" can be called by any externally owned accounts (EOAs) or contract accounts. Specifying public visibility for functions is necessary if you want others to interact with your contract. Functions marked \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"private\"), \" however can only be called by functions within the smart contract, and not external accounts. Giving every network participant access to contract functions can cause problems, especially if it means anyone can perform sensitive operations (e.g., minting new tokens).\"), mdx(\"p\", null, \"To prevent unauthorized use of smart contract functions, it is necessary to implement secure access controls. Access control mechanisms restrict the ability to use certain functions in a smart contract to approved entities, such as accounts responsible for managing the contract. The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Ownable pattern\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"role-based control\"), \" are two patterns useful for implementing access control in smart contracts:\"), mdx(\"h4\", {\n    \"id\": \"ownable-pattern\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#ownable-pattern\",\n    \"aria-label\": \"ownable pattern permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Ownable pattern\"), mdx(\"p\", null, \"In the Ownable pattern, an address is set as the \\u201Cowner\\u201D of the contract during the contract-creation process. Protected functions are assigned an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"OnlyOwner\"), \" modifier, which ensures the contract authenticates the identity of the calling address before executing the function. Calls to protected functions from other addresses aside from the contract owner always revert, preventing unwanted access.\"), mdx(\"h4\", {\n    \"id\": \"role-based-access-control\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#role-based-access-control\",\n    \"aria-label\": \"role based access control permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Role-based access control\"), mdx(\"p\", null, \"Registering a single address as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Owner\"), \" in a smart contract introduces the risk of centralization and represents a single point-of-failure. If the owner\\u2019s account keys are compromised, attackers can attack the owned contract. This is why using a role-based access control pattern with multiple administrative accounts may be a better option.\"), mdx(\"p\", null, \"In role-based access control, access to sensitive functions is distributed between a set of trusted participants. For instance, one account may be responsible for minting tokens, while another account performs upgrades or pauses the contract. Decentralizing access control this way eliminates single points of failure and reduces trust assumptions for users.\"), mdx(\"h5\", null, \"Using multi-signature wallets\"), mdx(\"p\", null, \"Another approach for implementing secure access control is using a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/smart-contracts/#multisig\"\n  }, \"multi-signature account\"), \" to manage a contract. Unlike a regular EOA, multi-signature accounts are owned by multiple entities and require signatures from a minimum number of accounts\\u2014say 3-of-5\\u2014to execute transactions.\"), mdx(\"p\", null, \"Using a multisig for access control introduces an extra layer of security since actions on the target contract require consent from multiple parties. This is particularly useful if using the Ownable pattern is necessary, as it makes it more difficult for an attacker or rogue insider to manipulate sensitive contract functions for malicious purposes.\"), mdx(\"h3\", {\n    \"id\": \"use-require-assert-revert\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#use-require-assert-revert\",\n    \"aria-label\": \"use require assert revert permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"2. Use require(), assert(), and revert() statements to guard contract operations\"), mdx(\"p\", null, \"As mentioned, anyone can call public functions in your smart contract once it is deployed on the blockchain. Since you cannot know in advance how external accounts will interact with a contract, it is ideal to implement internal safeguards against problematic operations before deploying. You can enforce correct behavior in smart contracts by using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"require()\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"assert()\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"revert()\"), \" statements to trigger exceptions and revert state changes if execution fails to satisfy certain requirements.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"require()\")), \": \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"require\"), \" are defined at the start of functions and ensures predefined conditions are met before the called function is executed. A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"require\"), \" statement can be used to validate user inputs, check state variables, or authenticate the identity of the calling account before progressing with a function.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"assert()\")), \": \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"assert()\"), \" is used to detect internal errors and check for violations of \\u201Cinvariants\\u201D in your code. An invariant is a logical assertion about a contract\\u2019s state that should hold true for all function executions. An example invariant is the maximum total supply or balance of a token contract. Using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"assert()\"), \" ensures that your contract never reaches a vulnerable state, and if it does, all changes to state variables are rolled back.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"revert()\")), \": \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"revert()\"), \" can be used in an if-else statement that triggers an exception if the required condition is not satisfied. The sample contract below uses \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"revert()\"), \" to guard the execution of functions:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"pragma solidity ^0.8.4;\\n\\ncontract VendingMachine {\\n    address owner;\\n    error Unauthorized();\\n    function buy(uint amount) public payable {\\n        if (amount > msg.value / 2 ether)\\n            revert(\\\"Not enough Ether provided.\\\");\\n        // Perform the purchase.\\n    }\\n    function withdraw() public {\\n        if (msg.sender != owner)\\n            revert Unauthorized();\\n\\n        payable(msg.sender).transfer(address(this).balance);\\n    }\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"test-smart-contracts-and-verify-code-correctness\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#test-smart-contracts-and-verify-code-correctness\",\n    \"aria-label\": \"test smart contracts and verify code correctness permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"3. Test smart contracts and verify code correctness\"), mdx(\"p\", null, \"The immutability of code running in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/evm/\"\n  }, \"Ethereum Virtual Machine\"), \" means smart contracts demand a higher level of quality assessment during the development phase. Testing your contract extensively and observing it for any unexpected results will improve security a great deal and protect your users in the long run.\"), mdx(\"p\", null, \"The usual method is to write small unit tests using mock data that the contract is expected to receive from users. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/smart-contracts/testing/#unit-testing\"\n  }, \"Unit testing\"), \" is good for testing the functionality of certain functions and ensuring a smart contract works as expected.\"), mdx(\"p\", null, \"Unfortunately, unit testing is minimally effective for improving smart contract security when used in isolation. A unit test might prove a function executes properly for mock data, but unit tests are only as effective as the tests that are written. This makes it difficult to detect missed edge cases and vulnerabilities that could break the safety of your smart contract.\"), mdx(\"p\", null, \"A better approach is to combine unit testing with property-based testing performed using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/smart-contracts/testing/#static-dynamic-analysis\"\n  }, \"static and dynamic analysis\"), \". Static analysis relies on low-level representations, such as \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Control-flow_graph\"\n  }, \"control flow graphs\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://deepsource.io/glossary/ast/\"\n  }, \"abstract syntax trees\"), \" to analyze reachable program states and execution paths. Meanwhile, dynamic analysis techniques, such as fuzzing, execute contract code with random input values to detect operations that violate security properties.\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/smart-contracts/formal-verification\"\n  }, \"Formal verification\"), \" is another technique for verifying security properties in smart contracts. Unlike regular testing, formal verification can conclusively prove the absence of errors in a smart contract. This is achieved by creating a formal specification that captures desired security properties and proving that a formal model of the contracts adheres to this specification.\"), mdx(\"h3\", {\n    \"id\": \"get-independent-code-reviews\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#get-independent-code-reviews\",\n    \"aria-label\": \"get independent code reviews permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"4. Ask for an independent review of your code\"), mdx(\"p\", null, \"After testing your contract, it is good to ask others to check the source code for any security issues. Testing will not uncover every flaw in a smart contract, but getting an independent review increases the possibility of spotting vulnerabilities.\"), mdx(\"h4\", {\n    \"id\": \"audits\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#audits\",\n    \"aria-label\": \"audits permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Audits\"), mdx(\"p\", null, \"Commissioning a smart contract audit is one way of conducting an independent code review. Auditors play an important role in ensuring that smart contracts are secure and free from quality defects and design errors.\"), mdx(\"p\", null, \"That said, you should avoid treating audits as a silver bullet. Smart contract audits won't catch every bug and are mostly designed to provide an additional round of reviews, which can help detect issues missed by developers during initial development and testing. You should also follow \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://twitter.com/tinchoabbate/status/1400170232904400897\"\n  }, \"best practices for working with auditors\"), \", such as documenting code properly and adding inline comments, to maximize the benefit of a smart contract audit.\"), mdx(\"h4\", {\n    \"id\": \"bug-bounties\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#bug-bounties\",\n    \"aria-label\": \"bug bounties permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Bug bounties\"), mdx(\"p\", null, \"Setting up a bug bounty program is another approach for implementing external code reviews. A bug bounty is a financial reward given to individuals (usually whitehat hackers) that discover vulnerabilities in an application.\"), mdx(\"p\", null, \"When used properly, bug bounties give members of the hacker community incentive to inspect your code for critical flaws. A real-life example is the \\u201Cinfinite money bug\\u201D that would have let an attacker create an unlimited amount of Ether on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.optimism.io/\"\n  }, \"Optimism\"), \", a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://ethereum.org/en/layer-2/\"\n  }, \"Layer 2\"), \" protocol running on Ethereum. Fortunately, a whitehat hacker \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.saurik.com/optimism.html\"\n  }, \"discovered the flaw\"), \" and notified the team, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://cryptoslate.com/critical-bug-in-ethereum-l2-optimism-2m-bounty-paid/\"\n  }, \"earning a large payout in the process\"), \".\"), mdx(\"p\", null, \"A useful strategy is to set the payout of a bug bounty program in proportion to the amount of funds at stake. Described as the \\u201C\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/immunefi/a-defi-security-standard-the-scaling-bug-bounty-9b83dfdc1ba7\"\n  }, \"scaling bug bounty\"), \"\\u201D, this approach provides financial incentives for individuals to responsibly disclose vulnerabilities instead of exploiting them.\"), mdx(\"h3\", {\n    \"id\": \"follow-smart-contract-development-best-practices\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#follow-smart-contract-development-best-practices\",\n    \"aria-label\": \"follow smart contract development best practices permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"5. Follow best practices during smart contract development\"), mdx(\"p\", null, \"The existence of audits and bug bounties doesn\\u2019t excuse your responsibility to write high-quality code. Good smart contract security starts with following proper design and development processes:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Store all code in a version control system, such as git\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Make all code modifications via pull requests\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Ensure pull requests have at least one independent reviewer\\u2014if you are working solo on a project, consider finding other developers and trade code reviews\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Use a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/frameworks/\"\n  }, \"development environment\"), \" for testing, compiling, deploying smart contracts\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Run your code through basic code analysis tools, such as Mythril and Slither. Ideally, you should do this before each pull request is merged and compare differences in output\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Ensure your code compiles without errors, and the Solidity compiler emits no warnings\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Properly document your code (using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://solidity.readthedocs.io/en/develop/natspec-format.html\"\n  }, \"NatSpec\"), \") and describe details about the contract architecture in easy-to-understand language. This will make it easier for others to audit and review your code.\"))), mdx(\"h3\", {\n    \"id\": \"implement-disaster-recovery-plans\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#implement-disaster-recovery-plans\",\n    \"aria-label\": \"implement disaster recovery plans permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"6. Implement robust disaster recovery plans\"), mdx(\"p\", null, \"Designing secure access controls, implementing function modifiers, and other suggestions can improve smart contract security, but they cannot rule out the possibility of malicious exploits. Building secure smart contracts requires \\u201Cpreparing for failure\\u201D and having a fallback plan for responding effectively to attacks. A proper disaster recovery plan will incorporate some or all of the following components:\"), mdx(\"h4\", {\n    \"id\": \"contract-upgrades\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#contract-upgrades\",\n    \"aria-label\": \"contract upgrades permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Contract upgrades\"), mdx(\"p\", null, \"While Ethereum smart contracts are immutable by default, it is possible to achieve some degree of mutability by using upgrade patterns. Upgrading contracts is necessary in cases where a critical flaw renders your old contract unusable and deploying new logic is the most feasible option.\"), mdx(\"p\", null, \"Contract upgrade mechanisms work differently, but the \\u201Cproxy pattern\\u201D is one of the more popular approaches for upgrading smart contracts. Proxy patterns split an application\\u2019s state and logic between \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"two\"), \" contracts. The first contract (called a \\u2018proxy contract\\u2019) stores state variables (e.g., user balances), while the second contract (called a \\u2018logic contract\\u2019) holds the code for executing contract functions.\"), mdx(\"p\", null, \"Accounts interact with the proxy contract, which dispatches all function calls to the logic contract using the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.soliditylang.org/en/v0.8.16/introduction-to-smart-contracts.html?highlight=delegatecall#delegatecall-callcode-and-libraries\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"delegatecall()\")), \" low-level call. Unlike a regular message call, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"delegatecall()\"), \" ensures the code running at the logic contract\\u2019s address is executed in the context of the calling contract. This means the logic contract will always write to the proxy\\u2019s storage (instead of its own storage) and the original values of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"msg.sender\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"msg.value\"), \" are preserved.\"), mdx(\"p\", null, \"Delegating calls to the logic contract requires storing its address in the proxy contract's storage. Hence, upgrading the contract's logic is only a matter of deploying another logic contract and storing the new address in the proxy contract. As subsequent calls to the proxy contract are automatically routed to the new logic contract, you would have \\u201Cupgraded\\u201D the contract without actually modifying the code.\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/smart-contracts/upgrading/\"\n  }, \"More on upgrading contracts\"), \".\"), mdx(\"h4\", {\n    \"id\": \"emergency-stops\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#emergency-stops\",\n    \"aria-label\": \"emergency stops permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Emergency stops\"), mdx(\"p\", null, \"As mentioned, extensive auditing and testing cannot possibly discover all bugs in a smart contract. If a vulnerability appears in your code after deployment, patching it is impossible since you cannot change the code running at the contract address. Also, upgrade mechanisms (e.g., proxy patterns) may take time to implement (they often require approval from different parties), which only gives attackers more time to cause more damage.\"), mdx(\"p\", null, \"The nuclear option is to implement an \\u201Cemergency stop\\u201D function that blocks calls to vulnerable functions in a contract. Emergency stops typically comprise the following components:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"A global Boolean variable indicating if the smart contract is in a stopped state or not. This variable is set to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \" when setting up the contract, but will revert to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \" once the contract is stopped.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Functions that reference the Boolean variable in their execution. Such functions are accessible when the smart contract is not stopped, and become inaccessible when the emergency stop feature is triggered.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"An entity that has access to the emergency stop function, which sets the Boolean variable to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \". To prevent malicious actions, calls to this function can be restricted to a trusted address (e.g., the contract owner).\"))), mdx(\"p\", null, \"Once the contract activates the emergency stop, certain functions will not be callable. This is achieved by wrapping select functions in a modifier that references the global variable. Below is \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/fravoll/solidity-patterns/blob/master/EmergencyStop/EmergencyStop.sol\"\n  }, \"an example\"), \" describing an implementation of this pattern in contracts:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"// This code has not been professionally audited and makes no promises about safety or correctness. Use at your own risk.\\n\\ncontract EmergencyStop {\\n\\n    bool isStopped = false;\\n\\n    modifier stoppedInEmergency {\\n        require(!isStopped);\\n        _;\\n    }\\n\\n    modifier onlyWhenStopped {\\n        require(isStopped);\\n        _;\\n    }\\n\\n    modifier onlyAuthorized {\\n        // Check for authorization of msg.sender here\\n        _;\\n    }\\n\\n    function stopContract() public onlyAuthorized {\\n        isStopped = true;\\n    }\\n\\n    function resumeContract() public onlyAuthorized {\\n        isStopped = false;\\n    }\\n\\n    function deposit() public payable stoppedInEmergency {\\n        // Deposit logic happening here\\n    }\\n\\n    function emergencyWithdraw() public onlyWhenStopped {\\n        // Emergency withdraw happening here\\n    }\\n}\\n\")), mdx(\"p\", null, \"This example shows the basic features of emergency stops:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isStopped\"), \" is a Boolean that evaluates to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \" at the beginning and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \" when the contract enters emergency mode.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"The function modifiers \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onlyWhenStopped\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"stoppedInEmergency\"), \" check the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isStopped\"), \" variable. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"stoppedInEmergency\"), \" is used to control functions that should be inaccessible when the contract is vulnerable (e.g., \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"deposit()\"), \"). Calls to these functions will simply revert.\"))), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onlyWhenStopped\"), \" is used for functions that should be callable during an emergency (e.g., \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"emergencyWithdraw()\"), \"). Such functions can help resolve the situation, hence their exclusion from the \\u201Crestricted functions\\u201D list.\"), mdx(\"p\", null, \"Using an emergency stop functionality provides an effective stopgap for dealing with serious vulnerabilities in your smart contract. However, it increases the need for users to trust developers not to activate it for self-serving reasons. To this end, decentralizing control of the emergency stop either by subjecting it to an on-chain voting mechanism, timelock, or approval from a multisig wallet are possible solutions.\"), mdx(\"h4\", {\n    \"id\": \"event-monitoring\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#event-monitoring\",\n    \"aria-label\": \"event monitoring permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Event monitoring\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.soliditylang.org/en/v0.8.15/contracts.html#events\"\n  }, \"Events\"), \" allow you to track calls to smart contract functions and monitor changes to state variables. It is ideal to program your smart contract to emit an event whenever some party takes a safety-critical action (e.g., withdrawing funds).\"), mdx(\"p\", null, \"Logging events and monitoring them off-chain provides insights on contract operations and aids faster discovery of malicious actions. This means your team can respond faster to hacks and take action to mitigate impact on users, such as pausing functions or performing an upgrade.\"), mdx(\"p\", null, \"You can also opt for an off-the-shelf monitoring tool that automatically forwards alerts whenever someone interacts with your contracts. These tools will allow you to create custom alerts based on different triggers, such as transaction volume, frequency of function calls, or the specific functions involved. For example, you could program an alert that comes in when the amount withdrawn in a single transaction crosses a particular threshold.\"), mdx(\"h3\", {\n    \"id\": \"design-secure-governance-systems\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#design-secure-governance-systems\",\n    \"aria-label\": \"design secure governance systems permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"7. Design secure governance systems\"), mdx(\"p\", null, \"You may want to decentralize your application by turning over control of core smart contracts to community members. In this case, the smart contract system will include a governance module\\u2014a mechanism that allows community members to approve administrative actions via an on-chain governance system. For example, a proposal to upgrade a proxy contract to a new implementation may be voted upon by token-holders.\"), mdx(\"p\", null, \"Decentralized governance can be beneficial, especially because it aligns the interests of developers and end-users. Nevertheless, smart contract governance mechanisms may introduce new risks if implemented incorrectly. A plausible scenario is if an attacker acquires enormous voting power (measured in number of tokens held) by taking out a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/defi/#flash-loans\"\n  }, \"flash loan\"), \" and pushes through a malicious proposal.\"), mdx(\"p\", null, \"One way of preventing problems related to on-chain governance is to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://blog.openzeppelin.com/protect-your-users-with-smart-contract-timelocks/\"\n  }, \"use a timelock\"), \". A timelock prevents a smart contract from executing certain actions until a specific amount of time passes. Other strategies include assigning a \\u201Cvoting weight\\u201D to each token based on how long it has been locked up for, or measuring the voting power of an address at a historical period (for example, 2-3 blocks in the past) instead of the current block. Both methods reduce the possibility of quickly amassing voting power to swing on-chain votes.\"), mdx(\"p\", null, \"More on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://blog.openzeppelin.com/smart-contract-security-guidelines-4-strategies-for-safer-governance-systems/\"\n  }, \"designing secure governance systems\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://hackernoon.com/governance-is-the-holy-grail-for-daos\"\n  }, \"different voting mechanisms in DAOs\"), \".\"), mdx(\"h3\", {\n    \"id\": \"reduce-code-complexity\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#reduce-code-complexity\",\n    \"aria-label\": \"reduce code complexity permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"8. Reduce complexity in code to a minimum\"), mdx(\"p\", null, \"Traditional software developers are familiar with the KISS (\\u201Ckeep it simple, stupid\\u201D) principle, which advises against introducing unnecessary complexity into software design. This follows the long-held thinking that \\u201Ccomplex systems fail in complex ways\\u201D and are more susceptible to costly errors.\"), mdx(\"p\", null, \"Keeping things simple is of particular importance when writing smart contracts, given that smart contracts are potentially controlling large amounts of value. A tip for achieving simplicity when writing smart contracts is to reuse existing libraries, such as \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.openzeppelin.com/contracts/4.x/\"\n  }, \"OpenZeppelin Contracts\"), \", where possible. Because these libraries have been extensively audited and tested by developers, using them reduces the chances of introducing bugs by writing new functionality from scratch.\"), mdx(\"p\", null, \"Another common advice is to write small functions and keep contracts modular by splitting business logic across multiple contracts. Not only does writing simpler code reduce the attack surface in a smart contract, it also makes it easier to reason about the correctness of the overall system and detect possible design errors early.\"), mdx(\"h3\", {\n    \"id\": \"mitigate-common-smart-contract-vulnerabilities\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#mitigate-common-smart-contract-vulnerabilities\",\n    \"aria-label\": \"mitigate common smart contract vulnerabilities permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"9. Defend against common smart contract vulnerabilities\"), mdx(\"h4\", {\n    \"id\": \"reentrancy\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#reentrancy\",\n    \"aria-label\": \"reentrancy permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Reentrancy\"), mdx(\"p\", null, \"The EVM doesn\\u2019t permit concurrency, meaning two contracts involved in a message call cannot run simultaneously. An external call pauses the calling contract's execution and memory until the call returns, at which point execution proceeds normally. This process can be formally described as transferring \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.computerhope.com/jargon/c/contflow.htm\"\n  }, \"control flow\"), \" to another contract.\"), mdx(\"p\", null, \"Although mostly harmless, transferring control flow to untrusted contracts can cause problems, such as reentrancy. A reentrancy attack occurs when a malicious contract calls back into a vulnerable contract before the original function invocation is complete. This type of attack is best explained with an example.\"), mdx(\"p\", null, \"Consider a simple smart contract (\\u2018Victim\\u2019) that allows anyone to deposit and withdraw Ether:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"// This contract is vulnerable. Do not use in production\\n\\ncontract Victim {\\n    mapping (address => uint256) public balances;\\n\\n    function deposit() external payable {\\n        balances[msg.sender] += msg.value;\\n    }\\n\\n    function withdraw() external {\\n        uint256 amount = balances[msg.sender];\\n        (bool success, ) = msg.sender.call.value(amount)(\\\"\\\");\\n        require(success);\\n        balances[msg.sender] = 0;\\n    }\\n}\\n\")), mdx(\"p\", null, \"This contract exposes a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"withdraw()\"), \" function to allow users to withdraw ETH previously deposited in the contract. When processing a withdrawal, the contract performs the following operations:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Checks the user\\u2019s ETH balance\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Sends funds to the calling address\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Resets their balance to 0, preventing additional withdrawals from the user\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"withdraw()\"), \" function in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Victim\"), \" contract follows a \\u201Cchecks-interactions-effects\\u201D pattern. It \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"checks\"), \" if conditions necessary for execution are satisfied (i.e., the user has a positive ETH balance) and performs the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"interaction\"), \" by sending ETH to the caller\\u2019s address, before applying the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"effects\"), \" of the transaction (i.e., reducing the user\\u2019s balance).\"), mdx(\"p\", null, \"If \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"withdraw()\"), \" is called from an externally owned account (EOA), the function executes as expected: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"msg.sender.call.value()\"), \" sends ETH to the caller. However, if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"msg.sender\"), \" is a smart contract account calls \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"withdraw()\"), \", sending funds using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"msg.sender.call.value()\"), \" will also trigger code stored at that address to run.\"), mdx(\"p\", null, \"Imagine this is the code deployed at the contract address:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \" contract Attacker {\\n    function beginAttack() external payable {\\n        Victim(victim_address).deposit.value(1 ether)();\\n        Victim(victim_address).withdraw();\\n    }\\n\\n    function() external payable {\\n        if (gasleft() > 40000) {\\n            Victim(victim_address).withdraw();\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"This contract is designed to do three things:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Accept a deposit from another account (likely the attacker\\u2019s EOA)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Deposit 1 ETH into the Victim contract\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Withdraw the 1 ETH stored in the smart contract\")), mdx(\"p\", null, \"There\\u2019s nothing wrong here, except that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Attacker\"), \" has another function that calls \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"withdraw()\"), \" in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Victim\"), \" again if the gas left over from the incoming \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"msg.sender.call.value\"), \" is more than 40,000. This gives \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Attacker\"), \" the ability to reenter \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Victim\"), \" and withdraw more funds \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"before\"), \" the first invocation of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"withdraw\"), \" completes. The cycle looks like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"- Attacker's EOA calls `Attacker.beginAttack()` with 1 ETH\\n- `Attacker.beginAttack()` deposits 1 ETH into `Victim`\\n- `Attacker` calls `withdraw() in `Victim`\\n- `Victim` checks `Attacker`\\u2019s balance (1 ETH)\\n- `Victim` sends 1 ETH to `Attacker` (which triggers the default function)\\n- `Attacker` calls `Victim.withdraw()` again (note that `Victim` hasn\\u2019t reduced `Attacker`\\u2019s balance from the first withdrawal)\\n- `Victim` checks `Attacker`\\u2019s balance (which is still 1 ETH because it hasn\\u2019t applied the effects of the first call)\\n- `Victim` sends 1 ETH to `Attacker` (which triggers the default function and allows `Attacker` to reenter the `withdraw` function)\\n- The process repeats until `Attacker` runs out of gas, at which point `msg.sender.call.value` returns without triggering additional withdrawals\\n- `Victim` finally applies the results of the first transaction (and subsequent ones) to its state, so `Attacker`\\u2019s balance is set to 0\\n\")), mdx(\"p\", null, \"The summary is that because the caller\\u2019s balance isn't set to 0 until the function execution completes, subsequent invocations will succeed and allow the caller to withdraw their balance multiple times. This kind of attack can be used to drain a smart contract of its funds, like what happened in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.coindesk.com/learn/2016/06/25/understanding-the-dao-attack/\"\n  }, \"2016 DAO hack\"), \". Reentrancy attacks are still a critical issue for smart contracts today as \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/pcaversaccio/reentrancy-attacks\"\n  }, \"public listings of reentrancy exploits\"), \" show.\"), mdx(\"h5\", null, \"How to prevent reentrancy attacks\"), mdx(\"p\", null, \"An approach to dealing with reentrancy is following the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.soliditylang.org/en/develop/security-considerations.html#use-the-checks-effects-interactions-pattern\"\n  }, \"checks-effects-interactions pattern\"), \". This pattern orders the execution of functions in a way that code that performs necessary checks before progressing with execution comes first, followed by code that manipulates contract state, with code that interacts with other contracts or EOAs arriving last.\"), mdx(\"p\", null, \"The checks-effect-interaction pattern is used in a revised version of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Victim\"), \" contract shown below:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"contract NoLongerAVictim {\\n    function withdraw() external {\\n        uint256 amount = balances[msg.sender];\\n        balances[msg.sender] = 0;\\n        (bool success, ) = msg.sender.call.value(amount)(\\\"\\\");\\n        require(success);\\n    }\\n}\\n\")), mdx(\"p\", null, \"This contract performs a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"check\"), \" on the user\\u2019s balance, applies the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"effects\"), \" of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"withdraw()\"), \" function (by resetting the user\\u2019s balance to 0), and proceeds to perform the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"interaction\"), \" (sending ETH to the user\\u2019s address). This ensures the contract updates its storage before the external call, eliminating the re-entrancy condition that enabled the first attack. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Attacker\"), \" contract could still call back into \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NoLongerAVictim\"), \", but since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"balances[msg.sender]\"), \" has been set to 0, additional withdrawals will throw an error.\"), mdx(\"p\", null, \"Another option is to use a mutual exclusion lock (commonly described as a \\\"mutex\\\") that locks a portion of a contract\\u2019s state until a function invocation completes. This is implemented using a Boolean variable that is set to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \" before the function executes and reverts to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \" after the invocation is done. As seen in the example below, using a mutex protects a function against recursive calls while the original invocation is still processing, effectively stopping reentrancy.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"pragma solidity ^0.7.0;\\n\\ncontract MutexPattern {\\n    bool locked = false;\\n    mapping(address => uint256) public balances;\\n\\n    modifier noReentrancy() {\\n        require(!locked, \\\"Blocked from reentrancy.\\\");\\n        locked = true;\\n        _;\\n        locked = false;\\n    }\\n    // This function is protected by a mutex, so reentrant calls from within `msg.sender.call` cannot call `withdraw` again.\\n    //  The `return` statement evaluates to `true` but still evaluates the `locked = false` statement in the modifier\\n    function withdraw(uint _amount) public payable noReentrancy returns(bool) {\\n        require(balances[msg.sender] >= _amount, \\\"No balance to withdraw.\\\");\\n\\n        balances[msg.sender] -= _amount;\\n        bool (success, ) = msg.sender.call{value: _amount}(\\\"\\\");\\n        require(success);\\n\\n        return true;\\n    }\\n}\\n\")), mdx(\"p\", null, \"You can also use a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.openzeppelin.com/contracts/4.x/api/security#PullPayment\"\n  }, \"pull payments\"), \" system that requires users to withdraw funds from the smart contracts, instead of a \\\"push payments\\\" system that sends funds to accounts. This removes the possibility of inadvertently triggering code at unknown addresses (and can also prevent certain denial-of-service attacks).\"), mdx(\"h4\", {\n    \"id\": \"integer-underflows-and-overflows\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#integer-underflows-and-overflows\",\n    \"aria-label\": \"integer underflows and overflows permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Integer underflows and overflows\"), mdx(\"p\", null, \"An integer overflow occurs when the results of an arithmetic operation falls outside the acceptable range of values, causing it to \\\"roll over\\\" to the lowest representable value. For example, a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uint8\"), \" can only store values up to 2^8-1=255. Arithmetic operations that result in values higher than \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"255\"), \" will overflow and reset \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uint\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0\"), \", similar to how the odometer on a car resets to 0 once it reaches the maximum mileage (999999).\"), mdx(\"p\", null, \"Integer underflows happen for similar reasons: the the results of an arithmetic operation falls below the acceptable range. Say you tried decrementing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0\"), \" in a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uint8\"), \", the result would simply roll over to the maximum representable value (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"255\"), \").\"), mdx(\"p\", null, \"Both integer overflows and underflows can lead to unexpected changes to a contract\\u2019s state variables and result in unplanned execution. Below is an example showing how an attacker can exploit arithmetic overflow in a smart contract to perform an invalid operation:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"pragma solidity ^0.7.6;\\n\\n// This contract is designed to act as a time vault.\\n// User can deposit into this contract but cannot withdraw for at least a week.\\n// User can also extend the wait time beyond the 1 week waiting period.\\n\\n/*\\n1. Deploy TimeLock\\n2. Deploy Attack with address of TimeLock\\n3. Call Attack.attack sending 1 ether. You will immediately be able to\\n   withdraw your ether.\\n\\nWhat happened?\\nAttack caused the TimeLock.lockTime to overflow and was able to withdraw\\nbefore the 1 week waiting period.\\n*/\\n\\ncontract TimeLock {\\n    mapping(address => uint) public balances;\\n    mapping(address => uint) public lockTime;\\n\\n    function deposit() external payable {\\n        balances[msg.sender] += msg.value;\\n        lockTime[msg.sender] = block.timestamp + 1 weeks;\\n    }\\n\\n    function increaseLockTime(uint _secondsToIncrease) public {\\n        lockTime[msg.sender] += _secondsToIncrease;\\n    }\\n\\n    function withdraw() public {\\n        require(balances[msg.sender] > 0, \\\"Insufficient funds\\\");\\n        require(block.timestamp > lockTime[msg.sender], \\\"Lock time not expired\\\");\\n\\n        uint amount = balances[msg.sender];\\n        balances[msg.sender] = 0;\\n\\n        (bool sent, ) = msg.sender.call{value: amount}(\\\"\\\");\\n        require(sent, \\\"Failed to send Ether\\\");\\n    }\\n}\\n\\ncontract Attack {\\n    TimeLock timeLock;\\n\\n    constructor(TimeLock _timeLock) {\\n        timeLock = TimeLock(_timeLock);\\n    }\\n\\n    fallback() external payable {}\\n\\n    function attack() public payable {\\n        timeLock.deposit{value: msg.value}();\\n        /*\\n        if t = current lock time then we need to find x such that\\n        x + t = 2**256 = 0\\n        so x = -t\\n        2**256 = type(uint).max + 1\\n        so x = type(uint).max + 1 - t\\n        */\\n        timeLock.increaseLockTime(\\n            type(uint).max + 1 - timeLock.lockTime(address(this))\\n        );\\n        timeLock.withdraw();\\n    }\\n}\\n\")), mdx(\"h5\", null, \"How to prevent integer underflows and overflows\"), mdx(\"p\", null, \"As of version 0.8.0, the Solidity compiler rejects code that results in integer underflows and overflows. However, contracts compiled with a lower compiler version should either perform checks on functions involving arithmetic operations or use a library (e.g., \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.openzeppelin.com/contracts/2.x/api/math\"\n  }, \"SafeMath\"), \") that checks for underflow/overflow.\"), mdx(\"h4\", {\n    \"id\": \"oracle-manipulation\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#oracle-manipulation\",\n    \"aria-label\": \"oracle manipulation permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Oracle manipulation\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/oracles/\"\n  }, \"Oracles\"), \" source off-chain information and send it on-chain for smart contracts to use. With oracles, you can design smart contracts that interoperate with off-chain systems, such as capital markets, greatly expanding their application.\"), mdx(\"p\", null, \"But if the oracle is corrupted and sends incorrect information on-chain, smart contracts will execute based on erroneous inputs, which can cause problems. This is the basis of the \\u201Coracle problem\\u201D, which concerns the task of making sure information from a blockchain oracle is accurate, up-to-date, and timely.\"), mdx(\"p\", null, \"A related security concern is using an on-chain oracle, such as a decentralized exchange, to get the spot price for an asset. Lending platforms in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/defi/\"\n  }, \"decentralized finance (DeFi)\"), \" industry often do this to determine the value of a user\\u2019s collateral to determine how much they can borrow.\"), mdx(\"p\", null, \"DEX prices are often accurate, largely due to arbitrageurs restoring parity in markets. However, they are open to manipulation, particularly if the on-chain oracle calculates asset prices based on historical trading patterns (as is usually the case).\"), mdx(\"p\", null, \"For instance, an attacker could artificially pump the spot price of an asset by taking out a flash loan right before interacting with your lending contract. Querying the DEX for the asset\\u2019s price would return a higher-than-normal value (due to the attacker\\u2019s large \\u201Cbuy order\\u201D skewing demand for the asset), allowing them to borrow more than they should. Such \\\"flash loan attacks\\\" have been used to exploit reliance on price oracles among DeFi applications, costing protocols millions in lost funds.\"), mdx(\"h5\", null, \"How to prevent oracle manipulation\"), mdx(\"p\", null, \"The minimum requirement to avoid oracle manipulation is to use a decentralized oracle network that queries information from multiple sources to avoid single points of failure. In most cases, decentralized oracles have built-in cryptoeconomic incentives to encourage oracle nodes to report correct information, making them more secure than centralized oracles.\"), mdx(\"p\", null, \"If you plan on querying an on-chain oracle for asset prices, consider using one that implements a time-weighted average price (TWAP) mechanism. A \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.uniswap.org/protocol/V2/concepts/core-concepts/oracles\"\n  }, \"TWAP oracle\"), \" queries the price of an asset at two different points in time (which you can modify) and calculates the spot price based on the average obtained. Choosing longer time periods protects your protocol against price manipulation since large orders executed recently cannot impact asset prices.\"), mdx(\"h2\", {\n    \"id\": \"smart-contract-security-resources-for-developers\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#smart-contract-security-resources-for-developers\",\n    \"aria-label\": \"smart contract security resources for developers permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Smart contract security resources for developers\"), mdx(\"h3\", {\n    \"id\": \"code-analysis-tools\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#code-analysis-tools\",\n    \"aria-label\": \"code analysis tools permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Tools for analyzing smart contracts and verifying code correctness\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"/developers/docs/smart-contracts/testing/#testing-tools-and-libraries\"\n  }, \"Testing tools and libraries\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Collection of industry-standard tools and libraries for performing unit tests, static analysis, and dynamic analysis on smart contracts.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"/developers/docs/smart-contracts/formal-verification/#formal-verification-tools\"\n  }, \"Formal verification tools\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Tools for verifying functional correctness in smart contracts and checking invariants.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"/developers/docs/smart-contracts/testing/#smart-contract-auditing-services\"\n  }, \"Smart contract auditing services\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Listing of organizations providing smart contract auditing services for Ethereum development projects.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://ethereum.org/en/developers/docs/smart-contracts/testing/#bug-bounty-platforms\"\n  }, \"Bug bounty platforms\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Platforms for coordinating bug bounties and rewarding responsible disclosure of critical vulnerabilities in smart contracts.\")))), mdx(\"h3\", {\n    \"id\": \"smart-contract-monitoring-tools\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#smart-contract-monitoring-tools\",\n    \"aria-label\": \"smart contract monitoring tools permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Tools for monitoring smart contracts\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://docs.openzeppelin.com/defender/sentinel\"\n  }, \"OpenZeppelin Defender Sentinels\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"A tool for automatically monitoring and responding to events, functions, and transaction parameters on your smart contracts.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://tenderly.co/alerting/\"\n  }, \"Tenderly Real-Time Alerting\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"A tool for getting real-time notifications when unusual or unexpected events happen on your smart contracts or wallets.\")))), mdx(\"h3\", {\n    \"id\": \"smart-contract-administration-tools\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#smart-contract-administration-tools\",\n    \"aria-label\": \"smart contract administration tools permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Tools for secure administration of smart contracts\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://docs.openzeppelin.com/defender/admin\"\n  }, \"OpenZeppelin Defender Admin\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Interface for managing smart contract administration, including access controls, upgrades, and pausing.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://safe.global/\"\n  }, \"Safe\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Smart contract wallet running on Ethereum that requires a minimum number of people to approve a transaction before it can occur (M-of-N).\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://docs.openzeppelin.com/contracts/4.x/\"\n  }, \"OpenZeppelin Contracts\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Contract libraries for implementing administrative features, including contract ownership, upgrades, access controls, governance, pauseability, and more.\")))), mdx(\"h3\", {\n    \"id\": \"smart-contract-auditing-services\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#smart-contract-auditing-services\",\n    \"aria-label\": \"smart contract auditing services permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Smart contract auditing services\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://consensys.net/diligence/\"\n  }, \"ConsenSys Diligence\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Smart contract auditing service helping projects across the blockchain ecosystem ensure their protocols are ready for launch and built to protect users.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://www.certik.com/\"\n  }, \"CertiK\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Blockchain security firm pioneering the use of cutting-edge formal Verification technology on smart contracts and blockchain networks.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://www.trailofbits.com/\"\n  }, \"Trail of Bits\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Cybersecurity company that combines security research with an attacker mentality to reduce risk and fortify code.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://peckshield.com/\"\n  }, \"PeckShield\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Blockchain security company offering products and services for the security, privacy, and usability of the entire blockchain ecosystem.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://quantstamp.com/\"\n  }, \"QuantStamp\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Auditing service facilitating the mainstream adoption of blockchain technology through security and risk assessment services.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://www.openzeppelin.com/security-audits\"\n  }, \"OpenZeppelin\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Smart contract security company providing security audits for distributed systems.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://runtimeverification.com/\"\n  }, \"Runtime Verification\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Security company specializing in formal modeling and verification of smart contracts.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://hacken.io\"\n  }, \"Hacken\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Web3 cybersecurity auditor bringing the 360-degree approach to blockchain security.\")))), mdx(\"h3\", {\n    \"id\": \"bug-bounty-platforms\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#bug-bounty-platforms\",\n    \"aria-label\": \"bug bounty platforms permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Bug bounty platforms\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://immunefi.com/\"\n  }, \"Immunefi\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Bug bounty platform for smart contracts and DeFi projects, where security researchers review code, disclose vulnerabilities, get paid, and make crypto safer.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://www.hackerone.com/\"\n  }, \"HackerOne\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Vulnerability coordination and bug bounty platform that connects businesses with penetration testers and cybersecurity researchers.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://hackenproof.com/\"\n  }, \"HackenProof\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Expert bug bounty platform for crypto projects (DeFi, Smart Contracts, Wallets, CEX and more), where security professionals provide triage services and researchers get paid for relevant, verified bug reports.\")))), mdx(\"h3\", {\n    \"id\": \"common-smart-contract-vulnerabilities-and-exploits\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#common-smart-contract-vulnerabilities-and-exploits\",\n    \"aria-label\": \"common smart contract vulnerabilities and exploits permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Publications of known smart contract vulnerabilities and exploits\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://consensys.github.io/smart-contract-best-practices/attacks/\"\n  }, \"ConsenSys: Smart Contract Known Attacks\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Beginner-friendly explanation of the most significant contract vulnerabilities, with sample code for most cases.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://swcregistry.io/\"\n  }, \"SWC Registry\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Curated list of Common Weakness Enumeration (CWE) items that apply to Ethereum smart contracts.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://rekt.news/\"\n  }, \"Rekt\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Regularly updated publication of high-profile crypto hacks and exploits, along with detailed post-mortem reports.\")))), mdx(\"h3\", {\n    \"id\": \"challenges-for-learning-smart-contract-security\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#challenges-for-learning-smart-contract-security\",\n    \"aria-label\": \"challenges for learning smart contract security permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Challenges for learning smart contract security\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://github.com/blockthreat/blocksec-ctfs\"\n  }, \"Awesome BlockSec CTF\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Curated list of blockchain security wargames, challenges, and \", mdx(\"a\", {\n    parentName: \"em\",\n    \"href\": \"https://www.webopedia.com/definitions/ctf-event/amp/\"\n  }, \"Capture The Flag\"), \" competitions and solution writeups.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://www.damnvulnerabledefi.xyz/\"\n  }, \"Damn Vulnerable DeFi\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Wargame to learn offensive security of DeFi smart contracts and build skills in bug-hunting and security auditing.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://ethernaut.openzeppelin.com/\"\n  }, \"Ethernaut\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Web3/Solidity-based wargame where each level is a smart contract that needs to be 'hacked'.\")))), mdx(\"h3\", {\n    \"id\": \"smart-contract-security-best-practices\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#smart-contract-security-best-practices\",\n    \"aria-label\": \"smart contract security best practices permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Best practices for securing smart contracts\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://consensys.github.io/smart-contract-best-practices/\"\n  }, \"ConsenSys: Ethereum Smart Contract Security Best Practices\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Comprehensive list of guidelines for securing Ethereum smart contracts.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://github.com/nascentxyz/simple-security-toolkit\"\n  }, \"Nascent: Simple Security Toolkit\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Collection of practical security-focused guides and checklists for smart contract development.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://fravoll.github.io/solidity-patterns/\"\n  }, \"Solidity Patterns\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Useful compilation of secure patterns and best practices for the smart contract programming language Solidity.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://docs.soliditylang.org/en/v0.8.16/security-considerations.html\"\n  }, \"Solidity Docs: Security Considerations\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Guidelines for writing secure smart contracts with Solidity.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://github.com/securing/SCSVS\"\n  }, \"Smart Contract Security Verification Standard\")), \" - \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Fourteen-part checklist created to standardize the security of smart contracts for developers, architects, security reviewers and vendors.\")))), mdx(\"h3\", {\n    \"id\": \"tutorials-on-smart-contract-security\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#tutorials-on-smart-contract-security\",\n    \"aria-label\": \"tutorials on smart contract security permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Tutorials on smart contract security\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/tutorials/secure-development-workflow/\"\n  }, \"How to write secure smart contracts\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/tutorials/how-to-use-slither-to-find-smart-contract-bugs/\"\n  }, \"How to use Slither to find smart contract bugs\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/tutorials/how-to-use-manticore-to-find-smart-contract-bugs/\"\n  }, \"How to use Manticore to find smart contract bugs\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/tutorials/smart-contract-security-guidelines/\"\n  }, \"Smart contract security guidelines\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/tutorials/token-integration-checklist/\"\n  }, \"How to safely integrate your token contract with arbitrary tokens\")))));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#prerequisites-prerequisites","title":"Prerequisites {#prerequisites}"},{"url":"#guidelines-for-building-secure-ethereum-smart-contracts-smart-contract-security-guidelines","title":"Guidelines for building secure Ethereum smart contracts {#smart-contract-security-guidelines}","items":[{"url":"#1-design-proper-access-controls-design-proper-access-controls","title":"1. Design proper access controls {#design-proper-access-controls}","items":[{"url":"#ownable-pattern-ownable-pattern","title":"Ownable pattern {#ownable-pattern}"},{"url":"#role-based-access-control-role-based-access-control","title":"Role-based access control {#role-based-access-control}","items":[{"url":"#using-multi-signature-wallets","title":"Using multi-signature wallets"}]}]},{"url":"#2-use-require-assert-and-revert-statements-to-guard-contract-operations-use-require-assert-revert","title":"2. Use require(), assert(), and revert() statements to guard contract operations {#use-require-assert-revert}"},{"url":"#3-test-smart-contracts-and-verify-code-correctness-test-smart-contracts-and-verify-code-correctness","title":"3. Test smart contracts and verify code correctness {#test-smart-contracts-and-verify-code-correctness}"},{"url":"#4-ask-for-an-independent-review-of-your-code-get-independent-code-reviews","title":"4. Ask for an independent review of your code {#get-independent-code-reviews}","items":[{"url":"#audits-audits","title":"Audits {#audits}"},{"url":"#bug-bounties-bug-bounties","title":"Bug bounties {#bug-bounties}"}]},{"url":"#5-follow-best-practices-during-smart-contract-development-follow-smart-contract-development-best-practices","title":"5. Follow best practices during smart contract development {#follow-smart-contract-development-best-practices}"},{"url":"#6-implement-robust-disaster-recovery-plans-implement-disaster-recovery-plans","title":"6. Implement robust disaster recovery plans {#implement-disaster-recovery-plans}","items":[{"url":"#contract-upgrades-contract-upgrades","title":"Contract upgrades {#contract-upgrades}"},{"url":"#emergency-stops-emergency-stops","title":"Emergency stops {#emergency-stops}"},{"url":"#event-monitoring-event-monitoring","title":"Event monitoring {#event-monitoring}"}]},{"url":"#7-design-secure-governance-systems-design-secure-governance-systems","title":"7. Design secure governance systems {#design-secure-governance-systems}"},{"url":"#8-reduce-complexity-in-code-to-a-minimum-reduce-code-complexity","title":"8. Reduce complexity in code to a minimum {#reduce-code-complexity}"},{"url":"#9-defend-against-common-smart-contract-vulnerabilities-mitigate-common-smart-contract-vulnerabilities","title":"9. Defend against common smart contract vulnerabilities {#mitigate-common-smart-contract-vulnerabilities}","items":[{"url":"#reentrancy-reentrancy","title":"Reentrancy {#reentrancy}","items":[{"url":"#how-to-prevent-reentrancy-attacks","title":"How to prevent reentrancy attacks"}]},{"url":"#integer-underflows-and-overflows-integer-underflows-and-overflows","title":"Integer underflows and overflows {#integer-underflows-and-overflows}","items":[{"url":"#how-to-prevent-integer-underflows-and-overflows","title":"How to prevent integer underflows and overflows"}]},{"url":"#oracle-manipulation-oracle-manipulation","title":"Oracle manipulation {#oracle-manipulation}","items":[{"url":"#how-to-prevent-oracle-manipulation","title":"How to prevent oracle manipulation"}]}]}]},{"url":"#smart-contract-security-resources-for-developers-smart-contract-security-resources-for-developers","title":"Smart contract security resources for developers {#smart-contract-security-resources-for-developers}","items":[{"url":"#tools-for-analyzing-smart-contracts-and-verifying-code-correctness-code-analysis-tools","title":"Tools for analyzing smart contracts and verifying code correctness {#code-analysis-tools}"},{"url":"#tools-for-monitoring-smart-contracts-smart-contract-monitoring-tools","title":"Tools for monitoring smart contracts {#smart-contract-monitoring-tools}"},{"url":"#tools-for-secure-administration-of-smart-contracts-smart-contract-administration-tools","title":"Tools for secure administration of smart contracts {#smart-contract-administration-tools}"},{"url":"#smart-contract-auditing-services-smart-contract-auditing-services","title":"Smart contract auditing services {#smart-contract-auditing-services}"},{"url":"#bug-bounty-platforms-bug-bounty-platforms","title":"Bug bounty platforms {#bug-bounty-platforms}"},{"url":"#publications-of-known-smart-contract-vulnerabilities-and-exploits-common-smart-contract-vulnerabilities-and-exploits","title":"Publications of known smart contract vulnerabilities and exploits {#common-smart-contract-vulnerabilities-and-exploits}"},{"url":"#challenges-for-learning-smart-contract-security-challenges-for-learning-smart-contract-security","title":"Challenges for learning smart contract security {#challenges-for-learning-smart-contract-security}"},{"url":"#best-practices-for-securing-smart-contracts-smart-contract-security-best-practices","title":"Best practices for securing smart contracts {#smart-contract-security-best-practices}"},{"url":"#tutorials-on-smart-contract-security-tutorials-on-smart-contract-security","title":"Tutorials on smart contract security {#tutorials-on-smart-contract-security}"}]}]}}},"pageContext":{"language":"km","slug":"/km/developers/docs/smart-contracts/security/","ignoreTranslationBanner":false,"isLegal":false,"isOutdated":false,"isContentEnglish":true,"relativePath":"src/content/developers/docs/smart-contracts/security/index.md","locale":"km","hrefLang":"km","originalPath":"/developers/docs/smart-contracts/security/","dateFormat":"MM/DD/YYYY"}},"staticQueryHashes":["1239077767","3003422828","3280999885","446219633"],"slicesMap":{}}