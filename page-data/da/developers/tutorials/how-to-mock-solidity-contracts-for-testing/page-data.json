{"componentChunkName":"component---src-templates-tutorial-tsx","path":"/da/developers/tutorials/how-to-mock-solidity-contracts-for-testing/","result":{"data":{"siteData":{"siteMetadata":{"editContentUrl":"https://github.com/ethereum/ethereum-org-website/tree/dev/"}},"pageData":{"fields":{"slug":"/en/developers/tutorials/how-to-mock-solidity-contracts-for-testing/","readingTime":{"minutes":3.885}},"frontmatter":{"title":"How to mock Solidity smart contracts for testing","description":"Why you should make fun of your contracts when testing","lang":"en","tags":["solidity","smart contracts","testing","mocking"],"author":"Markus Waas","source":"soliditydeveloper.com","sourceUrl":"https://soliditydeveloper.com/mocking-contracts","skill":"intermediate","published":"2020-05-02T00:00:00.000Z","sidebarDepth":null,"address":null,"isOutdated":null,"postMergeBannerTranslation":null,"hideEditButton":null},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to mock Solidity smart contracts for testing\",\n  \"description\": \"Why you should make fun of your contracts when testing\",\n  \"author\": \"Markus Waas\",\n  \"lang\": \"en\",\n  \"tags\": [\"solidity\", \"smart contracts\", \"testing\", \"mocking\"],\n  \"skill\": \"intermediate\",\n  \"published\": \"2020-05-02T00:00:00.000Z\",\n  \"source\": \"soliditydeveloper.com\",\n  \"sourceUrl\": \"https://soliditydeveloper.com/mocking-contracts\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://wikipedia.org/wiki/Mock_object\"\n  }, \"Mock objects\"), \" are a common design pattern in object-oriented programming. Coming from the old French word 'mocquer' with the meaning of 'making fun of', it evolved to 'imitating something real' which is actually what we are doing in programming. Please only make fun of your smart contracts if you want to, but mock them whenever you can. It makes your life easier.\"), mdx(\"h2\", {\n    \"id\": \"unit-testing-contracts-with-mocks\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#unit-testing-contracts-with-mocks\",\n    \"aria-label\": \"unit testing contracts with mocks permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Unit-testing contracts with mocks\"), mdx(\"p\", null, \"Mocking a contract essentially means creating a second version of that contract which behaves very similar to the original one, but in a way that can be easily controlled by the developer. You often end up with complex contracts where you only want to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/smart-contracts/testing/\"\n  }, \"unit-test small parts of the contract\"), \". The problem is what if testing this small part requires a very specific contract state that is difficult to end up in?\"), mdx(\"p\", null, \"You could write complex test setup logic every time that brings in the contract in the required state or you write a mock. Mocking a contract is easy with inheritance. Simply create a second mock contract that inherits from the original one. Now you can override functions to your mock. Let us see it with an example.\"), mdx(\"h2\", {\n    \"id\": \"example-private-erc20\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#example-private-erc20\",\n    \"aria-label\": \"example private erc20 permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Example: Private ERC20\"), mdx(\"p\", null, \"We use an example ERC-20 contract that has an initial private time. The owner can manage private users and only those will be allowed to receive tokens at the beginning. Once a certain time has passed, everyone will be allowed to use the tokens. If you are curious, we are using the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.openzeppelin.com/contracts/3.x/extending-contracts#using-hooks\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"_beforeTokenTransfer\")), \" hook from the new OpenZeppelin contracts v3.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract PrivateERC20 is ERC20, Ownable {\\n    mapping (address => bool) public isPrivateUser;\\n    uint256 private publicAfterTime;\\n\\n    constructor(uint256 privateERC20timeInSec) ERC20(\\\"PrivateERC20\\\", \\\"PRIV\\\") public {\\n        publicAfterTime = now + privateERC20timeInSec;\\n    }\\n\\n    function addUser(address user) external onlyOwner {\\n        isPrivateUser[user] = true;\\n    }\\n\\n    function isPublic() public view returns (bool) {\\n        return now >= publicAfterTime;\\n    }\\n\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\\n        super._beforeTokenTransfer(from, to, amount);\\n\\n        require(_validRecipient(to), \\\"PrivateERC20: invalid recipient\\\");\\n    }\\n\\n    function _validRecipient(address to) private view returns (bool) {\\n        if (isPublic()) {\\n            return true;\\n        }\\n\\n        return isPrivateUser[to];\\n    }\\n}\\n\")), mdx(\"p\", null, \"And now let's mock it.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"pragma solidity ^0.6.0;\\nimport \\\"../PrivateERC20.sol\\\";\\n\\ncontract PrivateERC20Mock is PrivateERC20 {\\n    bool isPublicConfig;\\n\\n    constructor() public PrivateERC20(0) {}\\n\\n    function setIsPublic(bool isPublic) external {\\n        isPublicConfig = isPublic;\\n    }\\n\\n    function isPublic() public view returns (bool) {\\n        return isPublicConfig;\\n    }\\n}\\n\")), mdx(\"p\", null, \"You will get one of the following error messages:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"PrivateERC20Mock.sol: TypeError: Overriding function is missing \\\"override\\\" specifier.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"PrivateERC20.sol: TypeError: Trying to override non-virtual function. Did you forget to add \\\"virtual\\\"?.\"))), mdx(\"p\", null, \"Since we are using the new 0.6 Solidity version, we have to add the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"virtual\"), \" keyword for functions that can be overridden and override for the overriding function. So let us add those to both \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isPublic\"), \" functions.\"), mdx(\"p\", null, \"Now in your unit tests, you can use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PrivateERC20Mock\"), \" instead. When you want to test the behaviour during the private usage time, use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setIsPublic(false)\"), \" and likewise \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setIsPublic(true)\"), \" for testing the public usage time. Of course in our example, we could just use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.openzeppelin.com/test-helpers/0.5/api#increase\"\n  }, \"time helpers\"), \" to change the times accordingly as well. But the idea of mocking should be clear now and you can imagine scenarios where it is not as easy as simply advancing the time.\"), mdx(\"h2\", {\n    \"id\": \"mocking-many-contracts\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#mocking-many-contracts\",\n    \"aria-label\": \"mocking many contracts permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Mocking many contracts\"), mdx(\"p\", null, \"It can become messy if you have to create another contract for every single mock. If this bothers you, you can take a look at the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/gnosis/mock-contract\"\n  }, \"MockContract\"), \" library. It allows you to override and change behaviours of contracts on-the-fly. However, it works only for mocking calls to another contract, so it would not work for our example.\"), mdx(\"h2\", {\n    \"id\": \"mocking-can-be-even-more-powerful\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#mocking-can-be-even-more-powerful\",\n    \"aria-label\": \"mocking can be even more powerful permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Mocking can be even more powerful\"), mdx(\"p\", null, \"The powers of mocking do not end there.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Adding functions: Not only overriding a specific function is useful, but also just adding additional functions. A good example for tokens is just having an additional \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"mint\"), \" function to allow any user to get new tokens for free.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Usage in testnets: When you deploy and test your contracts on testnets together with your dapp, consider using a mocked version. Avoid overriding functions unless you really have to. You want to test the real logic after all. But adding for example a reset function can be useful that simply resets the contract state to the beginning, no new deployment required. Obviously you would not want to have that in a Mainnet contract.\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#unit-testing-contracts-with-mocks-unit-testing-contracts-with-mocks","title":"Unit-testing contracts with mocks {#unit-testing-contracts-with-mocks}"},{"url":"#example-private-erc20-example-private-erc20","title":"Example: Private ERC20 {#example-private-erc20}"},{"url":"#mocking-many-contracts-mocking-many-contracts","title":"Mocking many contracts {#mocking-many-contracts}"},{"url":"#mocking-can-be-even-more-powerful-mocking-can-be-even-more-powerful","title":"Mocking can be even more powerful {#mocking-can-be-even-more-powerful}"}]}}},"pageContext":{"language":"da","slug":"/da/developers/tutorials/how-to-mock-solidity-contracts-for-testing/","ignoreTranslationBanner":false,"isLegal":false,"isOutdated":false,"isContentEnglish":true,"relativePath":"src/content/developers/tutorials/how-to-mock-solidity-contracts-for-testing/index.md","locale":"da","hrefLang":"da","originalPath":"/developers/tutorials/how-to-mock-solidity-contracts-for-testing/","dateFormat":"MM/DD/YYYY"}},"staticQueryHashes":["1239077767","3003422828","3280999885","446219633"],"slicesMap":{}}