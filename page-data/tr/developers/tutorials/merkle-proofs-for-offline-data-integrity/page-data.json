{"componentChunkName":"component---src-templates-tutorial-tsx","path":"/tr/developers/tutorials/merkle-proofs-for-offline-data-integrity/","result":{"data":{"siteData":{"siteMetadata":{"editContentUrl":"https://github.com/ethereum/ethereum-org-website/tree/dev/"}},"pageData":{"fields":{"slug":"/en/developers/tutorials/merkle-proofs-for-offline-data-integrity/","readingTime":{"minutes":10.4}},"frontmatter":{"title":"Merkle proofs for offline data integrity","description":"Ensuring data integrity on chain for data that is stored, mostly, off chain","lang":"en","tags":["storage"],"author":"Ori Pomerantz","source":null,"sourceUrl":null,"skill":"advanced","published":"2021-12-30T00:00:00.000Z","sidebarDepth":null,"address":null,"isOutdated":null,"postMergeBannerTranslation":null,"hideEditButton":null},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Merkle proofs for offline data integrity\",\n  \"description\": \"Ensuring data integrity on chain for data that is stored, mostly, off chain\",\n  \"author\": \"Ori Pomerantz\",\n  \"tags\": [\"storage\"],\n  \"skill\": \"advanced\",\n  \"lang\": \"en\",\n  \"published\": \"2021-12-30T00:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", {\n    \"id\": \"introduction\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#introduction\",\n    \"aria-label\": \"introduction permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Introduction\"), mdx(\"p\", null, \"Ideally we'd like to store everything in Ethereum storage, which is stored across thousands of computers and has\\nextremely high availability (the data cannot be censored) and integrity (the data cannot be modified in an\\nunauthorized manner), but storing a 32-byte word typically costs 20,000 gas. As I'm writing this, that cost is\\nequivalent to $6.60. At 21 cents per byte this is too expensive for many uses.\"), mdx(\"p\", null, \"To solve this problem the Ethereum ecosystem developed \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/storage/\"\n  }, \"many alternative ways to store data in a decentralized\\nfashion\"), \". Usually they involve a tradeoff between availability\\nand price. However, integrity is usually assured.\"), mdx(\"p\", null, \"In this article you learn \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"how\"), \" to ensure data integrity without storing the data on the blockchain, using\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://computersciencewiki.org/index.php/Merkle_proof\"\n  }, \"Merkle proofs\"), \".\"), mdx(\"h2\", {\n    \"id\": \"how-does-it-work\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#how-does-it-work\",\n    \"aria-label\": \"how does it work permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"How does it work?\"), mdx(\"p\", null, \"In theory we could just store the hash of the data on chain, and send all the data in transactions that require it. However, this is still too expensive. A byte of data to a transaction costs about 16 gas, currently about half a cent, or about $5 per kilobyte. At $5000 per megabyte, this is still too expensive for many uses, even without the added cost of hashing the data.\"), mdx(\"p\", null, \"The solution is to repeatedly hash different subsets of the data, so for the data that you don't need to send you can just send a hash. You do this using a Merkle tree, a tree data structure where each node is a hash of the nodes below it:\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"564px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/6537c46782d963ff247eaa4e6cb1886c/ba4d9/tree.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"58.333333333333336%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB2klEQVR42m2Sba+iMBCF/f9/bJPNZve+qRdF5B1EQC+IILR9Nm1vXDHbpB86Mz1zzplZ8HSUUvbqx6WlXi9pAx+RRqhpmtX87yzuBY9gStqPZUETh+R5TudtTQNTJ+UM9BF88UBtznQcEZEPpwpVHZHlEZFEIITNPyiaMZx16i7cQh91yJCBh5rGeROdd1aIIodzbUGf5FtALUG/ipzU31OeTgzB/l58zx9zqigkjiL60Ie+v1s19/D7IYsD03ZN8/aHm5b3NCTZXxG7DRfP5frxahs+DtMwlBKGHnU8IOLQTvLSQFmAFP/Yae+aM5OzAh1rvlDhHuoS+XW+z2EhsoTC29FliTUdGJKI/O2FMUsRaWxirbuhjEJk21gPr1eq9ZKmaRDa8+bLSpZ5ytndkq5XjNo3YIoCjhuHynMRcWCb+B7Z8oM22Bs16trRug7p8oNu+2lVGg+7CypLIE+hbe77pwfEITUrY2Ja3qVFasDvOvMnjZA6N94sw363MQVD6DNEPup8ot98GmljEpu4qkp6b4uoK8Ykot/voOvoXYeprpiyhM51ULeBxeHnD7O8tbPi5KzhkFEt3w2zZrel0rE8pXh/YYxDhjigXr4ZNeWr3QbdNP/9y8j+Cz0sm7tBMDhCAAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Merkle Tree\",\n    \"title\": \"Merkle Tree\",\n    \"src\": \"/static/6537c46782d963ff247eaa4e6cb1886c/ba4d9/tree.png\",\n    \"srcSet\": [\"/static/6537c46782d963ff247eaa4e6cb1886c/5a46d/tree.png 300w\", \"/static/6537c46782d963ff247eaa4e6cb1886c/ba4d9/tree.png 564w\"],\n    \"sizes\": \"(max-width: 564px) 100vw, 564px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"The root hash is the only part that needs to be stored on chain. To prove a certain value, you provide all the hashes that need to be combined with it to obtain the root. For example, to prove \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"C\"), \" you provide \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"D\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"H(A-B)\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"H(E-H)\"), \".\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"564px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/d971703e4ef95e42df0d02a9ec51ec0b/ba4d9/proof-c.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"58.333333333333336%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACDklEQVR42m2SW2/TQBSE8///BbwAL1RCqKKioBakFhDQpjRJXbuJb7EdX3Lxxokde/dDG5coKT2SH7w7O2dmzunwpJRS7ad/loLpoIdwbJrAQ9X1Aea56uwA+2RKtg/TmNx3iaKI1dBELQX6Rsqmxey9OyB8bHuodLOh8WyYZagsQaYJMvCh2cNouidCO/vyVbGkcm3UJEQ6Q1S9OQDXxQLb+IQz+UU2e3jWfksoZdsojgjsEelsRumMWktKbS3qMrMLzr1jvruXfPReUa/FjvR/yzqbeEJtDshvrqjG3p6CNtN5GXM7fM+V/YE/vaNdhvtz6NBIqnLOKrFpfBf0JJc5pDHo8P+pb2pY5EhjoKcC+RLl2jBNkYv5bg4dI77gs/2Oq+iMbnCyPS/HHtHNNZswoNGDAIR1T+q5SJHTxBGsCrJBjzzPaXTm+aK1bMaXfLWOOOsfce0cbw8r1yG5N0iHJrVvt03sIWHvFuGMUMkEtSoQlkHQu6Uw76Bct5b1bs3DAfOoTyMepc8nkIQQxZDNWjfuaLvoUhOKvMVFAQQeUt9tqlbh+sEEUVC7Po1vkwaC8xOPLKzoii98S06R0xSNa6YZm7HHevQARcHaMqinGXU4prAMVFXSmfy42C5vdtdHWH38+xkvX4/xrTWnyRve2i9QcUiiM/VdSt9h2rsBkZN2220oXZvo98+t7b9HTpPSt9rJkgAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Proof of the value of C\",\n    \"title\": \"Proof of the value of C\",\n    \"src\": \"/static/d971703e4ef95e42df0d02a9ec51ec0b/ba4d9/proof-c.png\",\n    \"srcSet\": [\"/static/d971703e4ef95e42df0d02a9ec51ec0b/5a46d/proof-c.png 300w\", \"/static/d971703e4ef95e42df0d02a9ec51ec0b/ba4d9/proof-c.png 564w\"],\n    \"sizes\": \"(max-width: 564px) 100vw, 564px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"h2\", {\n    \"id\": \"implementation\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#implementation\",\n    \"aria-label\": \"implementation permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Implementation\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/qbzzt/merkle-proofs-for-offline-data-integrity\"\n  }, \"The sample code is provided here\"), \".\"), mdx(\"h3\", {\n    \"id\": \"off-chain-code\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#off-chain-code\",\n    \"aria-label\": \"off chain code permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Off-chain code\"), mdx(\"p\", null, \"In this article we use JavaScript for the off-chain computations. Most decentralized applications have their off-chain component in JavaScript.\"), mdx(\"h4\", {\n    \"id\": \"creating-the-merkle-root\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#creating-the-merkle-root\",\n    \"aria-label\": \"creating the merkle root permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Creating the Merkle root\"), mdx(\"p\", null, \"First we need to provide the Merkle root to the chain.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"const ethers = require(\\\"ethers\\\")\\n\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.ethers.io/v5/api/utils/hashing/#utils-keccak256\"\n  }, \"We use the hash function from the ethers package\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"// The raw data whose integrity we have to verify. The first two bytes a\\n// are a user identifier, and the last two bytes the amount of tokens the\\n// user owns at present.\\nconst dataArray = [\\n  0x0bad0010, 0x60a70020, 0xbeef0030, 0xdead0040, 0xca110050, 0x0e660060,\\n  0xface0070, 0xbad00080, 0x060d0091,\\n]\\n\")), mdx(\"p\", null, \"Encoding each entry into a single 256-bit integer results in less readable code than using JSON, for example. However, this means significantly less processing to retrieve the data in the contract, so much lower gas costs. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/chrisdotn/jsmnSol\"\n  }, \"You can read JSON on chain\"), \", it's just a bad idea if avoidable.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"// The array of hash values, as BigInts\\nconst hashArray = dataArray\\n\")), mdx(\"p\", null, \"In this case our data is 256-bit values to begin with, so no processing is needed. If we use a more complicated data structure, such as strings, we need to make sure we hash the data first to get an array of hashes. Note that this is also because we don't care if users know other users' information. Otherwise we would have had to hash so user 1 won't know the value for user 0, user 2 won't know the value for user 3, etc.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"// Convert between the string the hash function expects and the\\n// BigInt we use everywhere else.\\nconst hash = (x) =>\\n  BigInt(ethers.utils.keccak256(\\\"0x\\\" + x.toString(16).padStart(64, 0)))\\n\")), mdx(\"p\", null, \"The ethers hash function expects to get a JavaScript string with a hexadecimal number, such as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0x60A7\"), \", and responds with another string with the same structure. However, for the rest of the code it's easier to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BigInt\"), \", so we convert to a hexadecimal string and back again.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"// Symmetrical hash of a pair so we won't care if the order is reversed.\\nconst pairHash = (a, b) => hash(hash(a) ^ hash(b))\\n\")), mdx(\"p\", null, \"This function is symmetrical (hash of a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Exclusive_or\"\n  }, \"xor\"), \" b). This means that when we check the Merkle proof we don't need to worry about whether to put the value from the proof before or after the calculated value. Merkle proof checking is done on chain, so the less we need to do there the better.\"), mdx(\"p\", null, \"Warning:\\nCryptography is harder than it looks.\\nThe initial version of this article had the hash function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hash(a^b)\"), \".\\nThat was a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"bad\"), \" idea because it meant that if you knew the legitimate values of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b\"), \" you could use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b' = a^b^a'\"), \" to prove any desired \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a'\"), \" value.\\nWith this function you'd have to calculate \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b'\"), \" such that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hash(a') ^ hash(b')\"), \" is equal to a known value (the next branch on the way to root), which is a lot harder.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"// The value to denote that a certain branch is empty, doesn't\\n// have a value\\nconst empty = 0n\\n\")), mdx(\"p\", null, \"When the number of values is not an integer power of two we need to handle empty branches. The way this program does it is to put zero as a place holder.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"537px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/6b875700ecab9efd193c7e7394a50f29/b1cde/merkle-empty-hash.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"63.66666666666666%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAACEUlEQVR42l2TbVfiMBCF+f+/Zc/ZD+uu7qqgYkGooKJVK9sC8rKIoK1IqabJs6cJBWrOSZNmbu7MnZkU+DKUUulnvQqnyftFDdwWqu9vMFvr9ijkiFarkpIM+lk/YfBwz6x9hzovG0xqzxybS2bmCFcGle1TMqeFbFTAv0c83CBsC+HerjHbd3KEOW/zEPo+8rqJ6Hg5WelO9Drw6BvcMtqQfiXMDoKjPZ46HvKmAbOJIUoSM9Of6ZjR/g5vVzaqVV+nIOMprD0kiZFZKTKtHjO3DiF8MdJWOdPYyYh5tcRz/ZSPo12I4w1GR5gBgSQI+DwtgRSorkfycLeWmkUhnBZqPDT4ns9n6yJXAyM5eCG+PgfrABW+aqPsd4hKu7pd1tKHXZYnf+D+Cvn+ZkjtMnHDgkfPRKiZnQa9Ro2pbSH/3prLTpOeXeVFn60ibdXxaxZBvYwadGH6hLg849m5gssqKhEmQum3SaolovK+jlCfjYfIZoXIKiJfZ4Zw1EdYRR2lipcmT902eHeoyWhV5XmoW0QuI7i0QQgjpXmG/PiAnqeJNKHrIMMQNXwEz93kd+txFKJKkUW1pPM0+/mNxHcRvsv893fda+HhDov6CQQzXg9+ILttxE2DoLwPTwNDmHaIWlV5aZ+ytMuwmBOmkp/HiH8D4toxxBGLyqEpWDBjXvqF6rj6fWsnk1HulaSS/wOQ7NzsJWFqwgAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Merkle tree with branches missing\",\n    \"title\": \"Merkle tree with branches missing\",\n    \"src\": \"/static/6b875700ecab9efd193c7e7394a50f29/b1cde/merkle-empty-hash.png\",\n    \"srcSet\": [\"/static/6b875700ecab9efd193c7e7394a50f29/5a46d/merkle-empty-hash.png 300w\", \"/static/6b875700ecab9efd193c7e7394a50f29/b1cde/merkle-empty-hash.png 537w\"],\n    \"sizes\": \"(max-width: 537px) 100vw, 537px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"// Calculate one level up the tree of a hash array by taking the hash of\\n// each pair in sequence\\nconst oneLevelUp = (inputArray) => {\\n  var result = []\\n  var inp = [...inputArray] // To avoid over writing the input // Add an empty value if necessary (we need all the leaves to be // paired)\\n\\n  if (inp.length % 2 === 1) inp.push(empty)\\n\\n  for (var i = 0; i < inp.length; i += 2)\\n    result.push(pairHash(inp[i], inp[i + 1]))\\n\\n  return result\\n} // oneLevelUp\\n\")), mdx(\"p\", null, \"This function \\\"climbs\\\" one level in the Merkle tree by hashing the pairs of values at the current layer. Note that this is not the most efficient implementation, we could have avoided copying the input and just added \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hashEmpty\"), \" when appropriate in the loop, but this code is optimized for readability.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"const getMerkleRoot = (inputArray) => {\\n  var result\\n\\n  result = [...inputArray] // Climb up the tree until there is only one value, that is the // root. // // If a layer has an odd number of entries the // code in oneLevelUp adds an empty value, so if we have, for example, // 10 leaves we'll have 5 branches in the second layer, 3 // branches in the third, 2 in the fourth and the root is the fifth\\n\\n  while (result.length > 1) result = oneLevelUp(result)\\n\\n  return result[0]\\n}\\n\")), mdx(\"p\", null, \"To get the root, climb until there is only one value left.\"), mdx(\"h4\", {\n    \"id\": \"creating-a-merkle-proof\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#creating-a-merkle-proof\",\n    \"aria-label\": \"creating a merkle proof permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Creating a Merkle proof\"), mdx(\"p\", null, \"A Merkle proof is the values to hash together with the value being proved to get back the Merkle root. The value to prove is often available from other data, so I prefer to provide it separately rather than as part of the code.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"// A merkle proof consists of the value of the list of entries to\\n// hash with. Because we use a symmetrical hash function, we don't\\n// need the item's location to verify the proof, only to create it\\nconst getMerkleProof = (inputArray, n) => {\\n\\xA0 \\xA0 var result = [], currentLayer = [...inputArray], currentN = n\\n\\n\\xA0 \\xA0 // Until we reach the top\\n\\xA0 \\xA0 while (currentLayer.length > 1) {\\n\\xA0 \\xA0 \\xA0 \\xA0 // No odd length layers\\n\\xA0 \\xA0 \\xA0 \\xA0 if (currentLayer.length % 2)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 currentLayer.push(empty)\\n\\n\\xA0 \\xA0 \\xA0 \\xA0 result.push(currentN % 2\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0// If currentN is odd, add with the value before it to the proof\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 ? currentLayer[currentN-1]\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0// If it is even, add the value after it\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 : currentLayer[currentN+1])\\n\\n\")), mdx(\"p\", null, \"We hash \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(v[0],v[1])\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(v[2],v[3])\"), \", etc. So for even values we need the next one, for odd values the previous one.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"\\xA0 \\xA0 \\xA0 \\xA0 // Move to the next layer up\\n\\xA0 \\xA0 \\xA0 \\xA0 currentN = Math.floor(currentN/2)\\n\\xA0 \\xA0 \\xA0 \\xA0 currentLayer = oneLevelUp(currentLayer)\\n\\xA0 \\xA0 } \\xA0 // while currentLayer.length > 1\\n\\n\\xA0 \\xA0 return result\\n} \\xA0 // getMerkleProof\\n\")), mdx(\"h3\", {\n    \"id\": \"on-chain-code\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#on-chain-code\",\n    \"aria-label\": \"on chain code permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"On-chain code\"), mdx(\"p\", null, \"Finally we have the code that checks the proof. The on-chain code is written in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.soliditylang.org/en/v0.8.11/\"\n  }, \"Solidity\"), \". Optimization is a lot more important here because gas is relatively expensive.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"//SPDX-License-Identifier: Public Domain\\npragma solidity ^0.8.0;\\n\\nimport \\\"hardhat/console.sol\\\";\\n\")), mdx(\"p\", null, \"I wrote this using the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://hardhat.org/\"\n  }, \"Hardhat development environment\"), \", which allows us to have \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://hardhat.org/tutorial/debugging-with-hardhat-network.html\"\n  }, \"console output from Solidity\"), \" while developing.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"\\ncontract MerkleProof {\\n\\xA0 \\xA0 uint merkleRoot;\\n\\n\\xA0 \\xA0 function getRoot() public view returns (uint) {\\n\\xA0 \\xA0 \\xA0 return merkleRoot;\\n\\xA0 \\xA0 }\\n\\n\\xA0 \\xA0 // Extremely insecure, in production code access to\\n\\xA0 \\xA0 // this function MUST BE strictly limited, probably to an\\n\\xA0 \\xA0 // owner\\n\\xA0 \\xA0 function setRoot(uint _merkleRoot) external {\\n\\xA0 \\xA0 \\xA0 merkleRoot = _merkleRoot;\\n\\xA0 \\xA0 } \\xA0 // setRoot\\n\")), mdx(\"p\", null, \"Set and get functions for the Merkle root. Letting everybody update the Merkle root is an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"extremely bad idea\"), \" in a production system. I do it here for the sake of simplicity for sample code. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Don't do it on a system where data integrity actually matters\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"\\xA0 \\xA0 function hash(uint _a) internal pure returns(uint) {\\n\\xA0 \\xA0 \\xA0 return uint(keccak256(abi.encode(_a)));\\n\\xA0 \\xA0 }\\n\\n\\xA0 \\xA0 function pairHash(uint _a, uint _b) internal pure returns(uint) {\\n\\xA0 \\xA0 \\xA0 return hash(hash(_a) ^ hash(_b));\\n\\xA0 \\xA0 }\\n\")), mdx(\"p\", null, \"This function generates a pair hash. It is just the Solidity translation of the JavaScript code for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"hash\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pairHash\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Note:\"), \" This is another case of optimization for readability. Based on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.tutorialspoint.com/solidity/solidity_cryptographic_functions.htm\"\n  }, \"the function definition\"), \", it might be possible to store the data as a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.soliditylang.org/en/v0.5.3/types.html#fixed-size-byte-arrays\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"bytes32\")), \" value and avoid the conversions.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"\\xA0 \\xA0 // Verify a Merkle proof\\n\\xA0 \\xA0 function verifyProof(uint _value, uint[] calldata _proof)\\n\\xA0 \\xA0 \\xA0 \\xA0 public view returns (bool) {\\n\\xA0 \\xA0 \\xA0 uint temp = _value;\\n\\xA0 \\xA0 \\xA0 uint i;\\n\\n\\xA0 \\xA0 \\xA0 for(i=0; i<_proof.length; i++) {\\n\\xA0 \\xA0 \\xA0 \\xA0 temp = pairHash(temp, _proof[i]);\\n\\xA0 \\xA0 \\xA0 }\\n\\n\\xA0 \\xA0 \\xA0 return temp == merkleRoot;\\n\\xA0 \\xA0 }\\n\\n} \\xA0// MarkleProof\\n\")), mdx(\"p\", null, \"In mathematical notation Merkle proof verification looks like this: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"H(proof_n, H(proof_n-1, H(proof_n-2, ... H(proof_1, H(proof_0, value))...)))\"), \". This code implements it.\"), mdx(\"h2\", {\n    \"id\": \"merkle-proofs-and-rollups\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#merkle-proofs-and-rollups\",\n    \"aria-label\": \"merkle proofs and rollups permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Merkle proofs and rollups don't mix\"), mdx(\"p\", null, \"Merkle proofs don't work well with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/scaling/#rollups\"\n  }, \"rollups\"), \". The reason is that rollups write all the transaction data on L1, but process on L2. The cost to send a Merkle proof with a transaction averages to 638 gas per layer (currently a byte in call data costs 16 gas if it isn't zero, and 4 if it is zero). If we have 1024 words of data, a Merkle proof requires ten layers, or a total of 6380 gas.\"), mdx(\"p\", null, \"Looking for example at \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://public-grafana.optimism.io/d/9hkhMxn7z/public-dashboard?orgId=1&refresh=5m\"\n  }, \"Optimism\"), \", writing L1 gas costs about 100 gwei and L2 gas costs 0.001 gwei (that is the normal price, it can rise with congestion). So for the cost of one L1 gas we can spend a hundred thousand gas on L2 processing. Assuming we don't overwrite storage, this means that we can write about five words to storage on L2 for the price of one L1 gas. For a single Merkle proof we can write the entire 1024 words to storage (assuming they can be calculated on chain to begin with, rather than provided in a transaction) and still have most of the gas left over.\"), mdx(\"h2\", {\n    \"id\": \"conclusion\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#conclusion\",\n    \"aria-label\": \"conclusion permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Conclusion\"), mdx(\"p\", null, \"In real life you might never implement Merkle trees on your own. There are well known and audited libraries you can use and generally speaking it is best not to implement cryptographic primitives on your own. But I hope that now you understand Merkle proofs better and can decide when they are worth using.\"), mdx(\"p\", null, \"Note that while Merkle proofs preserve \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"integrity\"), \", they do not preserve \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"availability\"), \". Knowing that nobody else can take your assets is small consolation if the data storage decides to disallow access and you can't construct a Merkle tree to access them either. So Merkle trees are best used with some kind of decentralized storage, such as IPFS.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#introduction-introduction","title":"Introduction {#introduction}"},{"url":"#how-does-it-work-how-does-it-work","title":"How does it work? {#how-does-it-work}"},{"url":"#implementation-implementation","title":"Implementation {#implementation}","items":[{"url":"#off-chain-code-off-chain-code","title":"Off-chain code {#off-chain-code}","items":[{"url":"#creating-the-merkle-root-creating-the-merkle-root","title":"Creating the Merkle root {#creating-the-merkle-root}"},{"url":"#creating-a-merkle-proof-creating-a-merkle-proof","title":"Creating a Merkle proof {#creating-a-merkle-proof}"}]},{"url":"#on-chain-code-on-chain-code","title":"On-chain code {#on-chain-code}"}]},{"url":"#merkle-proofs-and-rollups-dont-mix-merkle-proofs-and-rollups","title":"Merkle proofs and rollups don't mix {#merkle-proofs-and-rollups}"},{"url":"#conclusion-conclusion","title":"Conclusion {#conclusion}"}]}}},"pageContext":{"language":"tr","slug":"/tr/developers/tutorials/merkle-proofs-for-offline-data-integrity/","ignoreTranslationBanner":false,"isLegal":false,"isOutdated":false,"isContentEnglish":true,"relativePath":"src/content/developers/tutorials/merkle-proofs-for-offline-data-integrity/index.md","locale":"tr","hrefLang":"tr","originalPath":"/developers/tutorials/merkle-proofs-for-offline-data-integrity/","dateFormat":"MM/DD/YYYY"}},"staticQueryHashes":["1239077767","3003422828","3280999885","446219633"],"slicesMap":{}}