{"componentChunkName":"component---src-templates-docs-tsx","path":"/uk/developers/docs/consensus-mechanisms/pow/mining-algorithms/dagger-hashimoto/","result":{"data":{"siteData":{"siteMetadata":{"editContentUrl":"https://github.com/ethereum/ethereum-org-website/tree/dev/"}},"pageData":{"fields":{"slug":"/en/developers/docs/consensus-mechanisms/pow/mining-algorithms/dagger-hashimoto/"},"frontmatter":{"title":"Dagger-Hashimoto","description":"A detailed look at the Dagger-Hashimoto algorithm.","lang":"en","incomplete":null,"sidebarDepth":null,"isOutdated":null,"hideEditButton":null},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Dagger-Hashimoto\",\n  \"description\": \"A detailed look at the Dagger-Hashimoto algorithm.\",\n  \"lang\": \"en\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Dagger-Hashimoto was the original research implementation and specification for Ethereum's mining algorithm. Dagger-Hashimoto was superseded by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#ethash\"\n  }, \"Ethash\"), \". Mining was switched off completely at \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/updates/merge\"\n  }, \"The Merge\"), \" on 15th September 2022. Since then, Ethereum has been secured using a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/consensus-mechanisms/pos\"\n  }, \"proof-of-stake\"), \" mechanism instead. This page is for historical interest - the information here is no longer relevant for post-Merge Ethereum.\"), mdx(\"h2\", {\n    \"id\": \"prerequisites\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#prerequisites\",\n    \"aria-label\": \"prerequisites permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Prerequisites\"), mdx(\"p\", null, \"To better understand this page, we recommend you first read up on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/consensus-mechanisms/pow\"\n  }, \"proof-of-work consensus\"), \", \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/consensus-mechanisms/pow/mining\"\n  }, \"mining\"), \", and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/consensus-mechanisms/pow/mining/mining-algorithms\"\n  }, \"mining algorithms\"), \".\"), mdx(\"h2\", {\n    \"id\": \"dagger-hashimoto\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#dagger-hashimoto\",\n    \"aria-label\": \"dagger hashimoto permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Dagger-Hashimoto\"), mdx(\"p\", null, \"Dagger-Hashimoto aims to satisfy two goals:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"ASIC-resistance\"), \": the benefit from creating specialized hardware for the algorithm should be as small as possible\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Light client verifiability\"), \": a block should be efficiently verifiable by a light client.\")), mdx(\"p\", null, \"With an additional modification, we also specify how to fulfill a third goal if desired, but at the cost of additional complexity:\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Full chain storage\"), \": mining should require storage of the complete blockchain state (due to the irregular structure of the Ethereum state trie, we anticipate that some pruning will be possible, particularly of some often-used contracts, but we want to minimize this).\"), mdx(\"h2\", {\n    \"id\": \"dag-generation\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#dag-generation\",\n    \"aria-label\": \"dag generation permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"DAG Generation\"), mdx(\"p\", null, \"The code for the algorithm will be defined in Python below. First, we give \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"encode_int\"), \" for marshaling unsigned ints of specified precision to strings. Its inverse is also given:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"NUM_BITS = 512\\n\\ndef encode_int(x):\\n    \\\"Encode an integer x as a string of 64 characters using a big-endian scheme\\\"\\n    o = ''\\n    for _ in range(NUM_BITS / 8):\\n        o = chr(x % 256) + o\\n        x //= 256\\n    return o\\n\\ndef decode_int(s):\\n    \\\"Unencode an integer x from a string using a big-endian scheme\\\"\\n    x = 0\\n    for c in s:\\n        x *= 256\\n        x += ord(c)\\n    return x\\n\")), mdx(\"p\", null, \"We next assume that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sha3\"), \" is a function that takes an integer and outputs an integer, and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dbl_sha3\"), \" is a double-sha3 function; if converting this reference code into an implementation use:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from pyethereum import utils\\ndef sha3(x):\\n    if isinstance(x, (int, long)):\\n        x = encode_int(x)\\n    return decode_int(utils.sha3(x))\\n\\ndef dbl_sha3(x):\\n    if isinstance(x, (int, long)):\\n        x = encode_int(x)\\n    return decode_int(utils.sha3(utils.sha3(x)))\\n\")), mdx(\"h3\", {\n    \"id\": \"parameters\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#parameters\",\n    \"aria-label\": \"parameters permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Parameters\"), mdx(\"p\", null, \"The parameters used for the algorithm are:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"SAFE_PRIME_512 = 2**512 - 38117     # Largest Safe Prime less than 2**512\\n\\nparams = {\\n      \\\"n\\\": 4000055296 * 8 // NUM_BITS,  # Size of the dataset (4 Gigabytes); MUST BE MULTIPLE OF 65536\\n      \\\"n_inc\\\": 65536,                   # Increment in value of n per period; MUST BE MULTIPLE OF 65536\\n                                        # with epochtime=20000 gives 882 MB growth per year\\n      \\\"cache_size\\\": 2500,               # Size of the light client's cache (can be chosen by light\\n                                        # client; not part of the algo spec)\\n      \\\"diff\\\": 2**14,                    # Difficulty (adjusted during block evaluation)\\n      \\\"epochtime\\\": 100000,              # Length of an epoch in blocks (how often the dataset is updated)\\n      \\\"k\\\": 1,                           # Number of parents of a node\\n      \\\"w\\\": w,                          # Used for modular exponentiation hashing\\n      \\\"accesses\\\": 200,                  # Number of dataset accesses during hashimoto\\n      \\\"P\\\": SAFE_PRIME_512               # Safe Prime for hashing and random number generation\\n}\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"P\"), \" in this case is a prime chosen such that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"log\\u2082(P)\"), \" is just slightly less than 512, which corresponds to the 512 bits we have been using to represent our numbers. Note that only the latter half of the DAG actually needs to be stored, so the de-facto RAM requirement starts at 1 GB and grows by 441 MB per year.\"), mdx(\"h3\", {\n    \"id\": \"dagger-graph-building\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#dagger-graph-building\",\n    \"aria-label\": \"dagger graph building permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Dagger graph building\"), mdx(\"p\", null, \"The dagger graph building primitive is defined as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def produce_dag(params, seed, length):\\n    P = params[\\\"P\\\"]\\n    picker = init = pow(sha3(seed), params[\\\"w\\\"], P)\\n    o = [init]\\n    for i in range(1, length):\\n        x = picker = (picker * init) % P\\n        for _ in range(params[\\\"k\\\"]):\\n            x ^= o[x % i]\\n        o.append(pow(x, params[\\\"w\\\"], P))\\n    return o\\n\")), mdx(\"p\", null, \"Essentially, it starts off a graph as a single node, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sha3(seed)\"), \", and from there starts sequentially adding on other nodes based on random previous nodes. When a new node is created, a modular power of the seed is computed to randomly select some indices less than \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i\"), \" (using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x % i\"), \" above), and the values of the nodes at those indices are used in a calculation to generate a new a value for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \", which is then fed into a small proof of work function (based on XOR) to ultimately generate the value of the graph at index \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i\"), \". The rationale behind this particular design is to force sequential access of the DAG; the next value of the DAG that will be accessed cannot be determined until the current value is known. Finally, modular exponentiation hashes the result further.\"), mdx(\"p\", null, \"This algorithm relies on several results from number theory. See the appendix below for a discussion.\"), mdx(\"h2\", {\n    \"id\": \"light-client-evaluation\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#light-client-evaluation\",\n    \"aria-label\": \"light client evaluation permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Light client evaluation\"), mdx(\"p\", null, \"The above graph construction intends to allow each node in the graph to be reconstructed by computing a subtree of only a small number of nodes and requiring only a small amount of auxiliary memory. Note that with k=1, the subtree is only a chain of values going up to the first element in the DAG.\"), mdx(\"p\", null, \"The light client computing function for the DAG works as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def quick_calc(params, seed, p):\\n    w, P = params[\\\"w\\\"], params[\\\"P\\\"]\\n    cache = {}\\n\\n    def quick_calc_cached(p):\\n        if p in cache:\\n            pass\\n        elif p == 0:\\n            cache[p] = pow(sha3(seed), w, P)\\n        else:\\n            x = pow(sha3(seed), (p + 1) * w, P)\\n            for _ in range(params[\\\"k\\\"]):\\n                x ^= quick_calc_cached(x % p)\\n            cache[p] = pow(x, w, P)\\n        return cache[p]\\n\\n    return quick_calc_cached(p)\\n\")), mdx(\"p\", null, \"Essentially, it is simply a rewrite of the above algorithm that removes the loop of computing the values for the entire DAG and replaces the earlier node lookup with a recursive call or a cache lookup. Note that for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"k=1\"), \" the cache is unnecessary, although a further optimization actually precomputes the first few thousand values of the DAG and keeps that as a static cache for computations; see the appendix for a code implementation of this.\"), mdx(\"h2\", {\n    \"id\": \"double-buffer\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#double-buffer\",\n    \"aria-label\": \"double buffer permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Double buffer of DAGs\"), mdx(\"p\", null, \"In a full client, a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://wikipedia.org/wiki/Multiple_buffering\"\n  }, mdx(\"em\", {\n    parentName: \"a\"\n  }, \"double buffer\")), \" of 2 DAGs produced by the above formula is used. The idea is that DAGs are produced every \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"epochtime\"), \" number of blocks according to the params above. Instead of the client using the latest DAG produced, it uses the one previous. The benefit of this is that it allows the DAGs to be replaced over time without needing to incorporate a step where miners must suddenly recompute all of the data. Otherwise, there is the potential for an abrupt temporary slowdown in chain processing at regular intervals and dramatically increasing centralization. Thus 51% attack risks within those few minutes before all data are recomputed.\"), mdx(\"p\", null, \"The algorithm used to generate the set of DAGs used to compute the work for a block is as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def get_prevhash(n):\\n    from pyethereum.blocks import GENESIS_PREVHASH\\n    from pyethereum import chain_manager\\n    if num <= 0:\\n        return hash_to_int(GENESIS_PREVHASH)\\n    else:\\n        prevhash = chain_manager.index.get_block_by_number(n - 1)\\n        return decode_int(prevhash)\\n\\ndef get_seedset(params, block):\\n    seedset = {}\\n    seedset[\\\"back_number\\\"] = block.number - (block.number % params[\\\"epochtime\\\"])\\n    seedset[\\\"back_hash\\\"] = get_prevhash(seedset[\\\"back_number\\\"])\\n    seedset[\\\"front_number\\\"] = max(seedset[\\\"back_number\\\"] - params[\\\"epochtime\\\"], 0)\\n    seedset[\\\"front_hash\\\"] = get_prevhash(seedset[\\\"front_number\\\"])\\n    return seedset\\n\\ndef get_dagsize(params, block):\\n    return params[\\\"n\\\"] + (block.number // params[\\\"epochtime\\\"]) * params[\\\"n_inc\\\"]\\n\\ndef get_daggerset(params, block):\\n    dagsz = get_dagsize(params, block)\\n    seedset = get_seedset(params, block)\\n    if seedset[\\\"front_hash\\\"] <= 0:\\n        # No back buffer is possible, just make front buffer\\n        return {\\\"front\\\": {\\\"dag\\\": produce_dag(params, seedset[\\\"front_hash\\\"], dagsz),\\n                          \\\"block_number\\\": 0}}\\n    else:\\n        return {\\\"front\\\": {\\\"dag\\\": produce_dag(params, seedset[\\\"front_hash\\\"], dagsz),\\n                          \\\"block_number\\\": seedset[\\\"front_number\\\"]},\\n                \\\"back\\\": {\\\"dag\\\": produce_dag(params, seedset[\\\"back_hash\\\"], dagsz),\\n                         \\\"block_number\\\": seedset[\\\"back_number\\\"]}}\\n\")), mdx(\"h2\", {\n    \"id\": \"hashimoto\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#hashimoto\",\n    \"aria-label\": \"hashimoto permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Hashimoto\"), mdx(\"p\", null, \"The idea behind the original Hashimoto is to use the blockchain as a dataset, performing a computation that selects N indices from the blockchain, gathers the transactions at those indices, performs an XOR of this data, and returns the hash of the result. Thaddeus Dryja's original algorithm, translated to Python for consistency, is as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def orig_hashimoto(prev_hash, merkle_root, list_of_transactions, nonce):\\n    hash_output_A = sha256(prev_hash + merkle_root + nonce)\\n    txid_mix = 0\\n    for i in range(64):\\n        shifted_A = hash_output_A >> i\\n        transaction = shifted_A % len(list_of_transactions)\\n        txid_mix ^= list_of_transactions[transaction] << i\\n    return txid_max ^ (nonce << 192)\\n\")), mdx(\"p\", null, \"Unfortunately, while Hashimoto is considered RAM hard, it relies on 256-bit arithmetic, which has considerable computational overhead. However, Dagger-Hashimoto only uses the least significant 64 bits when indexing its dataset to address this issue.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def hashimoto(dag, dagsize, params, header, nonce):\\n    m = dagsize / 2\\n    mix = sha3(encode_int(nonce) + header)\\n    for _ in range(params[\\\"accesses\\\"]):\\n        mix ^= dag[m + (mix % 2**64) % m]\\n    return dbl_sha3(mix)\\n\")), mdx(\"p\", null, \"The use of double SHA3 allows for a form of zero-data, near-instant pre-verification, verifying only that a correct intermediate value was provided. This outer layer of proof-of-work is highly ASIC-friendly and fairly weak, but exists to make DDoS even more difficult since that small amount of work must be done in order to produce a block that will not be rejected immediately. Here is the light-client version:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def quick_hashimoto(seed, dagsize, params, header, nonce):\\n    m = dagsize // 2\\n    mix = sha3(nonce + header)\\n    for _ in range(params[\\\"accesses\\\"]):\\n        mix ^= quick_calc(params, seed, m + (mix % 2**64) % m)\\n    return dbl_sha3(mix)\\n\")), mdx(\"h2\", {\n    \"id\": \"mining-and-verifying\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#mining-and-verifying\",\n    \"aria-label\": \"mining and verifying permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Mining and verifying\"), mdx(\"p\", null, \"Now, let us put it all together into the mining algorithm:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def mine(daggerset, params, block):\\n    from random import randint\\n    nonce = randint(0, 2**64)\\n    while 1:\\n        result = hashimoto(daggerset, get_dagsize(params, block),\\n                           params, decode_int(block.prevhash), nonce)\\n        if result * params[\\\"diff\\\"] < 2**256:\\n            break\\n        nonce += 1\\n        if nonce >= 2**64:\\n            nonce = 0\\n    return nonce\\n\")), mdx(\"p\", null, \"Here is the verification algorithm:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def verify(daggerset, params, block, nonce):\\n    result = hashimoto(daggerset, get_dagsize(params, block),\\n                       params, decode_int(block.prevhash), nonce)\\n    return result * params[\\\"diff\\\"] < 2**256\\n\")), mdx(\"p\", null, \"Light-client friendly verification:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def light_verify(params, header, nonce):\\n    seedset = get_seedset(params, block)\\n    result = quick_hashimoto(seedset[\\\"front_hash\\\"], get_dagsize(params, block),\\n                             params, decode_int(block.prevhash), nonce)\\n    return result * params[\\\"diff\\\"] < 2**256\\n\")), mdx(\"p\", null, \"Also, note that Dagger-Hashimoto imposes additional requirements on the block header:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"For two-layer verification to work, a block header must have both the nonce and the middle value pre-sha3\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Somewhere, a block header must store the sha3 of the current seedset\")), mdx(\"h2\", {\n    \"id\": \"further-reading\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#further-reading\",\n    \"aria-label\": \"further reading permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Further reading\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Know of a community resource that helped you? Edit this page and add it!\")), mdx(\"h2\", {\n    \"id\": \"appendix\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#appendix\",\n    \"aria-label\": \"appendix permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Appendix\"), mdx(\"p\", null, \"As noted above, the RNG used for DAG generation relies on some results from number theory. First, we provide assurance that the Lehmer RNG that is the basis for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"picker\"), \" variable has a wide period. Second, we show that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pow(x,3,P)\"), \" will not map \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"P-1\"), \" provided \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x \\u2208 [2,P-2]\"), \" to start. Finally, we show that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pow(x,3,P)\"), \" has a low collision rate when treated as a hashing function.\"), mdx(\"h3\", {\n    \"id\": \"lehmer-random-number\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#lehmer-random-number\",\n    \"aria-label\": \"lehmer random number permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Lehmer random number generator\"), mdx(\"p\", null, \"While the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"produce_dag\"), \" function does not need to produce unbiased random numbers, a potential threat is that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"seed**i % P\"), \" only takes on a handful of values. This could provide an advantage to miners recognizing the pattern over those that do not.\"), mdx(\"p\", null, \"To avoid this, a result from number theory is appealed to. A \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Safe_prime\"\n  }, mdx(\"em\", {\n    parentName: \"a\"\n  }, \"Safe Prime\")), \" is defined to be a prime \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"P\"), \" such that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(P-1)/2\"), \" is also prime. The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"order\"), \" of a member \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" of the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Multiplicative_group_of_integers_modulo_n\"\n  }, \"multiplicative group\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\u2124/n\\u2124\"), \" is defined to be the minimal \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"m\"), \" such that \", mdx(\"pre\", null, \"x\\u1D50 mod P \\u2261 1\"), \"\\nGiven these definitions, we have:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Observation 1. Let \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" be a member of the multiplicative group \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\u2124/P\\u2124\"), \" for a safe prime \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"P\"), \". If \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x mod P \\u2260 1 mod P\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x mod P \\u2260 P-1 mod P\"), \", then the order of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" is either \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"P-1\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(P-1)/2\"), \".\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Proof\"), \". Since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"P\"), \" is a safe prime, then by \", \"[Lagrange's Theorem][lagrange]\", \" we have that the order of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" is either \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"2\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(P-1)/2\"), \", or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"P-1\"), \".\"), mdx(\"p\", null, \"The order of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" cannot be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1\"), \", since by Fermat's Little Theorem we have:\"), mdx(\"pre\", null, \"x\", mdx(\"sup\", null, \"P-1\"), \" mod P \\u2261 1\"), mdx(\"p\", null, \"Hence \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" must be a multiplicative identity of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\u2124/n\\u2124\"), \", which is unique. Since we assumed that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x \\u2260 1\"), \" by assumption, this is not possible.\"), mdx(\"p\", null, \"The order of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" cannot be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"2\"), \" unless \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x = P-1\"), \", since this would violate that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"P\"), \" is prime.\"), mdx(\"p\", null, \"From the above proposition, we can recognize that iterating \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(picker * init) % P\"), \" will have a cycle length of at least \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(P-1)/2\"), \". This is because we selected \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"P\"), \" to be a safe prime approximately equal to be a higher power of two, and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"init\"), \" is in the interval \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[2,2**256+1]\"), \". Given the magnitude fo \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"P\"), \", we should never expect a cycle from modular exponentiation.\"), mdx(\"p\", null, \"When we are assigning the first cell in the DAG (the variable labeled \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"init\"), \"), we compute \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pow(sha3(seed) + 2, 3, P)\"), \". At first glance, this does not guarantee that the result is neither \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1\"), \" nor \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"P-1\"), \". However, since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"P-1\"), \" is a safe prime, we have the following additional assurance, which is a corollary of Observation 1:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Observation 2. Let \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\"), \" be a member of the multiplicative group \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\u2124/P\\u2124\"), \" for a safe prime \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"P\"), \", and let \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"w\"), \" be a natural number. If \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x mod P \\u2260 1 mod P\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x mod P \\u2260 P-1 mod P\"), \", as well as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"w mod P \\u2260 P-1 mod P\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"w mod P \\u2260 0 mod P\"), \", then \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\\u02B7 mod P \\u2260 1 mod P\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x\\u02B7 mod P \\u2260 P-1 mod P\"))), mdx(\"h3\", {\n    \"id\": \"modular-exponentiation\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#modular-exponentiation\",\n    \"aria-label\": \"modular exponentiation permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Modular exponentiation as a hash function\"), mdx(\"p\", null, \"For certain values of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"P\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"w\"), \", the function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pow(x, w, P)\"), \" may have many collisions. For instance, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pow(x,9,19)\"), \" only takes on values \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{1,18}\"), \".\"), mdx(\"p\", null, \"Given that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"P\"), \" is prime, then an appropriate \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"w\"), \" for a modular exponentiation hashing function can be chosen using the following result:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Observation 3. Let \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"P\"), \" be a prime; \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"w\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"P-1\"), \" are relatively prime if and only if for all \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b\"), \" in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\u2124/P\\u2124\"), \":\", mdx(\"center\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\\u02B7 mod P \\u2261 b\\u02B7 mod P\"), \" if and only if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a mod P \\u2261 b mod P\")))), mdx(\"p\", null, \"Thus, given that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"P\"), \" is prime and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"w\"), \" is relatively prime to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"P-1\"), \", we have that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"|{pow(x, w, P) : x \\u2208 \\u2124}| = P\"), \", implying that the hashing function has the minimal collision rate possible.\"), mdx(\"p\", null, \"In the special case that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"P\"), \" is a safe prime as we have selected, then \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"P-1\"), \" only has factors 1, 2, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(P-1)/2\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"P-1\"), \". Since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"P\"), \" > 7, we know that 3 is relatively prime to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"P-1\"), \", hence \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"w=3\"), \" satisfies the above proposition.\"), mdx(\"h2\", {\n    \"id\": \"cache-based-evaluation\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#cache-based-evaluation\",\n    \"aria-label\": \"cache based evaluation permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"More efficient cache-based evaluation algorithm\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def quick_calc(params, seed, p):\\n    cache = produce_dag(params, seed, params[\\\"cache_size\\\"])\\n    return quick_calc_cached(cache, params, p)\\n\\ndef quick_calc_cached(cache, params, p):\\n    P = params[\\\"P\\\"]\\n    if p < len(cache):\\n        return cache[p]\\n    else:\\n        x = pow(cache[0], p + 1, P)\\n        for _ in range(params[\\\"k\\\"]):\\n            x ^= quick_calc_cached(cache, params, x % p)\\n        return pow(x, params[\\\"w\\\"], P)\\n\\ndef quick_hashimoto(seed, dagsize, params, header, nonce):\\n    cache = produce_dag(params, seed, params[\\\"cache_size\\\"])\\n    return quick_hashimoto_cached(cache, dagsize, params, header, nonce)\\n\\ndef quick_hashimoto_cached(cache, dagsize, params, header, nonce):\\n    m = dagsize // 2\\n    mask = 2**64 - 1\\n    mix = sha3(encode_int(nonce) + header)\\n    for _ in range(params[\\\"accesses\\\"]):\\n        mix ^= quick_calc_cached(cache, params, m + (mix & mask) % m)\\n    return dbl_sha3(mix)\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#prerequisites-prerequisites","title":"Prerequisites {#prerequisites}"},{"url":"#dagger-hashimoto-dagger-hashimoto","title":"Dagger-Hashimoto {#dagger-hashimoto}"},{"url":"#dag-generation-dag-generation","title":"DAG Generation {#dag-generation}","items":[{"url":"#parameters-parameters","title":"Parameters {#parameters}"},{"url":"#dagger-graph-building-dagger-graph-building","title":"Dagger graph building {#dagger-graph-building}"}]},{"url":"#light-client-evaluation-light-client-evaluation","title":"Light client evaluation {#light-client-evaluation}"},{"url":"#double-buffer-of-dags-double-buffer","title":"Double buffer of DAGs {#double-buffer}"},{"url":"#hashimoto-hashimoto","title":"Hashimoto {#hashimoto}"},{"url":"#mining-and-verifying-mining-and-verifying","title":"Mining and verifying {#mining-and-verifying}"},{"url":"#further-reading-further-reading","title":"Further reading {#further-reading}"},{"url":"#appendix-appendix","title":"Appendix {#appendix}","items":[{"url":"#lehmer-random-number-generator-lehmer-random-number","title":"Lehmer random number generator {#lehmer-random-number}"},{"url":"#modular-exponentiation-as-a-hash-function-modular-exponentiation","title":"Modular exponentiation as a hash function {#modular-exponentiation}"}]},{"url":"#more-efficient-cache-based-evaluation-algorithm-cache-based-evaluation","title":"More efficient cache-based evaluation algorithm {#cache-based-evaluation}"}]}}},"pageContext":{"language":"uk","slug":"/uk/developers/docs/consensus-mechanisms/pow/mining-algorithms/dagger-hashimoto/","ignoreTranslationBanner":false,"isLegal":false,"isOutdated":false,"isContentEnglish":true,"relativePath":"src/content/developers/docs/consensus-mechanisms/pow/mining-algorithms/dagger-hashimoto/index.md","locale":"uk","hrefLang":"uk","originalPath":"/developers/docs/consensus-mechanisms/pow/mining-algorithms/dagger-hashimoto/","dateFormat":"MM/DD/YYYY"}},"staticQueryHashes":["1239077767","3003422828","3280999885","446219633"],"slicesMap":{}}