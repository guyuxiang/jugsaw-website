{"componentChunkName":"component---src-templates-docs-tsx","path":"/ro/developers/docs/data-structures-and-encoding/patricia-merkle-trie/","result":{"data":{"siteData":{"siteMetadata":{"editContentUrl":"https://github.com/ethereum/ethereum-org-website/tree/dev/"}},"pageData":{"fields":{"slug":"/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/"},"frontmatter":{"title":"Patricia Merkle Trees","description":"Introduction to Patricia Merkle Tries.","lang":"en","incomplete":null,"sidebarDepth":2,"isOutdated":null,"hideEditButton":null},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Patricia Merkle Trees\",\n  \"description\": \"Introduction to Patricia Merkle Tries.\",\n  \"lang\": \"en\",\n  \"sidebarDepth\": 2\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"A Patricia Merkle Trie provides a cryptographically authenticated data structure that can be used to store all \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(key, value)\"), \" bindings.\"), mdx(\"p\", null, \"Patricia Merkle Tries are deterministic, meaning that a trie with the same \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(key, value)\"), \" bindings is guaranteed to be identical\\u2014down to the last byte. They have the same root hash, providing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O(log(n))\"), \" efficiency for inserts, lookups and deletes. They are simpler to understand and implement than more complex comparison-based alternatives, like red-black trees.\"), mdx(\"h2\", {\n    \"id\": \"prerequisites\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#prerequisites\",\n    \"aria-label\": \"prerequisites permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Prerequisites\"), mdx(\"p\", null, \"It's helpful to have basic knowledge of Merkle trees and serialization to understand this page.\"), mdx(\"h2\", {\n    \"id\": \"basic-radix-tries\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#basic-radix-tries\",\n    \"aria-label\": \"basic radix tries permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Basic radix tries\"), mdx(\"p\", null, \"In a basic radix trie, every node looks as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"    [i_0, i_1 ... i_n, value]\\n\")), mdx(\"p\", null, \"Where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i_0 ... i_n\"), \" represent the symbols of the alphabet (often binary or hex), \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \" is the terminal value at the node, and the values in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i_0, i_1 ... i_n\"), \" slots are either \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NULL\"), \" or pointers to (in our case, hashes of) other nodes. This forms a basic \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(key, value)\"), \" store.\"), mdx(\"p\", null, \"Say you wanted to use a radix tree data structure for persisting an order over a set of key value pairs. To find the value currently mapped to the key \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dog\"), \" in the trie, you would first convert \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dog\"), \" into letters of the alphabet (giving \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"64 6f 67\"), \"), and then descend the trie following that path until you find the value. That is, you start by look up the root hash in a flat key/value DB to find the root node of the trie. It is represented as an array of keys pointing to other nodes. You would use the value at index \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"6\"), \" as a key and look it up in the flat key/value DB to get the node one level down. Then pick index \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"4\"), \" to look up the next value, then pick index \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"6\"), \", and so on, until, once you followed the path: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"root -> 6 -> 4 -> 6 -> 15 -> 6 -> 7\"), \", you look would up the value of the node and return the result.\"), mdx(\"p\", null, \"There is a difference between looking something up in the 'trie' and the underlying flat key/value 'DB'. They both define key/values arrangements, but the underlying DB can do a traditional 1 step lookup of a key. Looking up a key in the trie requires multiple underlying DB lookups to get to the final value described above. Let's refer to the latter as a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"path\"), \" to eliminate ambiguity.\"), mdx(\"p\", null, \"The update and delete operations for radix tries can be defined as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"    def update(node,path,value):\\n        if path == '':\\n            curnode = db.get(node) if node else [ NULL ] * 17\\n            newnode = curnode.copy()\\n            newnode[-1] = value\\n        else:\\n            curnode = db.get(node) if node else [ NULL ] * 17\\n            newnode = curnode.copy()\\n            newindex = update(curnode[path[0]],path[1:],value)\\n            newnode[path[0]] = newindex\\n        db.put(hash(newnode),newnode)\\n        return hash(newnode)\\n\\n    def delete(node,path):\\n        if node is NULL:\\n            return NULL\\n        else:\\n            curnode = db.get(node)\\n            newnode = curnode.copy()\\n            if path == '':\\n                newnode[-1] = NULL\\n            else:\\n                newindex = delete(curnode[path[0]],path[1:])\\n                newnode[path[0]] = newindex\\n\\n            if len(filter(x -> x is not NULL, newnode)) == 0:\\n                return NULL\\n            else:\\n                db.put(hash(newnode),newnode)\\n                return hash(newnode)\\n\")), mdx(\"p\", null, \"A \\\"Merkle\\\" Radix tree is built by linking nodes using deterministically-generated cryptographic hash digests. This content-addressing (in the key/value DB \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"key == keccak256(rlp(value))\"), \") provides cryptographic authentication of the stored data. If the root hash of a given trie is publicly known, then anyone can provide a proof that the trie includes a given value at a specific path by providing the hashes of each node joining a specific value to the tree root.\"), mdx(\"p\", null, \"It is impossible for an attacker to provide a proof of a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(path, value)\"), \" pair that does not exist since the root hash is ultimately based on all hashes below it. Any underlying modification would change the root hash.\"), mdx(\"p\", null, \"We'll refer to an atomic unit of a radix tree (e.g. a single hex character, or 4 bit binary number) as a \\\"nibble\\\". While traversing a path one nibble at a time, as described above, nodes can maximally refer to 16 children but include a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \" element. We, hence, represent them as array with length. We call these 17-element arrays \\\"branch nodes\\\".\"), mdx(\"h2\", {\n    \"id\": \"merkle-patricia-trees\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#merkle-patricia-trees\",\n    \"aria-label\": \"merkle patricia trees permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Merkle Patricia Trie\"), mdx(\"p\", null, \"Radix tries have one major limitation: they are inefficient. If you want to store one \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(path, value)\"), \" binding where the path, like in Ethereum, is 64 characters long (the number of nibbles in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bytes32\"), \"), we will need over a kilobyte of extra space to store one level per character, and each lookup or delete will take the full 64 steps. The Patricia trie introduced in the following solves this issue.\"), mdx(\"h3\", {\n    \"id\": \"optimization\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#optimization\",\n    \"aria-label\": \"optimization permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Optimization\"), mdx(\"p\", null, \"A node in a Merkle Patricia trie is one of the following:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"NULL\"), \" (represented as the empty string)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"branch\"), \" A 17-item node \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"[ v0 ... v15, vt ]\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"leaf\"), \" A 2-item node \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"[ encodedPath, value ]\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"extension\"), \" A 2-item node \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"[ encodedPath, key ]\"))), mdx(\"p\", null, \"With 64 character paths it is inevitable that after traversing the first few layers of the trie, you will reach a node where no divergent path exists for at least part of the way down. To avoid having to create up to 15 sparse \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NULL\"), \" nodes along the path, we shortcut the descent by setting up an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"extension\"), \" node of the form \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[ encodedPath, key ]\"), \", where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"encodedPath\"), \" contains the \\\"partial path\\\" to skip ahead (using a compact encoding described below), and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"key\"), \" is for the next DB lookup.\"), mdx(\"p\", null, \"For a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"leaf\"), \" node, which can be marked by a flag in the first nibble of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"encodedPath\"), \", the path encodes all prior node's path fragments and we can look up the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \" directly.\"), mdx(\"p\", null, \"This above optimization, however, introduces ambiguity.\"), mdx(\"p\", null, \"When traversing paths in nibbles, we may end up with an odd number of nibbles to traverse, but because all data is stored in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bytes\"), \" format. It is not possible to differentiate between, for instance, the nibble \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1\"), \", and the nibbles \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"01\"), \" (both must be stored as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<01>\"), \"). To specify odd length, the partial path is prefixed with a flag.\"), mdx(\"h3\", {\n    \"id\": \"specification\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#specification\",\n    \"aria-label\": \"specification permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Specification: Compact encoding of hex sequence with optional terminator\"), mdx(\"p\", null, \"The flagging of both \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"odd vs. even remaining partial path length\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"leaf vs. extension node\"), \" as described above reside in the first nibble of the partial path of any 2-item node. They result in the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"hex char    bits    |    node type partial     path length\\n----------------------------------------------------------\\n   0        0000    |       extension              even\\n   1        0001    |       extension              odd\\n   2        0010    |   terminating (leaf)         even\\n   3        0011    |   terminating (leaf)         odd\\n\")), mdx(\"p\", null, \"For even remaining path length (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"2\"), \"), another \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0\"), \" \\\"padding\\\" nibble will always follow.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"    def compact_encode(hexarray):\\n        term = 1 if hexarray[-1] == 16 else 0\\n        if term: hexarray = hexarray[:-1]\\n        oddlen = len(hexarray) % 2\\n        flags = 2 * term + oddlen\\n        if oddlen:\\n            hexarray = [flags] + hexarray\\n        else:\\n            hexarray = [flags] + [0] + hexarray\\n        // hexarray now has an even length whose first nibble is the flags.\\n        o = ''\\n        for i in range(0,len(hexarray),2):\\n            o += chr(16 * hexarray[i] + hexarray[i+1])\\n        return o\\n\")), mdx(\"p\", null, \"Examples:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"    > [ 1, 2, 3, 4, 5, ...]\\n    '11 23 45'\\n    > [ 0, 1, 2, 3, 4, 5, ...]\\n    '00 01 23 45'\\n    > [ 0, f, 1, c, b, 8, 10]\\n    '20 0f 1c b8'\\n    > [ f, 1, c, b, 8, 10]\\n    '3f 1c b8'\\n\")), mdx(\"p\", null, \"Here is the extended code for getting a node in the Merkle Patricia trie:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"    def get_helper(node,path):\\n        if path == []: return node\\n        if node = '': return ''\\n        curnode = rlp.decode(node if len(node) < 32 else db.get(node))\\n        if len(curnode) == 2:\\n            (k2, v2) = curnode\\n            k2 = compact_decode(k2)\\n            if k2 == path[:len(k2)]:\\n                return get(v2, path[len(k2):])\\n            else:\\n                return ''\\n        elif len(curnode) == 17:\\n            return get_helper(curnode[path[0]],path[1:])\\n\\n    def get(node,path):\\n        path2 = []\\n        for i in range(len(path)):\\n            path2.push(int(ord(path[i]) / 16))\\n            path2.push(ord(path[i]) % 16)\\n        path2.push(16)\\n        return get_helper(node,path2)\\n\")), mdx(\"h3\", {\n    \"id\": \"example-trie\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#example-trie\",\n    \"aria-label\": \"example trie permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Example Trie\"), mdx(\"p\", null, \"Suppose we want a trie containing four path/value pairs \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"('do', 'verb')\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"('dog', 'puppy')\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"('doge', 'coin')\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"('horse', 'stallion')\"), \".\"), mdx(\"p\", null, \"First, we convert both paths and values to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bytes\"), \". Below, actual byte representations for \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"paths\"), \" are denoted by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<>\"), \", although \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"values\"), \" are still shown as strings, denoted by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"''\"), \", for easier comprehension (they, too, would actually be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bytes\"), \"):\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"    <64 6f> : 'verb'\\n    <64 6f 67> : 'puppy'\\n    <64 6f 67 65> : 'coin'\\n    <68 6f 72 73 65> : 'stallion'\\n\")), mdx(\"p\", null, \"Now, we build such a trie with the following key/value pairs in the underlying DB:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"    rootHash: [ <16>, hashA ]\\n    hashA:    [ <>, <>, <>, <>, hashB, <>, <>, <>, [ <20 6f 72 73 65>, 'stallion' ], <>, <>, <>, <>, <>, <>, <>, <> ]\\n    hashB:    [ <00 6f>, hashD ]\\n    hashD:    [ <>, <>, <>, <>, <>, <>, hashE, <>, <>, <>, <>, <>, <>, <>, <>, <>, 'verb' ]\\n    hashE:    [ <17>, [ <>, <>, <>, <>, <>, <>, [ <35>, 'coin' ], <>, <>, <>, <>, <>, <>, <>, <>, <>, 'puppy' ] ]\\n\")), mdx(\"p\", null, \"When one node is referenced inside another node, what is included is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"H(rlp.encode(x))\"), \", where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"H(x) = keccak256(x) if len(x) >= 32 else x\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rlp.encode\"), \" is the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/data-structures-and-encoding/rlp\"\n  }, \"RLP\"), \" encoding function.\"), mdx(\"p\", null, \"Note that when updating a trie, one needs to store the key/value pair \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(keccak256(x), x)\"), \" in a persistent lookup table \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"if\"), \" the newly-created node has length >= 32. However, if the node is shorter than that, one does not need to store anything, since the function f(x) = x is reversible.\"), mdx(\"h2\", {\n    \"id\": \"tries-in-ethereum\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#tries-in-ethereum\",\n    \"aria-label\": \"tries in ethereum permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Tries in Ethereum\"), mdx(\"p\", null, \"All of the merkle tries in Ethereum's execution layer use a Merkle Patricia Trie.\"), mdx(\"p\", null, \"From a block header there are 3 roots from 3 of these tries.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"stateRoot\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"transactionsRoot\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"receiptsRoot\")), mdx(\"h3\", {\n    \"id\": \"state-trie\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#state-trie\",\n    \"aria-label\": \"state trie permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"State Trie\"), mdx(\"p\", null, \"There is one global state trie, and it updates over time. In it, a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"path\"), \" is always: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"keccak256(ethereumAddress)\"), \" and a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \" is always: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rlp(ethereumAccount)\"), \". More specifically an ethereum \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"account\"), \" is a 4 item array of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[nonce,balance,storageRoot,codeHash]\"), \". At this point it's worth noting that this \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"storageRoot\"), \" is the root of another patricia trie:\"), mdx(\"h3\", {\n    \"id\": \"storage-trie\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#storage-trie\",\n    \"aria-label\": \"storage trie permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Storage Trie\"), mdx(\"p\", null, \"Storage trie is where \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"all\"), \" contract data lives. There is a separate storage trie for each account. To retrieve values at specific storage positions at a given address the storage address, integer position of the stored data in the storage, and the block ID are required. These can then be passed as arguments to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"eth_getStorageAt\"), \" defined in the JSON-RPC API, e.g. to retrieve the data in storage slot 0 for address \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0x295a70b2de5e3953354a6a8344e616ed314d7251\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"curl -X POST --data '{\\\"jsonrpc\\\":\\\"2.0\\\", \\\"method\\\": \\\"eth_getStorageAt\\\", \\\"params\\\": [\\\"0x295a70b2de5e3953354a6a8344e616ed314d7251\\\", \\\"0x0\\\", \\\"latest\\\"], \\\"id\\\": 1}' localhost:8545\\n\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"result\\\":\\\"0x00000000000000000000000000000000000000000000000000000000000004d2\\\"}\\n\\n\")), mdx(\"p\", null, \"Retrieving other elements in storage is slightly more involved because the position in the storage trie must first be calculated. The position is calculated as the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"keccak256\"), \" hash of the address and the storage position, both left-padded with zeros to a length of 32 bytes. For example, the position for the data in storage slot 1 for address \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0x391694e7e0b0cce554cb130d723a9d27458f9298\"), \" is:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-keccak256(decodeHex(\\\"000000000000000000000000391694e7e0b0cce554cb130d723a9d27458f9298\\\"\",\n    \"metastring\": \"+ \\\"0000000000000000000000000000000000000000000000000000000000000001\\\"))\",\n    \"+\": true,\n    \"\\\"0000000000000000000000000000000000000000000000000000000000000001\\\"))\": true\n  }, \"\")), mdx(\"p\", null, \"In a Geth console, this can be calculated as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"> var key = \\\"000000000000000000000000391694e7e0b0cce554cb130d723a9d27458f9298\\\" + \\\"0000000000000000000000000000000000000000000000000000000000000001\\\"\\nundefined\\n> web3.sha3(key, {\\\"encoding\\\": \\\"hex\\\"})\\n\\\"0x6661e9d6d8b923d5bbaab1b96e1dd51ff6ea2a93520fdc9eb75d059238b8c5e9\\\"\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"path\"), \" is therefore \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"keccak256(<6661e9d6d8b923d5bbaab1b96e1dd51ff6ea2a93520fdc9eb75d059238b8c5e9>)\"), \". This can now be used to retrieve the data from the storage trie as before:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"curl -X POST --data '{\\\"jsonrpc\\\":\\\"2.0\\\", \\\"method\\\": \\\"eth_getStorageAt\\\", \\\"params\\\": [\\\"0x295a70b2de5e3953354a6a8344e616ed314d7251\\\", \\\"0x6661e9d6d8b923d5bbaab1b96e1dd51ff6ea2a93520fdc9eb75d059238b8c5e9\\\", \\\"latest\\\"], \\\"id\\\": 1}' localhost:8545\\n\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"result\\\":\\\"0x000000000000000000000000000000000000000000000000000000000000162e\\\"}\\n\")), mdx(\"h3\", {\n    \"id\": \"transaction-trie\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#transaction-trie\",\n    \"aria-label\": \"transaction trie permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Transactions Trie\"), mdx(\"p\", null, \"There is a separate transactions trie for every block, again storing (key, value) pairs. A path here is: rlp(transactionIndex) which represents the key that corresponds to a value determined by:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"if legacyTx:\\n  value = rlp(tx)\\nelse:\\n  value = TxType | encode(tx)\\n\")), mdx(\"p\", null, \"More information on this can be found in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://eips.ethereum.org/EIPS/eip-2718\"\n  }, \"EIP 2718\"), \" documentation.\"), mdx(\"h3\", {\n    \"id\": \"receipts-trie\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#receipts-trie\",\n    \"aria-label\": \"receipts trie permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Receipts Trie\"), mdx(\"p\", null, \"Every block has its own Receipts trie. A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"path\"), \" here is: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rlp(transactionIndex)\"), \". \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"transactionIndex\"), \" is its index within the block it's mined. The receipts trie never updates. Similarly to the Transactions trie, there are current and legacy receipts. To query a specific receipt in the Receipts trie the index of the transaction in its block, the receipt payload and the transaction type are required. The Returned receipt can be of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Receipt\"), \" which is defined as the concatenation of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"transaction type\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"transaction payload\"), \" or it can be of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LegacyReceipt\"), \" which is defined as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rlp([status, cumulativeGasUsed, logsBloom, logs])\"), \".\"), mdx(\"p\", null, \"More information on this can be found in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://eips.ethereum.org/EIPS/eip-2718\"\n  }, \"EIP 2718\"), \" documentation.\"), mdx(\"h2\", {\n    \"id\": \"further-reading\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#further-reading\",\n    \"aria-label\": \"further reading permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Further Reading\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/codechain/modified-merkle-patricia-trie-how-ethereum-saves-a-state-e6d7555078dd\"\n  }, \"Modified Merkle Patricia Trie \\u2014 How Ethereum saves a state\"), \"\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/\"\n  }, \"Merkling in Ethereum\"), \"\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://easythereentropy.wordpress.com/2014/06/04/understanding-the-ethereum-trie/\"\n  }, \"Understanding the Ethereum trie\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#prerequisites-prerequisites","title":"Prerequisites {#prerequisites}"},{"url":"#basic-radix-tries-basic-radix-tries","title":"Basic radix tries {#basic-radix-tries}"},{"url":"#merkle-patricia-trie-merkle-patricia-trees","title":"Merkle Patricia Trie {#merkle-patricia-trees}","items":[{"url":"#optimization-optimization","title":"Optimization {#optimization}"},{"url":"#specification-compact-encoding-of-hex-sequence-with-optional-terminator-specification","title":"Specification: Compact encoding of hex sequence with optional terminator {#specification}"},{"url":"#example-trie-example-trie","title":"Example Trie {#example-trie}"}]},{"url":"#tries-in-ethereum-tries-in-ethereum","title":"Tries in Ethereum {#tries-in-ethereum}","items":[{"url":"#state-trie-state-trie","title":"State Trie {#state-trie}"},{"url":"#storage-trie-storage-trie","title":"Storage Trie {#storage-trie}"},{"url":"#transactions-trie-transaction-trie","title":"Transactions Trie {#transaction-trie}"},{"url":"#receipts-trie-receipts-trie","title":"Receipts Trie {#receipts-trie}"}]},{"url":"#further-reading-further-reading","title":"Further Reading {#further-reading}"}]}}},"pageContext":{"language":"ro","slug":"/ro/developers/docs/data-structures-and-encoding/patricia-merkle-trie/","ignoreTranslationBanner":false,"isLegal":false,"isOutdated":false,"isContentEnglish":true,"relativePath":"src/content/developers/docs/data-structures-and-encoding/patricia-merkle-trie/index.md","locale":"ro","hrefLang":"ro","originalPath":"/developers/docs/data-structures-and-encoding/patricia-merkle-trie/","dateFormat":"MM/DD/YYYY"}},"staticQueryHashes":["1239077767","3003422828","3280999885","446219633"],"slicesMap":{}}