{"componentChunkName":"component---src-templates-tutorial-tsx","path":"/nl/developers/tutorials/nft-minter/","result":{"data":{"siteData":{"siteMetadata":{"editContentUrl":"https://github.com/ethereum/ethereum-org-website/tree/dev/"}},"pageData":{"fields":{"slug":"/en/developers/tutorials/nft-minter/","readingTime":{"minutes":28.675}},"frontmatter":{"title":"NFT Minter Tutorial","description":"In this tutorial, you’ll build an NFT minter and learn how to create a full stack dapp by connecting your smart contract to a React frontend using MetaMask and Web3 tools.","lang":"en","tags":["solidity","NFT","alchemy","smart contracts","frontend","Pinata"],"author":"smudgil","source":null,"sourceUrl":null,"skill":"intermediate","published":"2021-10-06T00:00:00.000Z","sidebarDepth":null,"address":null,"isOutdated":null,"postMergeBannerTranslation":null,"hideEditButton":null},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"NFT Minter Tutorial\",\n  \"description\": \"In this tutorial, you’ll build an NFT minter and learn how to create a full stack dapp by connecting your smart contract to a React frontend using MetaMask and Web3 tools.\",\n  \"author\": \"smudgil\",\n  \"tags\": [\"solidity\", \"NFT\", \"alchemy\", \"smart contracts\", \"frontend\", \"Pinata\"],\n  \"skill\": \"intermediate\",\n  \"lang\": \"en\",\n  \"published\": \"2021-10-06T00:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Emoji = makeShortcode(\"Emoji\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"One of the greatest challenges for developers coming from a Web2 background is figuring out how to connect your smart contract to a frontend project and interact with it.\"), mdx(\"p\", null, \"By building an NFT minter \\u2014 a simple UI where you can input a link to your digital asset, a title, and a description \\u2014 you'll learn how to:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Connect to MetaMask via your frontend project\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Call smart contract methods from your frontend\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Sign transactions using MetaMask\")), mdx(\"p\", null, \"In this tutorial, we will be using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://reactjs.org/\"\n  }, \"React\"), \" as our frontend framework. Because this tutorial is primarily focused on Web3 development, we won't be spending much time breaking down React fundamentals. Instead, we'll be focusing on bringing functionality to our project.\"), mdx(\"p\", null, \"As a prerequisite, you should have a beginner-level understanding of React\\u2014know how components, props, useState/useEffect, and basic function calling works. If you've never heard of any of those terms before, you may want to check out this \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://reactjs.org/tutorial/tutorial.html\"\n  }, \"Intro to React tutorial\"), \". For the more visual learners, we highly recommend this excellent \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.youtube.com/playlist?list=PL4cUxeGkcC9gZD-Tvwfod2gaISzfRiP9d\"\n  }, \"Full Modern React Tutorial\"), \" video series by Net Ninja.\"), mdx(\"p\", null, \"And if you haven't already, you'll definitely need an Alchemy account to complete this tutorial as well as build anything on the blockchain. Sign up for a free account \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://alchemy.com/\"\n  }, \"here\"), \".\"), mdx(\"p\", null, \"Without further ado, let's get started!\"), mdx(\"h2\", {\n    \"id\": \"making-nfts-101\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#making-nfts-101\",\n    \"aria-label\": \"making nfts 101 permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Making NFTs 101\"), mdx(\"p\", null, \"Before we even start looking at any code, it's important to understand how making an NFT works. It involves two steps:\"), mdx(\"h3\", {\n    \"id\": \"publish-nft\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#publish-nft\",\n    \"aria-label\": \"publish nft permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Publish an NFT smart contract on the Ethereum blockchain\"), mdx(\"p\", null, \"The biggest difference between the two NFT smart contract standards is that ERC-1155 is a multi-token standard and includes batch functionality, whereas with the ERC-721 is a single-token standard and therefore only supports transferring one token at a time.\"), mdx(\"h3\", {\n    \"id\": \"minting-function\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#minting-function\",\n    \"aria-label\": \"minting function permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Call the minting function\"), mdx(\"p\", null, \"Usually, this minting function requires you to pass in two variables as parameters, first the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"recipient\"), \", which specifies the address that will receive your freshly minted NFT, and second the NFT's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tokenURI\"), \", a string that resolves to a JSON document describing the NFT's metadata.\"), mdx(\"p\", null, \"An NFT's metadata is really what brings it to life, allowing it to have properties, such as a name, description, image (or different digital asset), and other attributes. Here's \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://gateway.pinata.cloud/ipfs/QmSvBcb4tjdFpajGJhbFAWeK3JAxCdNQLQtr6ZdiSi42V2\"\n  }, \"an example of a tokenURI\"), \", which contains an NFT's metadata.\"), mdx(\"p\", null, \"In this tutorial, we're going to focus on part 2, calling an existing NFT's smart contract minting function using our React UI.\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://ropsten.etherscan.io/address/0x4C4a07F737Bf57F6632B6CAB089B78f62385aCaE\"\n  }, \"Here's a link\"), \" to the ERC-721 NFT smart contract we will be calling in this tutorial. If you'd like to learn how we made it, we highly recommend that you check out our other tutorial, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.alchemyapi.io/alchemy/tutorials/how-to-create-an-nft\"\n  }, \"\\\"How to Create an NFT\\\"\"), \".\"), mdx(\"p\", null, \"Cool, now that we understand how making an NFT works, let's clone our starter files!\"), mdx(\"h2\", {\n    \"id\": \"clone-the-starter-files\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#clone-the-starter-files\",\n    \"aria-label\": \"clone the starter files permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Clone the starter files\"), mdx(\"p\", null, \"First, go to the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/alchemyplatform/nft-minter-tutorial\"\n  }, \"nft-minter-tutorial GitHub repository\"), \" to get the starter files for this project. Clone this repository into your local environment.=\"), mdx(\"p\", null, \"When you open this cloned \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nft-minter-tutorial\"), \" repository, you'll notice that it contains two folders: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"minter-starter-files\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nft-minter\"), \".\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"minter-starter-files\"), \" contains the starter files (essentially the React UI) for this project. In this tutorial, \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"we will be working in this directory\"), \", as you learn how to bring this UI to life by connecting it to your Ethereum wallet and an NFT smart contract.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"nft-minter\"), \" contains the entire completed tutorial and is there for you as a \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"reference\"), \" \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"if you get stuck.\"))), mdx(\"p\", null, \"Next, open your copy of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"minter-starter-files\"), \" in your code editor, and then navigate into your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src\"), \" folder.\"), mdx(\"p\", null, \"All of the code we'll write will live under the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src\"), \" folder. We'll be editing the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Minter.js\"), \" component and writing additional javascript files to give our project Web3 functionality.\"), mdx(\"h2\", {\n    \"id\": \"step-2-check-out-our-starter-files\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#step-2-check-out-our-starter-files\",\n    \"aria-label\": \"step 2 check out our starter files permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Step 2: Check out our starter files\"), mdx(\"p\", null, \"Before we start coding, it's important to check out what's already provided for us in the starter files.\"), mdx(\"h3\", {\n    \"id\": \"get-your-react-project-running\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#get-your-react-project-running\",\n    \"aria-label\": \"get your react project running permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Get your react project running\"), mdx(\"p\", null, \"Let's start by running the React project in our browser. The beauty of React is that once we have our project running in our browser, any changes we save will be updated live in our browser.\"), mdx(\"p\", null, \"To get the project running, navigate to the root directory of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"minter-starter-files\"), \" folder, and the run \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"npm install\"), \" in your terminal to install the dependencies of the project:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"cd minter-starter-files\\nnpm install\\n\")), mdx(\"p\", null, \"Once those have finished installing, run \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"npm start\"), \" in your terminal:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"npm start\\n\")), mdx(\"p\", null, \"Doing so should open http://localhost:3000/ in your browser, where you'll see the frontend for our project. It should consist of 3 fields: a place to input a link to your NFT's asset, enter the name of your NFT, and provide a description.\"), mdx(\"p\", null, \"If you try clicking \\\"Connect Wallet\\\" or \\\"Mint NFT\\\" buttons, you'll notice they don't work\\u2014that's because we still need to program their functionality! :\", \")\"), mdx(\"h3\", {\n    \"id\": \"minter-js\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#minter-js\",\n    \"aria-label\": \"minter js permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"The Minter.js component\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"NOTE:\"), \" Make sure you're in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"minter-starter-files\"), \" folder and not the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nft-minter\"), \" folder!\"), mdx(\"p\", null, \"Let's go back into the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src\"), \" folder in our editor and open the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Minter.js\"), \" file. It's super important that we understand everything in this file, as it is the primary React component we will be working on.\"), mdx(\"p\", null, \"At the top of our this file, we have our state variables that we will update after specific events.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"//State variables\\nconst [walletAddress, setWallet] = useState(\\\"\\\")\\nconst [status, setStatus] = useState(\\\"\\\")\\nconst [name, setName] = useState(\\\"\\\")\\nconst [description, setDescription] = useState(\\\"\\\")\\nconst [url, setURL] = useState(\\\"\\\")\\n\")), mdx(\"p\", null, \"Never heard of React state variables or state hooks? Check out \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://reactjs.org/docs/hooks-state.html\"\n  }, \"these\"), \" docs.\"), mdx(\"p\", null, \"Here's what each of the variables represent:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"walletAddress\"), \" - a string that stores the user's wallet address\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"status\"), \" - a string that contains a message to display at the bottom of the UI\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"name\"), \" - a string that stores the NFT's name\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"description\"), \" - a string that stores the NFT's description\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"url\"), \" - a string that is a link to the NFT's digital asset\")), mdx(\"p\", null, \"After the state variables, you'll see three un-implemented functions: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"connectWalletPressed\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onMintPressed\"), \". You'll notice that all of these functions are \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"async\"), \", that's because we will be making asynchronous API calls in them! Their names are eponymous with their functionalities:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"useEffect(async () => {\\n  //TODO: implement\\n}, [])\\n\\nconst connectWalletPressed = async () => {\\n  //TODO: implement\\n}\\n\\nconst onMintPressed = async () => {\\n  //TODO: implement\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://reactjs.org/docs/hooks-effect.html\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"useEffect\")), \" - this is a React hook that is called after your component is rendered. Because it has an empty array \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"[]\"), \" prop passed into it (see line 3), it will only be called on the component's \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"first\"), \" render. Here we'll call our wallet listener and another wallet function to update our UI to reflect whether a wallet is already connected.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"connectWalletPressed\"), \" - this function will be called to connect the user's MetaMask wallet to our dapp.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"onMintPressed\"), \" - this function will be called to mint the user's NFT.\")), mdx(\"p\", null, \"Near the end of this file, we have the UI of our component. If you scan this code carefully, you'll notice that we update our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"url\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"description\"), \" state variables when the input in their corresponding text fields change.\"), mdx(\"p\", null, \"You'll also see that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"connectWalletPressed\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onMintPressed\"), \" are called when the buttons with IDs \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mintButton\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"walletButton\"), \" are clicked respectively.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"//the UI of our component\\nreturn (\\n  <div className=\\\"Minter\\\">\\n    <button id=\\\"walletButton\\\" onClick={connectWalletPressed}>\\n      {walletAddress.length > 0 ? (\\n        \\\"Connected: \\\" +\\n        String(walletAddress).substring(0, 6) +\\n        \\\"...\\\" +\\n        String(walletAddress).substring(38)\\n      ) : (\\n        <span>Connect Wallet</span>\\n      )}\\n    </button>\\n\\n    <br></br>\\n    <h1 id=\\\"title\\\">\\uD83E\\uDDD9\\u200D\\u2642\\uFE0F Alchemy NFT Minter</h1>\\n    <p>\\n      Simply add your asset's link, name, and description, then press \\\"Mint.\\\"\\n    </p>\\n    <form>\\n      <h2>\\uD83D\\uDDBC Link to asset: </h2>\\n      <input\\n        type=\\\"text\\\"\\n        placeholder=\\\"e.g. https://gateway.pinata.cloud/ipfs/<hash>\\\"\\n        onChange={(event) => setURL(event.target.value)}\\n      />\\n      <h2>\\uD83E\\uDD14 Name: </h2>\\n      <input\\n        type=\\\"text\\\"\\n        placeholder=\\\"e.g. My first NFT!\\\"\\n        onChange={(event) => setName(event.target.value)}\\n      />\\n      <h2>\\u270D\\uFE0F Description: </h2>\\n      <input\\n        type=\\\"text\\\"\\n        placeholder=\\\"e.g. Even cooler than cryptokitties ;)\\\"\\n        onChange={(event) => setDescription(event.target.value)}\\n      />\\n    </form>\\n    <button id=\\\"mintButton\\\" onClick={onMintPressed}>\\n      Mint NFT\\n    </button>\\n    <p id=\\\"status\\\">{status}</p>\\n  </div>\\n)\\n\")), mdx(\"p\", null, \"Finally, let's address where is this Minter component added.\"), mdx(\"p\", null, \"If you go to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"App.js\"), \" file, which is the main component in React that acts as a container for all other components, you'll see that our Minter component is injected on line 7.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"In this tutorial, we'll only be editing the \", mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"Minter.js file\"), \" and adding files in our \", mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"src\"), \" folder.\")), mdx(\"p\", null, \"Now that we understand what we're working with, let's set up our Ethereum wallet!\"), mdx(\"p\", null, \"##: Set up your Ethereum wallet {#set-up-your-ethereum-wallet}\"), mdx(\"p\", null, \"For users to be able to interact with your smart contract they will need to connect their Ethereum wallet to your dapp.\"), mdx(\"h3\", {\n    \"id\": \"download-metamask\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#download-metamask\",\n    \"aria-label\": \"download metamask permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Download MetaMask\"), mdx(\"p\", null, \"For this tutorial, we\\u2019ll use MetaMask, a virtual wallet in the browser used to manage your Ethereum account address. If you want to understand more about how transactions on Ethereum work, check out \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/transactions/\"\n  }, \"this page\"), \".\"), mdx(\"p\", null, \"You can download and create a MetaMask account for free \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://metamask.io/download.html\"\n  }, \"here\"), \". When you are creating an account, or if you already have an account, make sure to switch over to the \\u201CRopsten Test Network\\u201D in the upper right \", \"(\", \"so that we\\u2019re not dealing with real money\", \")\", \".\"), mdx(\"h3\", {\n    \"id\": \"add-ether-from-faucet\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#add-ether-from-faucet\",\n    \"aria-label\": \"add ether from faucet permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Add ether from a Faucet\"), mdx(\"p\", null, \"In order to mint our NFTs (or sign any transactions on the Ethereum blockchain), we\\u2019ll need some fake Eth. To get Eth you can go to the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://faucet.ropsten.be/\"\n  }, \"Ropsten faucet\"), \" and enter your Ropsten account address, then click \\u201CSend Ropsten Eth.\\u201D You should see Eth in your MetaMask account soon after!\"), mdx(\"h3\", {\n    \"id\": \"check-your-balance\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#check-your-balance\",\n    \"aria-label\": \"check your balance permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Check your balance\"), mdx(\"p\", null, \"To double check our balance is there, let\\u2019s make an \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.alchemyapi.io/alchemy/documentation/alchemy-api-reference/json-rpc#eth_getbalance\"\n  }, \"eth_getBalance\"), \" request using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://composer.alchemyapi.io/?composer_state=%7B%22network%22%3A0%2C%22methodName%22%3A%22eth_getBalance%22%2C%22paramValues%22%3A%5B%22%22%2C%22latest%22%5D%7D\"\n  }, \"Alchemy\\u2019s composer tool\"), \". This will return the amount of Eth in our wallet. After you input your MetaMask account address and click \\u201CSend Request\\u201D, you should see a response like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"{\\\"jsonrpc\\\": \\\"2.0\\\", \\\"id\\\": 0, \\\"result\\\": \\\"0xde0b6b3a7640000\\\"}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"NOTE:\"), \" This result is in wei not eth. Wei is used as the smallest denomination of ether. The conversion from wei to eth is: 1 eth = 10\\xB9\\u2078 wei. So if we convert 0xde0b6b3a7640000 to decimal we get 1\", \"*\", \"10\\xB9\\u2078 which equals 1 eth.\"), mdx(\"p\", null, \"Phew! Our fake money is all there! \", mdx(Emoji, {\n    text: \":money_mouth_face:\",\n    size: 1,\n    mdxType: \"Emoji\"\n  })), mdx(\"h2\", {\n    \"id\": \"connect-metamask-to-your-UI\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#connect-metamask-to-your-UI\",\n    \"aria-label\": \"connect metamask to your UI permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Connect MetaMask to your UI\"), mdx(\"p\", null, \"Now that our MetaMask wallet is set up, let's connect our dapp to it!\"), mdx(\"p\", null, \"Because we want to prescribe to the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller\"\n  }, \"MVC\"), \" paradigm, we're going to create a separate file that contains our functions to manage the logic, data, and rules of our dapp, and then pass those functions to our frontend (our Minter.js component).\"), mdx(\"h3\", {\n    \"id\": \"connect-wallet-function\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#connect-wallet-function\",\n    \"aria-label\": \"connect wallet function permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"The \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"connectWallet\"), \" function\"), mdx(\"p\", null, \"To do so, let's create a new folder called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"utils\"), \" in your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src\"), \" directory and add a file called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"interact.js\"), \" inside it, which will contain all of our wallet and smart contract interaction functions.\"), mdx(\"p\", null, \"In our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"interact.js\"), \" file, we will write a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"connectWallet\"), \" function, which we will then import and call in our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Minter.js\"), \" component.\"), mdx(\"p\", null, \"In your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"interact.js\"), \" file, add the following\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"export const connectWallet = async () => {\\n  if (window.ethereum) {\\n    try {\\n      const addressArray = await window.ethereum.request({\\n        method: \\\"eth_requestAccounts\\\",\\n      })\\n      const obj = {\\n        status: \\\"\\uD83D\\uDC46\\uD83C\\uDFFD Write a message in the text-field above.\\\",\\n        address: addressArray[0],\\n      }\\n      return obj\\n    } catch (err) {\\n      return {\\n        address: \\\"\\\",\\n        status: \\\"\\uD83D\\uDE25 \\\" + err.message,\\n      }\\n    }\\n  } else {\\n    return {\\n      address: \\\"\\\",\\n      status: (\\n        <span>\\n          <p>\\n            {\\\" \\\"}\\n            \\uD83E\\uDD8A <a target=\\\"_blank\\\" href={`https://metamask.io/download.html`}>\\n              You must install MetaMask, a virtual Ethereum wallet, in your\\n              browser.\\n            </a>\\n          </p>\\n        </span>\\n      ),\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Let's breakdown what this code does:\"), mdx(\"p\", null, \"First, our function checks if it \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"window.ethereum\"), \" is enabled in your browser.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"window.ethereum\"), \" is a global API injected by MetaMask and other wallet providers that allows websites to request users' Ethereum accounts. If approved, it can read data from the blockchains the user is connected to, and suggest that the user sign messages and transactions. Check out the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.metamask.io/guide/ethereum-provider.html#table-of-contents\"\n  }, \"MetaMask docs\"), \" for more info!\"), mdx(\"p\", null, \"If \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"window.ethereum\"), \" \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"is not\"), \" present, then that means MetaMask is not installed. This results in a JSON object being returned, where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"address\"), \" returned is an empty string, and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"status\"), \" JSX object relays that the user must install MetaMask.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Most of the functions we write will be returning JSON objects that we can use to update our state variables and UI.\")), mdx(\"p\", null, \"Now if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"window.ethereum\"), \" \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"is\"), \" present, then that's when things get interesting.\"), mdx(\"p\", null, \"Using a try/catch loop, we'll try to connect to MetaMask by calling\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[window.ethereum.request({ method: \\\"eth_requestAccounts\\\" });](https://docs.metamask.io/guide/rpc-api.html#eth-requestaccounts)\"), \". Calling this function will open up MetaMask in the browser, whereby the user will be prompted to connect their wallet to your dapp.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If the user chooses to connect, \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"method: \\\"eth_requestAccounts\\\"\"), \" will return an array that contains all of the user's account addresses that are connected to the dapp. Altogether, our \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"connectWallet\"), \" function will return a JSON object that contains the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"first\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"address\"), \" in this array \", \"(\", \"see line 9\", \")\", \" and a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"status\"), \" message that prompts the user to write a message to the smart contract.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If the user rejects the connection, then the JSON object will contain an empty string for the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"address\"), \" returned and a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"status\"), \" message that reflects that the user rejected the connection.\")), mdx(\"h3\", {\n    \"id\": \"add-connect-wallet\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#add-connect-wallet\",\n    \"aria-label\": \"add connect wallet permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Add connectWallet function to your Minter.js UI Component\"), mdx(\"p\", null, \"Now that we've written this \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"connectWallet\"), \" function, let's connect it to our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Minter.js.\"), \" component.\"), mdx(\"p\", null, \"First, we'll have to import our function into our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Minter.js\"), \" file by adding \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"import { connectWallet } from \\\"./utils/interact.js\\\";\"), \" to the top of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Minter.js\"), \" file. Your first 11 lines of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Minter.js\"), \" should now look like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"import { useEffect, useState } from \\\"react\\\";\\nimport { connectWallet } from \\\"./utils/interact.js\\\";\\n\\nconst Minter = (props) => {\\n\\n  //State variables\\n  const [walletAddress, setWallet] = useState(\\\"\\\");\\n  const [status, setStatus] = useState(\\\"\\\");\\n  const [name, setName] = useState(\\\"\\\");\\n  const [description, setDescription] = useState(\\\"\\\");\\n  const [url, setURL] = useState(\\\"\\\");\\n\")), mdx(\"p\", null, \"Then, inside our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"connectWalletPressed\"), \" function, we'll call our imported \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"connectWallet\"), \" function, like so:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"const connectWalletPressed = async () => {\\n  const walletResponse = await connectWallet()\\n  setStatus(walletResponse.status)\\n  setWallet(walletResponse.address)\\n}\\n\")), mdx(\"p\", null, \"Notice how most of our functionality is abstracted away from our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Minter.js\"), \" component from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"interact.js\"), \" file? This is so we comply with the M-V-C paradigm!\"), mdx(\"p\", null, \"In \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"connectWalletPressed\"), \", we simply make an await call to our imported \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"connectWallet\"), \" function, and using its response, we update our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"status\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"walletAddress\"), \" variables via their state hooks.\"), mdx(\"p\", null, \"Now, let's save both files \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Minter.js\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"interact.js\"), \" and test out our UI so far.\"), mdx(\"p\", null, \"Open your browser on localhost:3000, and press the \\\"Connect Wallet\\\" button on the top right of the page.\"), mdx(\"p\", null, \"If you have MetaMask installed, you should be prompted to connect your wallet to your dapp. Accept the invitation to connect.\"), mdx(\"p\", null, \"You should see that the wallet button now reflects that your address is connected.\"), mdx(\"p\", null, \"Next, try refreshing the page... this is strange. Our wallet button is prompting us to connect MetaMask, even though it is already connected...\"), mdx(\"p\", null, \"Don't worry though! We easily can fix that by implementing a function called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getCurrentWalletConnected\"), \", which will check if an address is already connected to our dapp and update our UI accordingly!\"), mdx(\"h3\", {\n    \"id\": \"get-current-wallet\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#get-current-wallet\",\n    \"aria-label\": \"get current wallet permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"The getCurrentWalletConnected function\"), mdx(\"p\", null, \"In your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"interact.js\"), \" file, add the following \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getCurrentWalletConnected\"), \" function:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"export const getCurrentWalletConnected = async () => {\\n  if (window.ethereum) {\\n    try {\\n      const addressArray = await window.ethereum.request({\\n        method: \\\"eth_accounts\\\",\\n      })\\n      if (addressArray.length > 0) {\\n        return {\\n          address: addressArray[0],\\n          status: \\\"\\uD83D\\uDC46\\uD83C\\uDFFD Write a message in the text-field above.\\\",\\n        }\\n      } else {\\n        return {\\n          address: \\\"\\\",\\n          status: \\\"\\uD83E\\uDD8A Connect to MetaMask using the top right button.\\\",\\n        }\\n      }\\n    } catch (err) {\\n      return {\\n        address: \\\"\\\",\\n        status: \\\"\\uD83D\\uDE25 \\\" + err.message,\\n      }\\n    }\\n  } else {\\n    return {\\n      address: \\\"\\\",\\n      status: (\\n        <span>\\n          <p>\\n            {\\\" \\\"}\\n            \\uD83E\\uDD8A <a target=\\\"_blank\\\" href={`https://metamask.io/download.html`}>\\n              You must install MetaMask, a virtual Ethereum wallet, in your\\n              browser.\\n            </a>\\n          </p>\\n        </span>\\n      ),\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"This code is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"very\"), \" similar to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"connectWallet\"), \" function we just wrote earlier.\"), mdx(\"p\", null, \"The main difference is that instead of calling the method \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"eth_requestAccounts\"), \", which opens MetaMask for the user to connect their wallet, here we call the method \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"eth_accounts\"), \", which simply returns an array containing the MetaMask addresses currently connected to our dapp.\"), mdx(\"p\", null, \"To see this function in action, let's call it in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" function of our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Minter.js\"), \" component.\"), mdx(\"p\", null, \"Like we did for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"connectWallet\"), \", we must import this function from our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"interact.js\"), \" file into our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Minter.js\"), \" file like so:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"import { useEffect, useState } from \\\"react\\\"\\nimport {\\n  connectWallet,\\n  getCurrentWalletConnected, //import here\\n} from \\\"./utils/interact.js\\\"\\n\")), mdx(\"p\", null, \"Now, we simply call it in our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" function:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"useEffect(async () => {\\n  const { address, status } = await getCurrentWalletConnected()\\n  setWallet(address)\\n  setStatus(status)\\n}, [])\\n\")), mdx(\"p\", null, \"Notice, we use the response of our call to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getCurrentWalletConnected\"), \" to update our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"walletAddress\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"status\"), \" state variables.\"), mdx(\"p\", null, \"Once you've added this code, try refreshing our browser window. The button should say that you're connected, and show a preview of your connected wallet's address - even after you refresh!\"), mdx(\"h3\", {\n    \"id\": \"implement-add-wallet-listener\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#implement-add-wallet-listener\",\n    \"aria-label\": \"implement add wallet listener permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Implement addWalletListener\"), mdx(\"p\", null, \"The final step in our dapp wallet setup is implementing the wallet listener so our UI updates when our wallet's state changes, such as when the user disconnects or switches accounts.\"), mdx(\"p\", null, \"In your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Minter.js\"), \" file, add a function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"addWalletListener\"), \" that looks like the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"function addWalletListener() {\\n  if (window.ethereum) {\\n    window.ethereum.on(\\\"accountsChanged\\\", (accounts) => {\\n      if (accounts.length > 0) {\\n        setWallet(accounts[0])\\n        setStatus(\\\"\\uD83D\\uDC46\\uD83C\\uDFFD Write a message in the text-field above.\\\")\\n      } else {\\n        setWallet(\\\"\\\")\\n        setStatus(\\\"\\uD83E\\uDD8A Connect to MetaMask using the top right button.\\\")\\n      }\\n    })\\n  } else {\\n    setStatus(\\n      <p>\\n        {\\\" \\\"}\\n        \\uD83E\\uDD8A <a target=\\\"_blank\\\" href={`https://metamask.io/download.html`}>\\n          You must install MetaMask, a virtual Ethereum wallet, in your browser.\\n        </a>\\n      </p>\\n    )\\n  }\\n}\\n\")), mdx(\"p\", null, \"Let's quickly break down what's happening here:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"First, our function checks if \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"window.ethereum\"), \" is enabled \", \"(\", \"i.e. MetaMask is installed\", \")\", \".\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If it's not, we simply set our \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"status\"), \" state variable to a JSX string that prompts the user to install MetaMask.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If it is enabled, we set up the listener \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"window.ethereum.on(\\\"accountsChanged\\\")\"), \" on line 3 that listens for state changes in the MetaMask wallet, which include when the user connects an additional account to the dapp, switches accounts, or disconnects an account. If there is at least one account connected, the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"walletAddress\"), \" state variable is updated as the first account in the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"accounts\"), \" array returned by the listener. Otherwise, \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"walletAddress\"), \" is set as an empty string.\")))), mdx(\"p\", null, \"Finally, we must call it in our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useEffect\"), \" function:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"useEffect(async () => {\\n  const { address, status } = await getCurrentWalletConnected()\\n  setWallet(address)\\n  setStatus(status)\\n\\n  addWalletListener()\\n}, [])\\n\")), mdx(\"p\", null, \"And voila! We've completed programming all of our wallet functionality! Now that our wallet is set up, let's figure out how to mint our NFT!\"), mdx(\"h2\", {\n    \"id\": \"nft-metadata-101\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#nft-metadata-101\",\n    \"aria-label\": \"nft metadata 101 permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"NFT Metadata 101\"), mdx(\"p\", null, \"So remember the NFT metadata we just talked about in Step 0 of this tutorial\\u2014it brings an NFT to life, allowing it to have properties, such as a digital asset, name, description, and other attributes.\"), mdx(\"p\", null, \"We're going to need to configure this metadata as a JSON object and store it, so we can pass it in as the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tokenURI\"), \" parameter when calling our smart contract's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mintNFT\"), \" function.\"), mdx(\"p\", null, \"The text in the \\\"Link to Asset\\\", \\\"Name\\\", \\\"Description\\\" fields will comprise the different properties of our NFT's metadata. We'll format this metadata as a JSON object, but there are a couple options for where we can store this JSON object:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We could store it on the Ethereum blockchain; however, doing so would be very expensive.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We could store it on a centralized server, like AWS or Firebase. But that would defeat our decentralization ethos.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We could use IPFS, a decentralized protocol and peer-to-peer network for storing and sharing data in a distributed file system. As this protocol is decentralized and free, it is our best option!\")), mdx(\"p\", null, \"To store our metadata on IPFS, we will use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://pinata.cloud/\"\n  }, \"Pinata\"), \", a convenient IPFS API and toolkit. In the next step, we'll explain exactly how to do this!\"), mdx(\"h2\", {\n    \"id\": \"use-pinata-to-pin-your-metadata-to-IPFS\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#use-pinata-to-pin-your-metadata-to-IPFS\",\n    \"aria-label\": \"use pinata to pin your metadata to IPFS permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Use Pintata to pin your metadata to IPFS\"), mdx(\"p\", null, \"If you don't have a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://pinata.cloud/\"\n  }, \"Pinata\"), \" account, sign up for a free account \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://pinata.cloud/signup\"\n  }, \"here\"), \" and complete the steps to verify your email and account.\"), mdx(\"h3\", {\n    \"id\": \"create-pinata-api-key\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#create-pinata-api-key\",\n    \"aria-label\": \"create pinata api key permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Create your Pinata API key\"), mdx(\"p\", null, \"Navigate to the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://pinata.cloud/keys\"\n  }, \"https://pinata.cloud/keys\"), \" page, then select the \\\"New Key\\\" button at the top, set the Admin widget as enabled, and name your key.\"), mdx(\"p\", null, \"You'll then be shown a popup with your API info. Make sure to put this somewhere safe.\"), mdx(\"p\", null, \"Now that our key is set up, let's add it to our project so we can use it.\"), mdx(\"h3\", {\n    \"id\": \"create-a-env\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#create-a-env\",\n    \"aria-label\": \"create a env permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Create a .env file\"), mdx(\"p\", null, \"We can safely store our Pinata key and secret in an environment file. Let's install the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.npmjs.com/package/dotenv\"\n  }, \"dotenv package\"), \" in your project directory.\"), mdx(\"p\", null, \"Open up a new tab in your terminal \", \"(\", \"separate from the one running local host\", \")\", \" and make sure you are in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"minter-starter-files\"), \" folder, then run the following command in your terminal:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"npm install dotenv --save\\n\")), mdx(\"p\", null, \"Next, create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".env\"), \" file in the root directory of your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"minter-starter-files\"), \" by entering the following on your command line:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"vim.env\\n\")), mdx(\"p\", null, \"This will pop open your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".env\"), \" file in vim \", \"(\", \"a text editor\", \")\", \". To save it hit \\\"esc\\\" + \\\":\\\" + \\\"q\\\" on your keyboard in that order.\"), mdx(\"p\", null, \"Next, in VSCode, navigate to your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".env\"), \" file and add your Pinata API key and API secret to it, like so:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"REACT_APP_PINATA_KEY = <pinata-api-key>\\nREACT_APP_PINATA_SECRET = <pinata-api-secret>\\n\")), mdx(\"p\", null, \"Save the file, and then you're ready to start writing the function to upload your JSON metadata to IPFS!\"), mdx(\"h3\", {\n    \"id\": \"pin-json-to-ipfs\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#pin-json-to-ipfs\",\n    \"aria-label\": \"pin json to ipfs permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Implement pinJSONToIPFS\"), mdx(\"p\", null, \"Fortunately for us, Pinata has an \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://pinata.cloud/documentation#PinJSONToIPFS\"\n  }, \"API specifically for uploading JSON data to IPFS\"), \" and a convenient JavaScript with axios example that we can use, with some slight modifications.\"), mdx(\"p\", null, \"In your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"utils\"), \" folder, let's create another file called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pinata.js\"), \" and then import our Pinata secret and key from the .env file like so:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"require(\\\"dotenv\\\").config()\\nconst key = process.env.REACT_APP_PINATA_KEY\\nconst secret = process.env.REACT_APP_PINATA_SECRET\\n\")), mdx(\"p\", null, \"Next, paste the additional code from below into your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pinata.js\"), \" file. Don't worry, we'll break down what everything means!\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"require(\\\"dotenv\\\").config()\\nconst key = process.env.REACT_APP_PINATA_KEY\\nconst secret = process.env.REACT_APP_PINATA_SECRET\\n\\nconst axios = require(\\\"axios\\\")\\n\\nexport const pinJSONToIPFS = async (JSONBody) => {\\n  const url = `https://api.pinata.cloud/pinning/pinJSONToIPFS`\\n  //making axios POST request to Pinata \\u2B07\\uFE0F\\n  return axios\\n    .post(url, JSONBody, {\\n      headers: {\\n        pinata_api_key: key,\\n        pinata_secret_api_key: secret,\\n      },\\n    })\\n    .then(function (response) {\\n      return {\\n        success: true,\\n        pinataUrl:\\n          \\\"https://gateway.pinata.cloud/ipfs/\\\" + response.data.IpfsHash,\\n      }\\n    })\\n    .catch(function (error) {\\n      console.log(error)\\n      return {\\n        success: false,\\n        message: error.message,\\n      }\\n    })\\n}\\n\")), mdx(\"p\", null, \"So what does this code do exactly?\"), mdx(\"p\", null, \"First, it imports \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.npmjs.com/package/axios\"\n  }, \"axios\"), \", a promise based HTTP client for the browser and node.js, which we will use to make a request to Pinata.\"), mdx(\"p\", null, \"Then we have our asynchronous function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pinJSONToIPFS\"), \", which takes a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JSONBody\"), \" as its input and the Pinata api key and secret in its header, all to make a POST request to their \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pinJSONToIPFS\"), \" API.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If this POST request is successful, then our function returns a JSON object with the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"success\"), \" boolean as true and the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"pinataUrl\"), \" where our metadata was pinned. We will use this \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"pinataUrl\"), \" returned as the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"tokenURI\"), \" input to our smart contract's mint function.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If this post request fails, then our function returns a JSON object with the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"success\"), \" boolean as false and a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"message\"), \" string that relays our error.\")), mdx(\"p\", null, \"As with our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"connectWallet\"), \"function return types, we're returning JSON objects so we can use their parameters to update our state variables and UI.\"), mdx(\"h2\", {\n    \"id\": \"load-your-smart-contract\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#load-your-smart-contract\",\n    \"aria-label\": \"load your smart contract permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Load your smart contract\"), mdx(\"p\", null, \"Now that we have a way to upload our NFT metadata to IPFS via our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pinJSONToIPFS\"), \" function, we're going to need a way to load an instance of our smart contract so we can call its \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mintNFT\"), \" function.\"), mdx(\"p\", null, \"As we mentioned earlier, in this tutorial we will be using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://ropsten.etherscan.io/address/0x4C4a07F737Bf57F6632B6CAB089B78f62385aCaE\"\n  }, \"this existing NFT smart contract\"), \"; however, if you'd like to learn how we made it, or make one yourself, we highly recommend you check out our other tutorial, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.alchemyapi.io/alchemy/tutorials/how-to-create-an-nft\"\n  }, \"\\\"How to Create an NFT.\\\"\"), \".\"), mdx(\"h3\", {\n    \"id\": \"contract-abi\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#contract-abi\",\n    \"aria-label\": \"contract abi permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"The contract ABI\"), mdx(\"p\", null, \"If you examined our files closely, you'll have noticed that in our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src\"), \" directory, there's a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"contract-abi.json\"), \" file. An ABI is necessary for specifying which function a contract will invoke as well ensuring that the function will return data in the format you're expecting.\"), mdx(\"p\", null, \"We're also going to need an Alchemy API key and the Alchemy Web3 API to connect to the Ethereum blockchain and load our smart contract.\"), mdx(\"h3\", {\n    \"id\": \"create-alchemy-api\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#create-alchemy-api\",\n    \"aria-label\": \"create alchemy api permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Create your Alchemy API key\"), mdx(\"p\", null, \"If you don't already have an Alchemy account, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://alchemy.com/?a=eth-org-nft-minter\"\n  }, \"sign up for free here.\")), mdx(\"p\", null, \"Once you\\u2019ve created an Alchemy account, you can generate an API key by creating an app. This will allow us to make requests to the Ropsten test network.\"), mdx(\"p\", null, \"Navigate to the \\u201CCreate App\\u201D page in your Alchemy Dashboard by hovering over \\u201CApps\\u201D in the nav bar and clicking \\u201CCreate App\\u201D.\"), mdx(\"p\", null, \"Name your app we chose \\\"My First NFT!\\\", offer a short description, select \\u201CStaging\\u201D for the Environment used for your app bookkeeping, and choose \\u201CRopsten\\u201D for your network.\"), mdx(\"p\", null, \"Click \\u201CCreate app\\u201D and that\\u2019s it! Your app should appear in the table below.\"), mdx(\"p\", null, \"Awesome so now that we've created our HTTP Alchemy API URL, copy it to your clipboard...\"), mdx(\"p\", null, \"\\u2026and then let's add it to our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".env\"), \" file. Altogether, your .env file should look like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"REACT_APP_PINATA_KEY = <pinata-key>\\nREACT_APP_PINATA_SECRET = <pinata-secret>\\nREACT_APP_ALCHEMY_KEY = https://eth-ropsten.alchemyapi.io/v2/<alchemy-key>\\n\")), mdx(\"p\", null, \"Now that we have our contract ABI and our Alchemy API key, we're ready to load our smart contract using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/alchemyplatform/alchemy-web3\"\n  }, \"Alchemy Web3\"), \".\"), mdx(\"h3\", {\n    \"id\": \"setup-alchemy-endpoint\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#setup-alchemy-endpoint\",\n    \"aria-label\": \"setup alchemy endpoint permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Set up your Alchemy Web3 endpoint and contract\"), mdx(\"p\", null, \"First, if you don't have it already, you'll need to install \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/alchemyplatform/alchemy-web3\"\n  }, \"Alchemy Web3\"), \" by navigating to the home directory: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nft-minter-tutorial\"), \" in the terminal:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"cd ..\\nnpm install @alch/alchemy-web3\\n\")), mdx(\"p\", null, \"Next let's go back to our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"interact.js\"), \" file. At the top of the file, add the following code to import your Alchemy key from your .env file and set up your Alchemy Web3 endpoint:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"require(\\\"dotenv\\\").config()\\nconst alchemyKey = process.env.REACT_APP_ALCHEMY_KEY\\nconst { createAlchemyWeb3 } = require(\\\"@alch/alchemy-web3\\\")\\nconst web3 = createAlchemyWeb3(alchemyKey)\\n\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/alchemyplatform/alchemy-web3\"\n  }, \"Alchemy Web3\"), \" is a wrapper around \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://web3js.readthedocs.io/en/v1.2.9/\"\n  }, \"Web3.js\"), \", providing enhanced API methods and other crucial benefits to make your life as a web3 developer easier. It is designed to require minimal configuration so you can start using it in your app right away!\"), mdx(\"p\", null, \"Next, let's add our contract ABI and contract address to our file.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"require(\\\"dotenv\\\").config()\\nconst alchemyKey = process.env.REACT_APP_ALCHEMY_KEY\\nconst { createAlchemyWeb3 } = require(\\\"@alch/alchemy-web3\\\")\\nconst web3 = createAlchemyWeb3(alchemyKey)\\n\\nconst contractABI = require(\\\"../contract-abi.json\\\")\\nconst contractAddress = \\\"0x4C4a07F737Bf57F6632B6CAB089B78f62385aCaE\\\"\\n\")), mdx(\"p\", null, \"Once we have both of those, we're ready to start coding our mint function!\"), mdx(\"h2\", {\n    \"id\": \"implement-the-mintnft-function\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#implement-the-mintnft-function\",\n    \"aria-label\": \"implement the mintnft function permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Implement the mintNFT function\"), mdx(\"p\", null, \"Inside your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"interact.js\"), \" file, let's define our function, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mintNFT\"), \", which eponymously will mint our NFT.\"), mdx(\"p\", null, \"Because we will be making numerous asynchronous calls \", \"(\", \"to Pinata to pin our metadata to IPFS, Alchemy Web3 to load our smart contract, and MetaMask to sign our transactions\", \")\", \", our function will also be asynchronous.\"), mdx(\"p\", null, \"The three inputs to our function will be the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"url\"), \" of our digital asset, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"description\"), \". Add the following function signature below the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"connectWallet\"), \" function:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"export const mintNFT = async (url, name, description) => {}\\n\")), mdx(\"h3\", {\n    \"id\": \"input-error-handling\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#input-error-handling\",\n    \"aria-label\": \"input error handling permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Input error handling\"), mdx(\"p\", null, \"Naturally, it makes sense to have some sort of input error handling at the start of the function, so we exit this function if our input parameters aren't correct. Inside our function, let's add the following code:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"export const mintNFT = async (url, name, description) => {\\n  //error handling\\n  if (url.trim() == \\\"\\\" || name.trim() == \\\"\\\" || description.trim() == \\\"\\\") {\\n    return {\\n      success: false,\\n      status: \\\"\\u2757Please make sure all fields are completed before minting.\\\",\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Essentially, if any of the input parameters are an empty string, then we return a JSON object where the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"success\"), \" boolean is false, and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"status\"), \" string relays that all fields in our UI must be complete.\"), mdx(\"h3\", {\n    \"id\": \"upload-metadata-to-ipfs\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#upload-metadata-to-ipfs\",\n    \"aria-label\": \"upload metadata to ipfs permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Upload the metadata to IPFS\"), mdx(\"p\", null, \"Once we know our metadata is formatted properly, the next step is to wrap it into a JSON object and upload it to IPFS via the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pinJSONToIPFS\"), \" we wrote!\"), mdx(\"p\", null, \"To do so, we first we need to import the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pinJSONToIPFS\"), \" function into our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"interact.js\"), \" file. At the very top of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"interact.js\"), \", let's add:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"import { pinJSONToIPFS } from \\\"./pinata.js\\\"\\n\")), mdx(\"p\", null, \"Recall that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pinJSONToIPFS\"), \" takes in a JSON body. So before we make a call to it, we're going to need to format our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"url\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"description\"), \" parameters into a JSON object.\"), mdx(\"p\", null, \"Let's update our code to create a JSON object called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"metadata\"), \" and then make a call to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pinJSONToIPFS\"), \" with this \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"metadata\"), \" parameter:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"export const mintNFT = async (url, name, description) => {\\n  //error handling\\n  if (url.trim() == \\\"\\\" || name.trim() == \\\"\\\" || description.trim() == \\\"\\\") {\\n    return {\\n      success: false,\\n      status: \\\"\\u2757Please make sure all fields are completed before minting.\\\",\\n    }\\n  }\\n\\n  //make metadata\\n  const metadata = new Object()\\n  metadata.name = name\\n  metadata.image = url\\n  metadata.description = description\\n\\n  //make pinata call\\n  const pinataResponse = await pinJSONToIPFS(metadata)\\n  if (!pinataResponse.success) {\\n    return {\\n      success: false,\\n      status: \\\"\\uD83D\\uDE22 Something went wrong while uploading your tokenURI.\\\",\\n    }\\n  }\\n  const tokenURI = pinataResponse.pinataUrl\\n}\\n\")), mdx(\"p\", null, \"Notice, we store the response of our call to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pinJSONToIPFS(metadata)\"), \" in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pinataResponse\"), \" object. Then, we parse this object for any errors.\"), mdx(\"p\", null, \"If there's an error, we return a JSON object where the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"success\"), \" boolean is false and our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"status\"), \" string relays that our call failed. Otherwise, we extract the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pinataURL\"), \" from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pinataResponse\"), \" and store it as our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tokenURI\"), \" variable.\"), mdx(\"p\", null, \"Now it's time to load our smart contract using the Alchemy Web3 API that we initialized at the top of our file. Add the following line of code to the bottom of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mintNFT\"), \" function to set the contract at the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"window.contract\"), \" global variable:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"window.contract = await new web3.eth.Contract(contractABI, contractAddress)\\n\")), mdx(\"p\", null, \"The last thing to add in our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mintNFT\"), \" function is our Ethereum transaction:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"//set up your Ethereum transaction\\nconst transactionParameters = {\\n  to: contractAddress, // Required except during contract publications.\\n  from: window.ethereum.selectedAddress, // must match user's active address.\\n  data: window.contract.methods\\n    .mintNFT(window.ethereum.selectedAddress, tokenURI)\\n    .encodeABI(), //make call to NFT smart contract\\n}\\n\\n//sign the transaction via MetaMask\\ntry {\\n  const txHash = await window.ethereum.request({\\n    method: \\\"eth_sendTransaction\\\",\\n    params: [transactionParameters],\\n  })\\n  return {\\n    success: true,\\n    status:\\n      \\\"\\u2705 Check out your transaction on Etherscan: https://ropsten.etherscan.io/tx/\\\" +\\n      txHash,\\n  }\\n} catch (error) {\\n  return {\\n    success: false,\\n    status: \\\"\\uD83D\\uDE25 Something went wrong: \\\" + error.message,\\n  }\\n}\\n\")), mdx(\"p\", null, \"If you're already familiar with Ethereum transactions, you'll notice that the structure is pretty similar to what you've seen.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"First, we set up our transactions parameters.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"to\"), \" specifies the recipient address \", \"(\", \"our smart contract\", \")\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"from\"), \" specifies the signer of the transaction \", \"(\", \"the user's connected address to MetaMask: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"window.ethereum.selectedAddress\"), \")\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"data\"), \" contains the call to our smart contract \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"mintNFT\"), \" method, which receives our \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"tokenURI\"), \" and the user's wallet address, \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"window.ethereum.selectedAddress\"), \", as inputs\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Then, we make an await call, \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"window.ethereum.request,\"), \" where we ask MetaMask to sign the transaction. Notice, in this request, we're specifying our eth method \", \"(\", \"eth_SentTransaction\", \")\", \" and passing in our \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"transactionParameters\"), \". At this point, MetaMask will open up in the browser, and prompt the user to sign or reject the transaction.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If the transaction is successful, the function will return a JSON object where the boolean \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"success\"), \" is set to true and the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"status\"), \" string prompts the user to check out Etherscan for more information about their transaction.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If the transaction fails, the function will return a JSON object where the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"success\"), \" boolean is set to false, and the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"status\"), \" string relays the error message.\")))), mdx(\"p\", null, \"Altogether, our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mintNFT\"), \" function should look like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"export const mintNFT = async (url, name, description) => {\\n  //error handling\\n  if (url.trim() == \\\"\\\" || name.trim() == \\\"\\\" || description.trim() == \\\"\\\") {\\n    return {\\n      success: false,\\n      status: \\\"\\u2757Please make sure all fields are completed before minting.\\\",\\n    }\\n  }\\n\\n  //make metadata\\n  const metadata = new Object()\\n  metadata.name = name\\n  metadata.image = url\\n  metadata.description = description\\n\\n  //pinata pin request\\n  const pinataResponse = await pinJSONToIPFS(metadata)\\n  if (!pinataResponse.success) {\\n    return {\\n      success: false,\\n      status: \\\"\\uD83D\\uDE22 Something went wrong while uploading your tokenURI.\\\",\\n    }\\n  }\\n  const tokenURI = pinataResponse.pinataUrl\\n\\n  //load smart contract\\n  window.contract = await new web3.eth.Contract(contractABI, contractAddress) //loadContract();\\n\\n  //set up your Ethereum transaction\\n  const transactionParameters = {\\n    to: contractAddress, // Required except during contract publications.\\n    from: window.ethereum.selectedAddress, // must match user's active address.\\n    data: window.contract.methods\\n      .mintNFT(window.ethereum.selectedAddress, tokenURI)\\n      .encodeABI(), //make call to NFT smart contract\\n  }\\n\\n  //sign transaction via MetaMask\\n  try {\\n    const txHash = await window.ethereum.request({\\n      method: \\\"eth_sendTransaction\\\",\\n      params: [transactionParameters],\\n    })\\n    return {\\n      success: true,\\n      status:\\n        \\\"\\u2705 Check out your transaction on Etherscan: https://ropsten.etherscan.io/tx/\\\" +\\n        txHash,\\n    }\\n  } catch (error) {\\n    return {\\n      success: false,\\n      status: \\\"\\uD83D\\uDE25 Something went wrong: \\\" + error.message,\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"That's one giant function! Now, we just need to connect our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mintNFT\"), \" function to our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Minter.js\"), \" component...\"), mdx(\"h2\", {\n    \"id\": \"connect-our-frontend\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#connect-our-frontend\",\n    \"aria-label\": \"connect our frontend permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Connect mintNFT to our Minter.js frontend\"), mdx(\"p\", null, \"Open up your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Minter.js\"), \" file and update the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"import { connectWallet, getCurrentWalletConnected } from \\\"./utils/interact.js\\\";\"), \" line at the top to be:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"import {\\n  connectWallet,\\n  getCurrentWalletConnected,\\n  mintNFT,\\n} from \\\"./utils/interact.js\\\"\\n\")), mdx(\"p\", null, \"Finally, implement the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onMintPressed\"), \" function to make await call to your imported \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mintNFT\"), \"function and update the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"status\"), \" state variable to reflect whether our transaction succeeded or failed:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-javascript\"\n  }, \"const onMintPressed = async () => {\\n  const { status } = await mintNFT(url, name, description)\\n  setStatus(status)\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"deploy-your-NFT\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#deploy-your-NFT\",\n    \"aria-label\": \"deploy your NFT permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Deploy your NFT to a live website\"), mdx(\"p\", null, \"Ready to take your project live for users to interact with? Check out \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.alchemy.com/alchemy/tutorials/nft-minter/how-do-i-deploy-nfts-online\"\n  }, \"this tutorial\"), \" for deploying your Minter to a live website.\"), mdx(\"p\", null, \"One last step...\"), mdx(\"h2\", {\n    \"id\": \"take-the-blockchain-world-by-storm\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#take-the-blockchain-world-by-storm\",\n    \"aria-label\": \"take the blockchain world by storm permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Take the blockchain world by storm\"), mdx(\"p\", null, \"Just kidding, you made it to the end of the tutorial!\"), mdx(\"p\", null, \"To recap, by building an NFT minter, you successfully learned how to:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Connect to MetaMask via your frontend project\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Call smart contract methods from your frontend\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Sign transactions using MetaMask\")), mdx(\"p\", null, \"Presumably, you'd like to be able to show off the NFTs minted via your dapp in your wallet \\u2014 so be sure to check out our quick tutorial \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.alchemyapi.io/alchemy/tutorials/how-to-write-and-deploy-a-nft-smart-contract/how-to-view-your-nft-in-your-wallet\"\n  }, \"How to View Your NFT in Your Wallet\"), \"!\"), mdx(\"p\", null, \"And, as always, if you have any questions, we're here to help in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://discord.gg/gWuC7zB\"\n  }, \"Alchemy Discord\"), \". We can't wait to see how you apply the concepts from this tutorial to your future projects!\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#making-nfts-101-making-nfts-101","title":"Making NFTs 101 {#making-nfts-101}","items":[{"url":"#publish-an-nft-smart-contract-on-the-ethereum-blockchain-publish-nft","title":"Publish an NFT smart contract on the Ethereum blockchain {#publish-nft}"},{"url":"#call-the-minting-function-minting-function","title":"Call the minting function {#minting-function}"}]},{"url":"#clone-the-starter-files-clone-the-starter-files","title":"Clone the starter files {#clone-the-starter-files}"},{"url":"#step-2-check-out-our-starter-files-step-2-check-out-our-starter-files","title":"Step 2: Check out our starter files {#step-2-check-out-our-starter-files}","items":[{"url":"#get-your-react-project-running-get-your-react-project-running","title":"Get your react project running {#get-your-react-project-running}"},{"url":"#the-minterjs-component-minter-js","title":"The Minter.js component {#minter-js}"},{"url":"#download-metamask-download-metamask","title":"Download MetaMask {#download-metamask}"},{"url":"#add-ether-from-a-faucet-add-ether-from-faucet","title":"Add ether from a Faucet {#add-ether-from-faucet}"},{"url":"#check-your-balance-check-your-balance","title":"Check your balance {#check-your-balance}"}]},{"url":"#connect-metamask-to-your-ui-connect-metamask-to-your-ui","title":"Connect MetaMask to your UI {#connect-metamask-to-your-UI}","items":[{"url":"#the-connectwallet-function-connect-wallet-function","title":"The connectWallet function {#connect-wallet-function}"},{"url":"#add-connectwallet-function-to-your-minterjs-ui-component-add-connect-wallet","title":"Add connectWallet function to your Minter.js UI Component {#add-connect-wallet}"},{"url":"#the-getcurrentwalletconnected-function-get-current-wallet","title":"The getCurrentWalletConnected function {#get-current-wallet}"},{"url":"#implement-addwalletlistener-implement-add-wallet-listener","title":"Implement addWalletListener {#implement-add-wallet-listener}"}]},{"url":"#nft-metadata-101-nft-metadata-101","title":"NFT Metadata 101 {#nft-metadata-101}"},{"url":"#use-pintata-to-pin-your-metadata-to-ipfs-use-pinata-to-pin-your-metadata-to-ipfs","title":"Use Pintata to pin your metadata to IPFS {#use-pinata-to-pin-your-metadata-to-IPFS}","items":[{"url":"#create-your-pinata-api-key-create-pinata-api-key","title":"Create your Pinata API key {#create-pinata-api-key}"},{"url":"#create-a-env-file-create-a-env","title":"Create a .env file {#create-a-env}"},{"url":"#implement-pinjsontoipfs-pin-json-to-ipfs","title":"Implement pinJSONToIPFS {#pin-json-to-ipfs}"}]},{"url":"#load-your-smart-contract-load-your-smart-contract","title":"Load your smart contract {#load-your-smart-contract}","items":[{"url":"#the-contract-abi-contract-abi","title":"The contract ABI {#contract-abi}"},{"url":"#create-your-alchemy-api-key-create-alchemy-api","title":"Create your Alchemy API key {#create-alchemy-api}"},{"url":"#set-up-your-alchemy-web3-endpoint-and-contract-setup-alchemy-endpoint","title":"Set up your Alchemy Web3 endpoint and contract {#setup-alchemy-endpoint}"}]},{"url":"#implement-the-mintnft-function-implement-the-mintnft-function","title":"Implement the mintNFT function {#implement-the-mintnft-function}","items":[{"url":"#input-error-handling-input-error-handling","title":"Input error handling {#input-error-handling}"},{"url":"#upload-the-metadata-to-ipfs-upload-metadata-to-ipfs","title":"Upload the metadata to IPFS {#upload-metadata-to-ipfs}"}]},{"url":"#connect-mintnft-to-our-minterjs-frontend-connect-our-frontend","title":"Connect mintNFT to our Minter.js frontend {#connect-our-frontend}"},{"url":"#deploy-your-nft-to-a-live-website-deploy-your-nft","title":"Deploy your NFT to a live website {#deploy-your-NFT}"},{"url":"#take-the-blockchain-world-by-storm-take-the-blockchain-world-by-storm","title":"Take the blockchain world by storm {#take-the-blockchain-world-by-storm}"}]}}},"pageContext":{"language":"nl","slug":"/nl/developers/tutorials/nft-minter/","ignoreTranslationBanner":false,"isLegal":false,"isOutdated":false,"isContentEnglish":true,"relativePath":"src/content/developers/tutorials/nft-minter/index.md","locale":"nl","hrefLang":"nl","originalPath":"/developers/tutorials/nft-minter/","dateFormat":"MM/DD/YYYY"}},"staticQueryHashes":["1239077767","3003422828","3280999885","446219633"],"slicesMap":{}}