{"componentChunkName":"component---src-templates-docs-tsx","path":"/ig/developers/docs/smart-contracts/verifying/","result":{"data":{"siteData":{"siteMetadata":{"editContentUrl":"https://github.com/ethereum/ethereum-org-website/tree/dev/"}},"pageData":{"fields":{"slug":"/en/developers/docs/smart-contracts/verifying/"},"frontmatter":{"title":"Verifying smart contracts","description":"An overview of source code verification for Ethereum smart contracts","lang":"en","incomplete":null,"sidebarDepth":null,"isOutdated":null,"hideEditButton":null},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Verifying smart contracts\",\n  \"description\": \"An overview of source code verification for Ethereum smart contracts\",\n  \"lang\": \"en\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/smart-contracts/\"\n  }, \"Smart contracts\"), \" are designed to be \\u201Ctrustless\\u201D, meaning users shouldn\\u2019t have to trust third parties (e.g., developers and companies) before interacting with a contract. As a requisite for trustlessness, users and other developers must be able to verify a smart contract\\u2019s source code. Source code verification assures users and developers that the published contract code is the same code running at the contract address on the Ethereum blockchain.\"), mdx(\"p\", null, \"It is important to make the distinction between \\\"source code verification\\\" and \\\"\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/smart-contracts/formal-verification/\"\n  }, \"formal verification\"), \"\\\". Source code verification, which will be explained in detail below, refers to verifying that the given source code of a smart contract in a high-level language (e.g. Solidity) compiles to the same bytecode to be executed at the contract address. However, formal verification describes verifying the correctness of a smart contract, meaning the contract behaves as expected. Although context-dependent, contract verification usually refers to source code verification.\"), mdx(\"h2\", {\n    \"id\": \"what-is-source-code-verification\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#what-is-source-code-verification\",\n    \"aria-label\": \"what is source code verification permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"What is source code verification?\"), mdx(\"p\", null, \"Before deploying a smart contract in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/evm/\"\n  }, \"Ethereum Virtual Machine (EVM)\"), \", developers \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/smart-contracts/compiling/\"\n  }, \"compile\"), \" the contract\\u2019s source code\\u2014instructions \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/smart-contracts/languages/\"\n  }, \"written in Solidity\"), \" or another high-level programming language\\u2014to bytecode. As the EVM cannot interpret high-level instructions, compiling source code to bytecode (i.e., low-level, machine instructions) is necessary for executing contract logic in the EVM.\"), mdx(\"p\", null, \"Source code verification is comparing a smart contract\\u2019s source code and the compiled bytecode used during the contract creation to detect any differences. Verifying smart contracts matters because the advertised contract code may be different from what runs on the blockchain.\"), mdx(\"p\", null, \"Smart contract verification enables investigating what a contract does through the higher-level language it is written in, without having to read machine code. Functions, values, and usually the variable names and comments remain the same with the original source code that is compiled and deployed. This makes reading code much easier. Source verification also makes provision for code documentation, so that end-users know what a smart contract is designed to do.\"), mdx(\"h3\", {\n    \"id\": \"full-verification\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#full-verification\",\n    \"aria-label\": \"full verification permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"What is full verification?\"), mdx(\"p\", null, \"There are some parts of the source code that do not affect the compiled bytecode such as comments or variable names. That means two source codes with different variable names and different comments would both be able to verify the same contract. With that, a malicious actor can add deceiving comments or give misleading variable names inside the source code and get the contract verified with a source code different than the original source code.\"), mdx(\"p\", null, \"It is possible to avoid this by appending extra data to the bytecode to serve as a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cryptographical guarantee\"), \" for the exactness of the source code, and as a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"fingerprint\"), \" of the compilation information. The necessary information is found in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.soliditylang.org/en/v0.8.15/metadata.html\"\n  }, \"Solidity's contract metadata\"), \", and the hash of this file is appended to the bytecode of a contract. You can see it in action in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://playground.sourcify.dev\"\n  }, \"metadata playground\")), mdx(\"p\", null, \"The metadata file contains information about the compilation of the contract including the source files and their hashes. Meaning, if any of the compilation settings or even a byte in one of the source files change, the metadata file changes. Consequently the hash of the metadata file, which is appended to the bytecode, also changes. That means if a contract's bytecode + the appended metadata hash match with the given source code and compilation settings, we can be sure this is exactly the same source code used in the original compilation, not even a single byte is different.\"), mdx(\"p\", null, \"This type of verification that leverages the metadata hash is referred to as \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\\"\", mdx(\"a\", {\n    parentName: \"strong\",\n    \"href\": \"https://docs.sourcify.dev/docs/full-vs-partial-match/\"\n  }, \"full verification\"), \")\\\"\"), \" (also \\\"perfect verification\\\"). If the metadata hashes do not match or are not considered in verification it would be a \\\"partial match\\\", which currently is the more common way to verify contracts. It is possible to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://samczsun.com/hiding-in-plain-sight/\"\n  }, \"insert malicious code\"), \" that wouldn't be reflected in the verified source code without full verification. Most developers are not aware of the full verification and don't keep the metadata file of their compilation, hence partial verification has been the de facto method to verify contracts so far.\"), mdx(\"h2\", {\n    \"id\": \"importance-of-source-code-verification\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#importance-of-source-code-verification\",\n    \"aria-label\": \"importance of source code verification permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Why is source code verification important?\"), mdx(\"h3\", {\n    \"id\": \"trustlessness\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#trustlessness\",\n    \"aria-label\": \"trustlessness permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Trustlessness\"), mdx(\"p\", null, \"Trustlessness is arguably the biggest premise for smart contracts and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/dapps/\"\n  }, \"decentralized applications (dapps)\"), \". Smart contracts are \\u201Cimmutable\\u201D and cannot be altered; a contract will only execute the business logic defined in the code at the time of deployment. This means developers and enterprises cannot tamper with a contract's code after deploying on Ethereum.\"), mdx(\"p\", null, \"For a smart contract to be trustless, the contract code should be available for independent verification. While the compiled bytecode for every smart contract is publicly available on the blockchain, low-level language is difficult to understand\\u2014for both developers and users.\"), mdx(\"p\", null, \"Projects reduce trust assumptions by publishing the source code of their contracts. But this leads to another problem: it is difficult to verify that the published source code match the contract bytecode. In this scenario, the value of trustlessness is lost because users have to trust developers not to change a contract's business logic (i.e., by changing the bytecode) before deploying it on the blockchain.\"), mdx(\"p\", null, \"Source code verification tools provide guarantees that a smart contract\\u2019s source code files matches the assembly code. The result is a trustless ecosystem, where users don\\u2019t blindly trust third parties and instead verify code before depositing funds into a contract.\"), mdx(\"h3\", {\n    \"id\": \"user-safety\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#user-safety\",\n    \"aria-label\": \"user safety permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"User Safety\"), mdx(\"p\", null, \"With smart contracts, there\\u2019s usually a lot of money at stake. This calls for higher security guarantees and verification of a smart contract\\u2019s logic before using it. The problem is that unscrupulous developers can deceive users by inserting malicious code in a smart contract. Without verification, malicious smart contracts can have \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.trustnodes.com/2018/11/10/concerns-rise-over-backdoored-smart-contracts\"\n  }, \"backdoors\"), \", controversial access control mechanisms, exploitable vulnerabilities, and other things that jeopardize user safety that would go undetected.\"), mdx(\"p\", null, \"Publishing a smart contract's source code files makes it easier for those interested, such as auditors, to assess the contract for potential attack vectors. With multiple parties independently verifying a smart contract, users have stronger guarantees of its security.\"), mdx(\"h2\", {\n    \"id\": \"source-code-verification-for-ethereum-smart-contracts\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#source-code-verification-for-ethereum-smart-contracts\",\n    \"aria-label\": \"source code verification for ethereum smart contracts permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"How to verify source code for Ethereum smart contracts\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/smart-contracts/deploying/\"\n  }, \"Deploying a smart contract on Ethereum\"), \" requires sending a transaction with a data payload (compiled bytecode) to a special address. The data payload is generated by compiling the source code, plus the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.soliditylang.org/en/v0.8.14/contracts.html#constructor\"\n  }, \"constructor arguments\"), \" of the contract instance appended to the data payload in the transaction. Compilation is deterministic, meaning it always produces the same output (i.e., contract bytecode) if the same source files, and compilation settings (e.g. compiler version, optimizer) are used.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"1200px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/56bd7425cd677f3a0416fcb8a1c45118/5b795/source-code-verification.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"36.66666666666667%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsTAAALEwEAmpwYAAABHUlEQVR42n2QwU4CMRCGeQGjT6HEg8/nYxiPeBIi+gZ41osJmnhbyu6GBHG3REBg6XbbTucn3TXKyS9zaNN888+0hQOYQ/0DM78Oh0TUXFulNkXplHZEzAzv/3wi2ilTGQewIzbWW+tX3xvryFgiz6365B1575F9LQdPL9E4BeAcTSaTJEnjOFksFiG27misZ/wEhOR1YZS2AJ7f3i+vrh8Gj8zQlU3TVNTMpUSxq7bbXEqZyzzPq6oKsq6s0s66EA5guS21sc3MWZZNp9OP2WyzWuEz38n5SIg4jqMoKooiyFwDYLNe3/fver1+p3MjxKjxf18BKKXGNUmSKKWCDCCsCwghLs7b7bPTk+Ojbve2XtsdfjQRlTVa60bZA5fQhNfXEmn/AAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"A diagram showing showing smart contract source code verification\",\n    \"title\": \"A diagram showing showing smart contract source code verification\",\n    \"src\": \"/static/56bd7425cd677f3a0416fcb8a1c45118/c1b63/source-code-verification.png\",\n    \"srcSet\": [\"/static/56bd7425cd677f3a0416fcb8a1c45118/5a46d/source-code-verification.png 300w\", \"/static/56bd7425cd677f3a0416fcb8a1c45118/0a47e/source-code-verification.png 600w\", \"/static/56bd7425cd677f3a0416fcb8a1c45118/c1b63/source-code-verification.png 1200w\", \"/static/56bd7425cd677f3a0416fcb8a1c45118/5b795/source-code-verification.png 1455w\"],\n    \"sizes\": \"(max-width: 1200px) 100vw, 1200px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"Verifying a smart contract basically involves the following steps:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Input the source files and compilation settings to a compiler.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Compiler outputs the bytecode of the contract\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Get the bytecode of the deployed contract at a given address\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Compare the deployed bytecode with the recompiled bytecode. If the codes match, the contract gets verified with the given source code and compilation settings.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Additionally, if the metadata hashes at the end of the bytecode match, it will be a full match.\"))), mdx(\"p\", null, \"Note that this is a simplistic description of verification and there are many exceptions that would not work with this such as having \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.sourcify.dev/docs/immutables/\"\n  }, \"immutable variables\"), \".\"), mdx(\"h2\", {\n    \"id\": \"source-code-verification-tools\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#source-code-verification-tools\",\n    \"aria-label\": \"source code verification tools permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Source code verification tools\"), mdx(\"p\", null, \"The traditional process of verifying contracts can be complex. This is why we have tools for verifying source code for smart contracts deployed on Ethereum. These tools automate large parts of the source code verification and also curate verified contracts for the benefits of users.\"), mdx(\"h3\", {\n    \"id\": \"etherscan\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#etherscan\",\n    \"aria-label\": \"etherscan permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Etherscan\"), mdx(\"p\", null, \"Although mostly known as an \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/data-and-analytics/block-explorers/\"\n  }, \"Ethereum blockchain explorer\"), \", Etherscan also offers a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://etherscan.io/verifyContract\"\n  }, \"source code verification service\"), \" for smart contract developers and users.\"), mdx(\"p\", null, \"Etherscan allows you to recompile contract bytecode from the original data payload (source code, library address, compiler settings, contract address, etc.) If the recompiled bytecode is associated with the bytecode (and constructor parameters) of the on-chain contract, then \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://info.etherscan.com/types-of-contract-verification/\"\n  }, \"the contract is verified\"), \".\"), mdx(\"p\", null, \"Once verified, your contract\\u2019s source code receives a \\\"Verified\\\" label and is published on Etherscan for others to audit. It also gets added to the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://etherscan.io/contractsVerified/\"\n  }, \"Verified Contracts\"), \" section\\u2014a repository of smart contracts with verified source codes.\"), mdx(\"p\", null, \"Etherscan is the most used tool for verifying contracts. However, Etherscan's contract verification has a drawback: it fails to compare the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"metadata hash\"), \" of the on-chain bytecode and recompiled bytecode. Therefore the matches in Etherscan are partial matches.\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/etherscan-blog/verifying-contracts-on-etherscan-f995ab772327\"\n  }, \"More on verifying contracts on Etherscan\"), \".\"), mdx(\"h3\", {\n    \"id\": \"sourcify\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#sourcify\",\n    \"aria-label\": \"sourcify permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Sourcify\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://sourcify.dev/#/verifier\"\n  }, \"Sourcify\"), \" is another tool for verifying contracts that is open-sourced and decentralized. It is not a block explorer and only verifies contracts on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.sourcify.dev/docs/chains\"\n  }, \"different EVM based networks\"), \". It acts as a public infrastructure for other tools to build on top of it, and aims to enable more human-friendly contract interactions using the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/developers/docs/smart-contracts/compiling/#web-applications\"\n  }, \"ABI\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.soliditylang.org/en/v0.8.15/natspec-format.html\"\n  }, \"NatSpec\"), \" comments found in the metadata file.\"), mdx(\"p\", null, \"Unlike Etherscan, Sourcify supports full matches with the metadata hash. The verified contracts are served in its \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.sourcify.dev/docs/repository/\"\n  }, \"public repository\"), \" on HTTP and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.ipfs.io/concepts/what-is-ipfs/#what-is-ipfs\"\n  }, \"IPFS\"), \", which is a decentralized, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://web3.storage/docs/concepts/content-addressing/\"\n  }, \"content-addressed\"), \" storage. This allows fetching the metadata file of a contract over IPFS since the appended metadata hash is an IPFS hash.\"), mdx(\"p\", null, \"Additionally, one can also retrieve the source code files over IPFS, as IPFS hashes of these files are also found in the metadata. A contract can be verified by providing the metadata file and source files over its API or the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://sourcify.dev/#/verifier\"\n  }, \"UI\"), \", or using the plugins. Sourcify monitoring tool also listens to contract creations on new blocks and tries to verify the contracts if their metadata and source files are published on IPFS.\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://blog.soliditylang.org/2020/06/25/sourcify-faq/\"\n  }, \"More on verifying contracts on Sourcify\"), \".\"), mdx(\"h3\", {\n    \"id\": \"tenderly\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#tenderly\",\n    \"aria-label\": \"tenderly permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Tenderly\"), mdx(\"p\", null, \"The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://tenderly.co/\"\n  }, \"Tenderly platform\"), \" enables Web3 developers to build, test, monitor, and operate smart contracts. Combining debugging tools with observability and infrastructure building blocks, Tenderly helps developers accelerate smart contract development. To fully enable Tenderly features, developers need to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.tenderly.co/monitoring/contract-verification\"\n  }, \"perform source code verification\"), \" using several methods.\"), mdx(\"p\", null, \"It's possible to verify a contract privately or publicly. If verified privately, the smart contract is visible only to you (and other members in your project). Verifying a contract publicly makes it visible to everyone using the Tenderly platform.\"), mdx(\"p\", null, \"You can verify your contracts using the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.tenderly.co/monitoring/smart-contract-verification/verifying-a-smart-contract\"\n  }, \"Dashboard\"), \", \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.tenderly.co/monitoring/smart-contract-verification/verifying-contracts-using-the-tenderly-hardhat-plugin\"\n  }, \"Tenderly Hardhat plugin\"), \", or \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.tenderly.co/monitoring/smart-contract-verification/verifying-contracts-using-cli\"\n  }, \"CLI\"), \".\"), mdx(\"p\", null, \"When verifying contracts through the Dashboard, you need to import the source file or the metadata file generated by the Solidity compiler, the address/network, and compiler settings.\"), mdx(\"p\", null, \"Using the Tenderly Hardhat plugin allows for more control over the verification process with less effort, enabling you to choose between automatic (no-code) and manual (code-based) verification.\"), mdx(\"h2\", {\n    \"id\": \"further-reading\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#further-reading\",\n    \"aria-label\": \"further reading permalink\",\n    \"className\": \"header-anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Further reading\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://developpaper.com/how-to-verify-the-source-code-of-ethereum-smart-contract/\"\n  }, \"How to verify the source code of Ethereum smart contract\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://programtheblockchain.com/posts/2018/01/16/verifying-contract-source-code/\"\n  }, \"Verifying contract source code\"))));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#what-is-source-code-verification-what-is-source-code-verification","title":"What is source code verification? {#what-is-source-code-verification}","items":[{"url":"#what-is-full-verification-full-verification","title":"What is full verification? {#full-verification}"}]},{"url":"#why-is-source-code-verification-important-importance-of-source-code-verification","title":"Why is source code verification important? {#importance-of-source-code-verification}","items":[{"url":"#trustlessness-trustlessness","title":"Trustlessness {#trustlessness}"},{"url":"#user-safety-user-safety","title":"User Safety {#user-safety}"}]},{"url":"#how-to-verify-source-code-for-ethereum-smart-contracts-source-code-verification-for-ethereum-smart-contracts","title":"How to verify source code for Ethereum smart contracts {#source-code-verification-for-ethereum-smart-contracts}"},{"url":"#source-code-verification-tools-source-code-verification-tools","title":"Source code verification tools {#source-code-verification-tools}","items":[{"url":"#etherscan-etherscan","title":"Etherscan {#etherscan}"},{"url":"#sourcify-sourcify","title":"Sourcify {#sourcify}"},{"url":"#tenderly-tenderly","title":"Tenderly {#tenderly}"}]},{"url":"#further-reading-further-reading","title":"Further reading {#further-reading}"}]}}},"pageContext":{"language":"ig","slug":"/ig/developers/docs/smart-contracts/verifying/","ignoreTranslationBanner":false,"isLegal":false,"isOutdated":false,"isContentEnglish":true,"relativePath":"src/content/developers/docs/smart-contracts/verifying/index.md","locale":"ig","hrefLang":"ig","originalPath":"/developers/docs/smart-contracts/verifying/","dateFormat":"MM/DD/YYYY"}},"staticQueryHashes":["1239077767","3003422828","3280999885","446219633"],"slicesMap":{}}