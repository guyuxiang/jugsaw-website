{"version":3,"file":"42976bc124b88b6023476060d825babb5c09392b-b3f2037b37b59da7fc24.js","mappings":"wNAyBA,IAhBiCA,IAAmC,IAAlC,KAAEC,EAAI,SAAEC,GAAoB,EAAPC,GAAK,YAS1D,OACEC,EAAAA,EAAAA,IAACC,EAAAA,IAAY,QAACC,QATM,KACfL,IAILM,EAAAA,EAAAA,GAAeN,EAAK,GAIsBE,GACvCD,EACY,C,wKCsFnB,IAzFuCF,IAIhC,IAJiC,OACtCQ,EAAM,UACNC,GAAY,GAEb,EADIN,GAAK,YAER,MAAM,EAACO,EAAkB,EAACC,IAAwBC,EAAAA,EAAAA,WAAS,GACrDC,GAAYC,EAAAA,EAAAA,GAAUJ,GAGtBK,GAD6B,oBAAXC,OAAyBA,OAAOC,SAASC,KAAO,IAC5CC,SAAS,aAY/BC,EAAgBC,KACpBC,EAAAA,EAAAA,GAAiB,CACfC,cAAc,2BACdC,YAAY,UACZC,UAAWC,OAAOL,KAEpBV,GAAqB,EAAK,EAU5B,OACEP,EAAAA,EAAAA,IAACuB,EAAAA,IAAI,QACHC,OAAO,MACPC,YAAY,SACZC,GAAG,mBACHC,aAAa,OACbC,EAAG,EACHC,UAAU,SACVC,GAAI,EACJC,GAAI,EACJC,EAAE,QACEjC,IAEJC,EAAAA,EAAAA,IAACuB,EAAAA,GAAI,CAACM,UAAU,SAASI,IAAK,IAC5BjC,EAAAA,EAAAA,IAACkC,EAAAA,GAAO,CAACC,GAAG,KAAKC,EAAG,EAAGN,GAAI,EAAGO,SAAS,WAAWC,WAAW,QAxCjDhC,IACXA,GAMEN,EAAAA,EAAAA,IAACuC,EAAAA,EAAW,CAACC,GAAG,oCALjBpC,IACAO,GAAmBX,EAAAA,EAAAA,IAACuC,EAAAA,EAAW,CAACC,GAAG,kCACnCnC,GAAkBL,EAAAA,EAAAA,IAACuC,EAAAA,EAAW,CAACC,GAAG,kCAC/BxC,EAAAA,EAAAA,IAACuC,EAAAA,EAAW,CAACC,GAAG,+BAoClBC,CAASnC,IAEXA,IACCN,EAAAA,EAAAA,IAAAA,IAAAA,MACEA,EAAAA,EAAAA,IAACuC,EAAAA,EAAW,CAACC,GAAG,uCAAwC,KACxDxC,EAAAA,EAAAA,IAACuC,EAAAA,EAAW,CAACC,GAAG,6CAGpBxC,EAAAA,EAAAA,IAACuB,EAAAA,GAAI,CAACU,IAAK,GACP3B,GAkBAN,EAAAA,EAAAA,IAAC0C,EAAAA,EAAM,CAACC,QAAQ,gBAAgBzC,QAlDjB,MACvBgB,EAAAA,EAAAA,GAAiB,CACfC,cAAc,yBACdC,YAAY,UACZC,UAAW,2BAEbT,QAAUH,GAAaG,OAAOgC,KAAKnC,EAAW,SAAS,IA6C7CT,EAAAA,EAAAA,IAACuC,EAAAA,EAAW,CAACC,GAAG,oCAlBlBxC,EAAAA,EAAAA,IAAAA,EAAAA,SAAAA,MACEA,EAAAA,EAAAA,IAAC0C,EAAAA,EAAM,CACLC,QAAQ,gBACRE,UAAU7C,EAAAA,EAAAA,IAAC8C,EAAAA,GAAoB,MAC/B5C,QAAS,IAAMc,GAAa,KAE5BhB,EAAAA,EAAAA,IAACuC,EAAAA,EAAW,CAACC,GAAG,UAElBxC,EAAAA,EAAAA,IAAC0C,EAAAA,EAAM,CACLC,QAAQ,gBACRE,UAAU7C,EAAAA,EAAAA,IAAC8C,EAAAA,GAAoB,CAACC,UAAU,eAC1C7C,QAAS,IAAMc,GAAa,KAE5BhB,EAAAA,EAAAA,IAACuC,EAAAA,EAAW,CAACC,GAAG,WAUrB,C,wECvGJ,SAASQ,EAAUC,EAAWC,GAGnC,IAFyBC,QAAQF,GAG/B,MAAM,IAAIG,MACG,MAAXF,EAAkBA,EAAU,kCAGlC,CCPA,MAAMG,EAAa,eASZ,SAASC,EAAYC,EAAQC,GAClC,IAAIC,EAAgB,EAChBC,EAAO,EAEX,IAAK,MAAMC,KAASJ,EAAOK,KAAKC,SAASR,GAAa,CAGpD,GAFuB,iBAAhBM,EAAMG,OAAsBd,GAAU,GAEzCW,EAAMG,OAASN,EACjB,MAGFC,EAAgBE,EAAMG,MAAQH,EAAM,GAAGI,OACvCL,GAAQ,CACV,CAEA,MAAO,CACLA,OACAM,OAAQR,EAAW,EAAIC,EAE3B,CCdO,SAASQ,EAAoBV,EAAQW,GAC1C,MAAMC,EAAwBZ,EAAOa,eAAeJ,OAAS,EACvDJ,EAAO,GAAGS,SAASF,GAAyBZ,EAAOK,KACnDU,EAAYJ,EAAeR,KAAO,EAClCa,EAAahB,EAAOa,eAAeV,KAAO,EAC1Cc,EAAUN,EAAeR,KAAOa,EAChCE,EAAuC,IAAxBP,EAAeR,KAAaS,EAAwB,EACnEO,EAAYR,EAAeF,OAASS,EACpCE,EAAc,GAAGpB,EAAOqB,QAAQJ,KAAWE,MAC3CG,EAAQjB,EAAKkB,MAAM,gBACnBC,EAAeF,EAAMP,GAE3B,GAAIS,EAAahB,OAAS,IAAK,CAC7B,MAAMiB,EAAeC,KAAKC,MAAMR,EAAY,IACtCS,EAAmBT,EAAY,GAC/BU,EAAW,GAEjB,IAAK,IAAIC,EAAI,EAAGA,EAAIN,EAAahB,OAAQsB,GAAK,GAC5CD,EAASE,KAAKP,EAAaQ,MAAMF,EAAGA,EAAI,KAG1C,OACEV,EACAa,EAAmB,CACjB,CAAC,GAAGhB,MAAaY,EAAS,OACvBA,EAASG,MAAM,EAAGP,EAAe,GAAGS,KAAKC,GAAY,CAAC,IAAKA,KAC9D,CAAC,IAAK,IAAIrB,SAASc,IACnB,CAAC,IAAKC,EAASJ,EAAe,KAGpC,CAEA,OACEL,EACAa,EAAmB,CAEjB,CAAIhB,EAAU,EAAb,KAAoBK,EAAMP,EAAY,IACvC,CAAC,GAAGE,MAAaO,GACjB,CAAC,IAAK,IAAIV,SAASK,IACnB,CAAC,GAAGF,EAAU,MAAOK,EAAMP,EAAY,KAG7C,CAEA,SAASkB,EAAmBX,GAC1B,MAAMc,EAAgBd,EAAMe,QAAO,EAAEC,EAAGnC,UAAmBoC,IAATpC,IAC5CqC,EAASd,KAAKe,OAAOL,EAAcF,KAAI,EAAEQ,KAAYA,EAAOlC,UAClE,OAAO4B,EACJF,KAAI,EAAEQ,EAAQvC,KAAUuC,EAAO5B,SAAS0B,IAAWrC,EAAO,IAAMA,EAAO,MACvEwC,KAAK,KACV,CCnCO,MAAMC,UAAqB/C,MA8ChCgD,YAAYlD,KAAYmD,GACtB,IAAIC,EAAaC,EAAiB3G,EAElC,MAAM,MAAE4G,EAAK,OAAEjD,EAAM,UAAEkD,EAAS,KAAEC,EAAI,cAAEC,EAAa,WAAEC,GAxE3D,SAA6BC,GAC3B,MAAMC,EAAWD,EAAK,GAEtB,OAAgB,MAAZC,GAAoB,SAAUA,GAAY,WAAYA,EACjD,CACLN,MAAOM,EACPvD,OAAQsD,EAAK,GACbJ,UAAWI,EAAK,GAChBH,KAAMG,EAAK,GACXF,cAAeE,EAAK,GACpBD,WAAYC,EAAK,IAIdC,CACT,CA0DMC,CAAoBV,GACtBW,MAAM9D,GACN+D,KAAKrC,KAAO,eACZqC,KAAKP,KAAOA,QAAmCA,OAAOZ,EACtDmB,KAAKN,cACHA,QACIA,OACAb,EAENmB,KAAKT,MAAQU,EACXC,MAAMC,QAAQZ,GAASA,EAAQA,EAAQ,CAACA,QAASV,GAEnD,MAAMuB,EAAgBH,EACW,QAA9BZ,EAAcW,KAAKT,aAAmC,IAAhBF,OACnC,EACAA,EAAYb,KAAK6B,GAASA,EAAKC,MAAK3B,QAAQ2B,GAAe,MAAPA,KAG1DN,KAAK1D,OACHA,QACIA,EACA8D,SAEyC,QAAxCd,EAAkBc,EAAc,UACb,IAApBd,OAFA,EAIAA,EAAgBhD,OACtB0D,KAAKR,UACHA,QACIA,EACAY,aACA,EACAA,EAAc5B,KAAK8B,GAAQA,EAAIC,QACrCP,KAAKQ,UACHhB,GAAalD,EACTkD,EAAUhB,KAAKiC,GAAQpE,EAAYC,EAAQmE,KAC3CL,aACA,EACAA,EAAc5B,KAAK8B,GAAQjE,EAAYiE,EAAIhE,OAAQgE,EAAIC,SAC7D,MAAMG,EClHe,iBADIC,EDoHvBjB,aACI,EACAA,EAAcC,aCrHuB,OAAVgB,EDuH7BjB,aACE,EACAA,EAAcC,gBAChBd,EC3HD,IAAsB8B,ED4HzBX,KAAKL,WAI2B,QAH7BhH,EACCgH,QACIA,EACAe,SAAyC,IAAT/H,EAClCA,EACAiI,OAAOC,OAAO,MAGpBD,OAAOE,iBAAiBd,KAAM,CAC5B/D,QAAS,CACP8E,UAAU,EACVC,YAAY,GAEdrD,KAAM,CACJqD,YAAY,GAEdzB,MAAO,CACLyB,YAAY,GAEd1E,OAAQ,CACN0E,YAAY,GAEdxB,UAAW,CACTwB,YAAY,GAEdtB,cAAe,CACbsB,YAAY,KAQdtB,SAEAA,EAAcuB,MAEdL,OAAOM,eAAelB,KAAM,QAAS,CACnCW,MAAOjB,EAAcuB,MACrBF,UAAU,EACVI,cAAc,IAEPhF,MAAMiF,kBACfjF,MAAMiF,kBAAkBpB,KAAMd,GAE9B0B,OAAOM,eAAelB,KAAM,QAAS,CACnCW,MAAOxE,QAAQ8E,MACfF,UAAU,EACVI,cAAc,GAIpB,CAEYE,IAAPC,OAAOD,eACV,MAAO,cACT,CAEAE,WACE,IAAIC,EAASxB,KAAK/D,QAElB,GAAI+D,KAAKT,MACP,IAAK,MAAMc,KAAQL,KAAKT,MAClBc,EAAKC,MACPkB,GAAU,OD5LXxE,GADqBpD,EC6LayG,EAAKC,KD3LnChE,OACTD,EAAYzC,EAAS0C,OAAQ1C,EAAS2G,cC6L/B,GAAIP,KAAK1D,QAAU0D,KAAKQ,UAC7B,IAAK,MAAM5G,KAAYoG,KAAKQ,UAC1BgB,GAAU,OAASxE,EAAoBgD,KAAK1D,OAAQ1C,GDlMrD,IAAuBA,ECsM1B,OAAO4H,CACT,CAEAC,SACE,MAAMC,EAAiB,CACrBzF,QAAS+D,KAAK/D,SAehB,OAZsB,MAAlB+D,KAAKQ,YACPkB,EAAelB,UAAYR,KAAKQ,WAGjB,MAAbR,KAAKP,OACPiC,EAAejC,KAAOO,KAAKP,MAGN,MAAnBO,KAAKL,YAAsBiB,OAAOe,KAAK3B,KAAKL,YAAY7C,OAAS,IACnE4E,EAAe/B,WAAaK,KAAKL,YAG5B+B,CACT,EAGF,SAASzB,EAAiB2B,GACxB,YAAiB/C,IAAV+C,GAAwC,IAAjBA,EAAM9E,YAAe+B,EAAY+C,CACjE,CE/NO,SAASC,EAAYvF,EAAQC,EAAUuF,GAC5C,OAAO,IAAI5C,EAAa,iBAAiB4C,IAAe,CACtDxF,SACAkD,UAAW,CAACjD,IAEhB,C,ICRIwF,E,YAEJ,SAAWA,GACTA,EAAyB,MAAI,QAC7BA,EAA4B,SAAI,WAChCA,EAAgC,aAAI,eACpCA,EAAyB,MAAI,QAC7BA,EAAuC,oBAAI,sBAC3CA,EAAmC,gBAAI,kBACvCA,EAAmC,gBAAI,kBACvCA,EAAuC,oBAAI,sBAC3CA,EAA0B,OAAI,SAC9BA,EAA0B,OAAI,SAC9BA,EAA0B,OAAI,SAC9BA,EAAoC,iBAAI,mBACxCA,EAAuC,oBAAI,sBAC3CA,EAA6B,UAAI,YACjCA,EAAyB,MAAI,QAC7BA,EAAwB,KAAI,OAC5BA,EAA8B,WAAI,aAClCA,EAAgC,aAAI,eACpCA,EAA0C,uBAAI,wBAC/C,CApBD,CAoBGA,IAAsBA,EAAoB,CAAC,I,ICrB1C,E,kCAEJ,SAAWC,GACTA,EAAe,IAAI,QACnBA,EAAe,IAAI,QACnBA,EAAgB,KAAI,IACpBA,EAAkB,OAAI,IACtBA,EAAe,IAAI,IACnBA,EAAmB,QAAI,IACvBA,EAAmB,QAAI,IACvBA,EAAkB,OAAI,MACtBA,EAAiB,MAAI,IACrBA,EAAkB,OAAI,IACtBA,EAAc,GAAI,IAClBA,EAAqB,UAAI,IACzBA,EAAqB,UAAI,IACzBA,EAAmB,QAAI,IACvBA,EAAgB,KAAI,IACpBA,EAAmB,QAAI,IACvBA,EAAgB,KAAI,OACpBA,EAAe,IAAI,MACnBA,EAAiB,MAAI,QACrBA,EAAkB,OAAI,SACtBA,EAAwB,aAAI,cAC5BA,EAAmB,QAAI,SACxB,CAvBD,CAuBG,IAAc,EAAY,CAAC,ICfvB,MAAMC,EAgBX9C,YAAY7C,GACV,MAAM4F,EAAmB,IAAI,KAAM,MAAe,EAAG,EAAG,EAAG,GAC3DlC,KAAK1D,OAASA,EACd0D,KAAKmC,UAAYD,EACjBlC,KAAKoC,MAAQF,EACblC,KAAKvD,KAAO,EACZuD,KAAKqC,UAAY,CACnB,CAEYhB,IAAPC,OAAOD,eACV,MAAO,OACT,CAKAiB,UACEtC,KAAKmC,UAAYnC,KAAKoC,MAEtB,OADepC,KAAKoC,MAAQpC,KAAKuC,WAEnC,CAMAA,YACE,IAAIH,EAAQpC,KAAKoC,MAEjB,GAAIA,EAAMI,OAAS,MACjB,GACE,GAAIJ,EAAMK,KACRL,EAAQA,EAAMK,SACT,CAEL,MAAMC,EAAYC,EAAc3C,KAAMoC,EAAMQ,KAE5CR,EAAMK,KAAOC,EAEbA,EAAUG,KAAOT,EACjBA,EAAQM,CACV,QACON,EAAMI,OAAS,WAG1B,OAAOJ,CACT,EAiCF,SAASU,EAAqBC,GAC5B,OACGA,GAAQ,GAAUA,GAAQ,OAAYA,GAAQ,OAAUA,GAAQ,OAErE,CAUA,SAASC,EAAyBrG,EAAM/C,GACtC,OACEqJ,EAAmBtG,EAAKuG,WAAWtJ,KACnCuJ,EAAoBxG,EAAKuG,WAAWtJ,EAAW,GAEnD,CAEA,SAASqJ,EAAmBF,GAC1B,OAAOA,GAAQ,OAAUA,GAAQ,KACnC,CAEA,SAASI,EAAoBJ,GAC3B,OAAOA,GAAQ,OAAUA,GAAQ,KACnC,CASA,SAASK,EAAiBC,EAAOzJ,GAC/B,MAAMmJ,EAAOM,EAAM/G,OAAOK,KAAK2G,YAAY1J,GAE3C,QAAaiF,IAATkE,EACF,OAAO,MACF,GAAIA,GAAQ,IAAUA,GAAQ,IAAQ,CAE3C,MAAMQ,EAAOlJ,OAAOmJ,cAAcT,GAClC,MAAgB,MAATQ,EAAe,OAAS,IAAIA,IACrC,CAEA,MAAO,KAAOR,EAAKxB,SAAS,IAAIkC,cAAcrG,SAAS,EAAG,IAC5D,CAKA,SAASsG,EAAYL,EAAOb,EAAMjC,EAAOqC,EAAKjC,GAC5C,MAAMlE,EAAO4G,EAAM5G,KACbkH,EAAM,EAAIpD,EAAQ8C,EAAMhB,UAC9B,OAAO,IAAI,KAAMG,EAAMjC,EAAOqC,EAAKnG,EAAMkH,EAAKhD,EAChD,CASA,SAASgC,EAAcU,EAAO9C,GAC5B,MAAM5D,EAAO0G,EAAM/G,OAAOK,KACpBiH,EAAajH,EAAKG,OACxB,IAAIP,EAAWgE,EAEf,KAAOhE,EAAWqH,GAAY,CAC5B,MAAMb,EAAOpG,EAAKuG,WAAW3G,GAE7B,OAAQwG,GAeN,KAAK,MAEL,KAAK,EAEL,KAAK,GAEL,KAAK,KAEDxG,EACF,SAMF,KAAK,KAEDA,IACA8G,EAAM5G,KACR4G,EAAMhB,UAAY9F,EAClB,SAEF,KAAK,GAEmC,KAAlCI,EAAKuG,WAAW3G,EAAW,GAC7BA,GAAY,IAEVA,IAGF8G,EAAM5G,KACR4G,EAAMhB,UAAY9F,EAClB,SAGF,KAAK,GAEH,OAAOsH,EAAYR,EAAO9G,GAU5B,KAAK,GAEH,OAAOmH,EAAYL,EAAO,OAAgB9G,EAAUA,EAAW,GAEjE,KAAK,GAEH,OAAOmH,EAAYL,EAAO,SAAkB9G,EAAUA,EAAW,GAEnE,KAAK,GAEH,OAAOmH,EAAYL,EAAO,MAAe9G,EAAUA,EAAW,GAEhE,KAAK,GAEH,OAAOmH,EAAYL,EAAO,UAAmB9G,EAAUA,EAAW,GAEpE,KAAK,GAEH,OAAOmH,EAAYL,EAAO,UAAmB9G,EAAUA,EAAW,GAEpE,KAAK,GAEH,GACoC,KAAlCI,EAAKuG,WAAW3G,EAAW,IACO,KAAlCI,EAAKuG,WAAW3G,EAAW,GAE3B,OAAOmH,EAAYL,EAAO,SAAkB9G,EAAUA,EAAW,GAGnE,MAEF,KAAK,GAEH,OAAOmH,EAAYL,EAAO,QAAiB9G,EAAUA,EAAW,GAElE,KAAK,GAEH,OAAOmH,EAAYL,EAAO,SAAkB9G,EAAUA,EAAW,GAEnE,KAAK,GAEH,OAAOmH,EAAYL,EAAO,KAAc9G,EAAUA,EAAW,GAE/D,KAAK,GAEH,OAAOmH,EAAYL,EAAO,YAAqB9G,EAAUA,EAAW,GAEtE,KAAK,GAEH,OAAOmH,EAAYL,EAAO,YAAqB9G,EAAUA,EAAW,GAEtE,KAAK,IAEH,OAAOmH,EAAYL,EAAO,UAAmB9G,EAAUA,EAAW,GAEpE,KAAK,IAEH,OAAOmH,EAAYL,EAAO,OAAgB9G,EAAUA,EAAW,GAEjE,KAAK,IAEH,OAAOmH,EAAYL,EAAO,UAAmB9G,EAAUA,EAAW,GAGpE,KAAK,GAEH,OACoC,KAAlCI,EAAKuG,WAAW3G,EAAW,IACO,KAAlCI,EAAKuG,WAAW3G,EAAW,GAEpBuH,EAAgBT,EAAO9G,GAGzBwH,EAAWV,EAAO9G,GAG7B,IAAI,QAAQwG,IAAkB,KAATA,EACnB,OAAOiB,EAAWX,EAAO9G,EAAUwG,GAGrC,IAAI,QAAYA,GACd,OAAOkB,EAASZ,EAAO9G,GAGzB,MAAMsF,EACJwB,EAAM/G,OACNC,EACS,KAATwG,EACI,kFACAD,EAAqBC,IAASC,EAAyBrG,EAAMJ,GAC7D,yBAAyB6G,EAAiBC,EAAO9G,MACjD,sBAAsB6G,EAAiBC,EAAO9G,MAEtD,CAEA,OAAOmH,EAAYL,EAAO,MAAeO,EAAYA,EACvD,CAWA,SAASC,EAAYR,EAAO9C,GAC1B,MAAM5D,EAAO0G,EAAM/G,OAAOK,KACpBiH,EAAajH,EAAKG,OACxB,IAAIP,EAAWgE,EAAQ,EAEvB,KAAOhE,EAAWqH,GAAY,CAC5B,MAAMb,EAAOpG,EAAKuG,WAAW3G,GAE7B,GAAa,KAATwG,GAA4B,KAATA,EACrB,MAGF,GAAID,EAAqBC,KACrBxG,MACG,KAAIyG,EAAyBrG,EAAMJ,GAGxC,MAFAA,GAAY,CAGd,CACF,CAEA,OAAOmH,EACLL,EACA,UACA9C,EACAhE,EACAI,EAAK2B,MAAMiC,EAAQ,EAAGhE,GAE1B,CA+BA,SAASyH,EAAWX,EAAO9C,EAAO2D,GAChC,MAAMvH,EAAO0G,EAAM/G,OAAOK,KAC1B,IAAIJ,EAAWgE,EACXwC,EAAOmB,EACPC,GAAU,EAMd,GAJa,KAATpB,IACFA,EAAOpG,EAAKuG,aAAa3G,IAGd,KAATwG,GAGF,GAFAA,EAAOpG,EAAKuG,aAAa3G,IAErB,QAAQwG,GACV,MAAMlB,EACJwB,EAAM/G,OACNC,EACA,6CAA6C6G,EAC3CC,EACA9G,YAKNA,EAAW6H,EAAWf,EAAO9G,EAAUwG,GACvCA,EAAOpG,EAAKuG,WAAW3G,GAsBzB,GAnBa,KAATwG,IACFoB,GAAU,EACVpB,EAAOpG,EAAKuG,aAAa3G,GACzBA,EAAW6H,EAAWf,EAAO9G,EAAUwG,GACvCA,EAAOpG,EAAKuG,WAAW3G,IAGZ,KAATwG,GAA4B,MAATA,IACrBoB,GAAU,EACVpB,EAAOpG,EAAKuG,aAAa3G,GAEZ,KAATwG,GAA4B,KAATA,IACrBA,EAAOpG,EAAKuG,aAAa3G,IAG3BA,EAAW6H,EAAWf,EAAO9G,EAAUwG,GACvCA,EAAOpG,EAAKuG,WAAW3G,IAGZ,KAATwG,IAAmB,QAAYA,GACjC,MAAMlB,EACJwB,EAAM/G,OACNC,EACA,2CAA2C6G,EACzCC,EACA9G,OAKN,OAAOmH,EACLL,EACAc,EAAU,QAAkB,MAC5B5D,EACAhE,EACAI,EAAK2B,MAAMiC,EAAOhE,GAEtB,CAKA,SAAS6H,EAAWf,EAAO9C,EAAO2D,GAChC,KAAK,QAAQA,GACX,MAAMrC,EACJwB,EAAM/G,OACNiE,EACA,2CAA2C6C,EACzCC,EACA9C,OAKN,MAAM5D,EAAO0G,EAAM/G,OAAOK,KAC1B,IAAIJ,EAAWgE,EAAQ,EAEvB,MAAO,QAAQ5D,EAAKuG,WAAW3G,OAC3BA,EAGJ,OAAOA,CACT,CAsBA,SAASwH,EAAWV,EAAO9C,GACzB,MAAM5D,EAAO0G,EAAM/G,OAAOK,KACpBiH,EAAajH,EAAKG,OACxB,IAAIP,EAAWgE,EAAQ,EACnB8D,EAAa9H,EACboE,EAAQ,GAEZ,KAAOpE,EAAWqH,GAAY,CAC5B,MAAMb,EAAOpG,EAAKuG,WAAW3G,GAE7B,GAAa,KAATwG,EAEF,OADApC,GAAShE,EAAK2B,MAAM+F,EAAY9H,GACzBmH,EAAYL,EAAO,SAAkB9C,EAAOhE,EAAW,EAAGoE,GAGnE,GAAa,KAAToC,EAAJ,CAcA,GAAa,KAATA,GAA4B,KAATA,EACrB,MAGF,GAAID,EAAqBC,KACrBxG,MACG,KAAIyG,EAAyBrG,EAAMJ,GAGxC,MAAMsF,EACJwB,EAAM/G,OACNC,EACA,oCAAoC6G,EAClCC,EACA9G,OAPJA,GAAY,CAUd,CAnBA,KAZA,CACEoE,GAAShE,EAAK2B,MAAM+F,EAAY9H,GAChC,MAAM+H,EAC8B,MAAlC3H,EAAKuG,WAAW3G,EAAW,GACW,MAAlCI,EAAKuG,WAAW3G,EAAW,GACzBgI,EAAgClB,EAAO9G,GACvCiI,EAA6BnB,EAAO9G,GACtCkI,EAAqBpB,EAAO9G,GAClCoE,GAAS2D,EAAO3D,MAChBpE,GAAY+H,EAAOI,KACnBL,EAAa9H,CAEf,CAoBF,CAEA,MAAMsF,EAAYwB,EAAM/G,OAAQC,EAAU,uBAC5C,CAEA,SAASgI,EAAgClB,EAAO9G,GAC9C,MAAMI,EAAO0G,EAAM/G,OAAOK,KAC1B,IAAIgI,EAAQ,EACRD,EAAO,EAEX,KAAOA,EAAO,IAAI,CAChB,MAAM3B,EAAOpG,EAAKuG,WAAW3G,EAAWmI,KAExC,GAAa,MAAT3B,EAAiB,CAEnB,GAAI2B,EAAO,IAAM5B,EAAqB6B,GACpC,MAGF,MAAO,CACLhE,MAAOtG,OAAOmJ,cAAcmB,GAC5BD,OAEJ,CAIA,GAFAC,EAASA,GAAS,EAAKC,EAAa7B,GAEhC4B,EAAQ,EACV,KAEJ,CAEA,MAAM9C,EACJwB,EAAM/G,OACNC,EACA,qCAAqCI,EAAK2B,MACxC/B,EACAA,EAAWmI,OAGjB,CAEA,SAASF,EAA6BnB,EAAO9G,GAC3C,MAAMI,EAAO0G,EAAM/G,OAAOK,KACpBoG,EAAO8B,EAAiBlI,EAAMJ,EAAW,GAE/C,GAAIuG,EAAqBC,GACvB,MAAO,CACLpC,MAAOtG,OAAOmJ,cAAcT,GAC5B2B,KAAM,GAKV,GAAIzB,EAAmBF,IAGe,KAAlCpG,EAAKuG,WAAW3G,EAAW,IACO,MAAlCI,EAAKuG,WAAW3G,EAAW,GAC3B,CACA,MAAMuI,EAAeD,EAAiBlI,EAAMJ,EAAW,GAEvD,GAAI4G,EAAoB2B,GAOtB,MAAO,CACLnE,MAAOtG,OAAOmJ,cAAcT,EAAM+B,GAClCJ,KAAM,GAGZ,CAGF,MAAM7C,EACJwB,EAAM/G,OACNC,EACA,qCAAqCI,EAAK2B,MAAM/B,EAAUA,EAAW,OAEzE,CASA,SAASsI,EAAiBlI,EAAMJ,GAG9B,OACGqI,EAAajI,EAAKuG,WAAW3G,KAAc,GAC3CqI,EAAajI,EAAKuG,WAAW3G,EAAW,KAAO,EAC/CqI,EAAajI,EAAKuG,WAAW3G,EAAW,KAAO,EAChDqI,EAAajI,EAAKuG,WAAW3G,EAAW,GAE5C,CAgBA,SAASqI,EAAa7B,GACpB,OAAOA,GAAQ,IAAUA,GAAQ,GAC7BA,EAAO,GACPA,GAAQ,IAAUA,GAAQ,GAC1BA,EAAO,GACPA,GAAQ,IAAUA,GAAQ,IAC1BA,EAAO,IACN,CACP,CAcA,SAAS0B,EAAqBpB,EAAO9G,GACnC,MAAMI,EAAO0G,EAAM/G,OAAOK,KAG1B,OAFaA,EAAKuG,WAAW3G,EAAW,IAGtC,KAAK,GAEH,MAAO,CACLoE,MAAO,IACP+D,KAAM,GAGV,KAAK,GAEH,MAAO,CACL/D,MAAO,KACP+D,KAAM,GAGV,KAAK,GAEH,MAAO,CACL/D,MAAO,IACP+D,KAAM,GAGV,KAAK,GAEH,MAAO,CACL/D,MAAO,KACP+D,KAAM,GAGV,KAAK,IAEH,MAAO,CACL/D,MAAO,KACP+D,KAAM,GAGV,KAAK,IAEH,MAAO,CACL/D,MAAO,KACP+D,KAAM,GAGV,KAAK,IAEH,MAAO,CACL/D,MAAO,KACP+D,KAAM,GAGV,KAAK,IAEH,MAAO,CACL/D,MAAO,KACP+D,KAAM,GAIZ,MAAM7C,EACJwB,EAAM/G,OACNC,EACA,uCAAuCI,EAAK2B,MAC1C/B,EACAA,EAAW,OAGjB,CAcA,SAASuH,EAAgBT,EAAO9C,GAC9B,MAAM5D,EAAO0G,EAAM/G,OAAOK,KACpBiH,EAAajH,EAAKG,OACxB,IAAIuF,EAAYgB,EAAMhB,UAClB9F,EAAWgE,EAAQ,EACnB8D,EAAa9H,EACbwI,EAAc,GAClB,MAAMC,EAAa,GAEnB,KAAOzI,EAAWqH,GAAY,CAC5B,MAAMb,EAAOpG,EAAKuG,WAAW3G,GAE7B,GACW,KAATwG,GACkC,KAAlCpG,EAAKuG,WAAW3G,EAAW,IACO,KAAlCI,EAAKuG,WAAW3G,EAAW,GAC3B,CACAwI,GAAepI,EAAK2B,MAAM+F,EAAY9H,GACtCyI,EAAW3G,KAAK0G,GAChB,MAAM3C,EAAQsB,EACZL,EACA,eACA9C,EACAhE,EAAW,GACX,QAAuByI,GAAY/F,KAAK,OAI1C,OAFAoE,EAAM5G,MAAQuI,EAAWlI,OAAS,EAClCuG,EAAMhB,UAAYA,EACXD,CACT,CAEA,GACW,KAATW,GACkC,KAAlCpG,EAAKuG,WAAW3G,EAAW,IACO,KAAlCI,EAAKuG,WAAW3G,EAAW,IACO,KAAlCI,EAAKuG,WAAW3G,EAAW,GAS7B,GAAa,KAATwG,GAA4B,KAATA,EAgBvB,GAAID,EAAqBC,KACrBxG,MACG,KAAIyG,EAAyBrG,EAAMJ,GAGxC,MAAMsF,EACJwB,EAAM/G,OACNC,EACA,oCAAoC6G,EAClCC,EACA9G,OAPJA,GAAY,CAUd,MA5BEwI,GAAepI,EAAK2B,MAAM+F,EAAY9H,GACtCyI,EAAW3G,KAAK0G,GAEH,KAAThC,GAAqD,KAAlCpG,EAAKuG,WAAW3G,EAAW,GAChDA,GAAY,IAEVA,EAGJwI,EAAc,GACdV,EAAa9H,EACb8F,EAAY9F,OAnBZwI,GAAepI,EAAK2B,MAAM+F,EAAY9H,GACtC8H,EAAa9H,EAAW,EAExBA,GAAY,CAkChB,CAEA,MAAMsF,EAAYwB,EAAM/G,OAAQC,EAAU,uBAC5C,CAUA,SAAS0H,EAASZ,EAAO9C,GACvB,MAAM5D,EAAO0G,EAAM/G,OAAOK,KACpBiH,EAAajH,EAAKG,OACxB,IAAIP,EAAWgE,EAAQ,EAEvB,KAAOhE,EAAWqH,GAAY,CAC5B,MAAMb,EAAOpG,EAAKuG,WAAW3G,GAE7B,KAAI,QAAewG,GAGjB,QAFExG,CAIN,CAEA,OAAOmH,EACLL,EACA,OACA9C,EACAhE,EACAI,EAAK2B,MAAMiC,EAAOhE,GAEtB,C,cCtzBO,MAAM0I,EACX9F,YAAY7C,EAAQ4I,EAAU,CAAC,GAC7B,MAAMC,GAAY,OAAS7I,GAAUA,EAAS,IAAI,IAAOA,GACzD0D,KAAKoF,OAAS,IAAInD,EAAMkD,GACxBnF,KAAKqF,SAAWH,EAChBlF,KAAKsF,cAAgB,CACvB,CAKAC,YACE,MAAMnD,EAAQpC,KAAKwF,YAAY,QAC/B,OAAOxF,KAAKK,KAAK+B,EAAO,CACtBI,KAAM,SACN7B,MAAOyB,EAAMzB,OAEjB,CAMA8E,gBACE,OAAOzF,KAAKK,KAAKL,KAAKoF,OAAOhD,MAAO,CAClCI,KAAM,aACNkD,YAAa1F,KAAK2F,KAChB,MACA3F,KAAK4F,gBACL,QAGN,CAyBAA,kBACE,GAAI5F,KAAK6F,KAAK,WACZ,OAAO7F,KAAK8F,2BAGd,MAAMC,EAAiB/F,KAAKgG,kBACtBC,EAAeF,EACjB/F,KAAKoF,OAAO7C,YACZvC,KAAKoF,OAAOhD,MAEhB,GAAI6D,EAAazD,OAAS,OAAgB,CACxC,OAAQyD,EAAatF,OACnB,IAAK,SACH,OAAOX,KAAKkG,wBAEd,IAAK,SACH,OAAOlG,KAAKmG,4BAEd,IAAK,OACH,OAAOnG,KAAKoG,4BAEd,IAAK,YACH,OAAOpG,KAAKqG,+BAEd,IAAK,QACH,OAAOrG,KAAKsG,2BAEd,IAAK,OACH,OAAOtG,KAAKuG,0BAEd,IAAK,QACH,OAAOvG,KAAKwG,iCAEd,IAAK,YACH,OAAOxG,KAAKyG,2BAGhB,GAAIV,EACF,MAAMlE,EACJ7B,KAAKoF,OAAO9I,OACZ0D,KAAKoF,OAAOhD,MAAM7B,MAClB,gFAIJ,OAAQ0F,EAAatF,OACnB,IAAK,QACL,IAAK,WACL,IAAK,eACH,OAAOX,KAAK8F,2BAEd,IAAK,WACH,OAAO9F,KAAK0G,0BAEd,IAAK,SACH,OAAO1G,KAAK2G,2BAElB,CAEA,MAAM3G,KAAK4G,WAAWX,EACxB,CAQAH,2BACE,MAAMvF,EAAQP,KAAKoF,OAAOhD,MAE1B,GAAIpC,KAAK6F,KAAK,WACZ,OAAO7F,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,yBACNqE,UAAW,WACXlJ,UAAMkB,EACNiI,oBAAqB,GACrBC,WAAY,GACZC,aAAchH,KAAKiH,sBAIvB,MAAMJ,EAAY7G,KAAKkH,qBACvB,IAAIvJ,EAMJ,OAJIqC,KAAK6F,KAAK,UACZlI,EAAOqC,KAAKuF,aAGPvF,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,yBACNqE,YACAlJ,OACAmJ,oBAAqB9G,KAAKmH,2BAC1BJ,WAAY/G,KAAKoH,iBAAgB,GACjCJ,aAAchH,KAAKiH,qBAEvB,CAKAC,qBACE,MAAMG,EAAiBrH,KAAKwF,YAAY,QAExC,OAAQ6B,EAAe1G,OACrB,IAAK,QACH,OAAO,WAET,IAAK,WACH,OAAO,cAET,IAAK,eACH,OAAO,kBAGX,MAAMX,KAAK4G,WAAWS,EACxB,CAKAF,2BACE,OAAOnH,KAAKsH,aACV,UACAtH,KAAKuH,wBACL,UAEJ,CAKAA,0BACE,OAAOvH,KAAKK,KAAKL,KAAKoF,OAAOhD,MAAO,CAClCI,KAAM,wBACNgF,SAAUxH,KAAKyH,gBACfC,MAAO1H,KAAKwF,YAAY,SAAkBxF,KAAK2H,sBAC/CC,aAAc5H,KAAK6H,oBAAoB,UACnC7H,KAAK8H,8BACLjJ,EACJkI,WAAY/G,KAAK+H,wBAErB,CAKAN,gBACE,MAAMlH,EAAQP,KAAKoF,OAAOhD,MAE1B,OADApC,KAAKwF,YAAY,UACVxF,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,aACN7E,KAAMqC,KAAKuF,aAEf,CAOA0B,oBACE,OAAOjH,KAAKK,KAAKL,KAAKoF,OAAOhD,MAAO,CAClCI,KAAM,kBACNwF,WAAYhI,KAAK2F,KACf,UACA3F,KAAKiI,eACL,YAGN,CAQAA,iBACE,OAAOjI,KAAK6F,KAAK,UACb7F,KAAKkI,gBACLlI,KAAKmI,YACX,CAOAA,aACE,MAAM5H,EAAQP,KAAKoF,OAAOhD,MACpBgG,EAAcpI,KAAKuF,YACzB,IAAI8C,EACA1K,EASJ,OAPIqC,KAAK6H,oBAAoB,UAC3BQ,EAAQD,EACRzK,EAAOqC,KAAKuF,aAEZ5H,EAAOyK,EAGFpI,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,UACN6F,QACA1K,OACA2K,UAAWtI,KAAKuI,gBAAe,GAC/BxB,WAAY/G,KAAKoH,iBAAgB,GACjCJ,aAAchH,KAAK6F,KAAK,WACpB7F,KAAKiH,yBACLpI,GAER,CAKA0J,eAAeC,GACb,MAAMC,EAAOD,EAAUxI,KAAK0I,mBAAqB1I,KAAK2I,cACtD,OAAO3I,KAAKsH,aAAa,UAAmBmB,EAAM,UACpD,CAKAE,cAAcH,GAAU,GACtB,MAAMjI,EAAQP,KAAKoF,OAAOhD,MACpBzE,EAAOqC,KAAKuF,YAElB,OADAvF,KAAKwF,YAAY,SACVxF,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,aACN7E,OACAgD,MAAOX,KAAK4I,kBAAkBJ,IAElC,CAEAE,qBACE,OAAO1I,KAAK2I,eAAc,EAC5B,CAUAT,gBACE,MAAM3H,EAAQP,KAAKoF,OAAOhD,MAC1BpC,KAAKwF,YAAY,UACjB,MAAMqD,EAAmB7I,KAAK8I,sBAAsB,MAEpD,OAAKD,GAAoB7I,KAAK6F,KAAK,QAC1B7F,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,oBACN7E,KAAMqC,KAAK+I,oBACXhC,WAAY/G,KAAKoH,iBAAgB,KAI9BpH,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,oBACNwG,cAAeH,EAAmB7I,KAAKiJ,sBAAmBpK,EAC1DkI,WAAY/G,KAAKoH,iBAAgB,GACjCJ,aAAchH,KAAKiH,qBAEvB,CAQAP,0BACE,MAAMnG,EAAQP,KAAKoF,OAAOhD,MAK1B,OAJApC,KAAKkJ,cAAc,aAIgC,IAA/ClJ,KAAKqF,SAAS8D,6BACTnJ,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,wBACN7E,KAAMqC,KAAK+I,oBACXjC,oBAAqB9G,KAAKmH,2BAC1B6B,eAAgBhJ,KAAKkJ,cAAc,MAAOlJ,KAAKiJ,kBAC/ClC,WAAY/G,KAAKoH,iBAAgB,GACjCJ,aAAchH,KAAKiH,sBAIhBjH,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,wBACN7E,KAAMqC,KAAK+I,oBACXC,eAAgBhJ,KAAKkJ,cAAc,MAAOlJ,KAAKiJ,kBAC/ClC,WAAY/G,KAAKoH,iBAAgB,GACjCJ,aAAchH,KAAKiH,qBAEvB,CAKA8B,oBACE,GAAgC,OAA5B/I,KAAKoF,OAAOhD,MAAMzB,MACpB,MAAMX,KAAK4G,aAGb,OAAO5G,KAAKuF,WACd,CAqBAqD,kBAAkBJ,GAChB,MAAMpG,EAAQpC,KAAKoF,OAAOhD,MAE1B,OAAQA,EAAMI,MACZ,KAAK,YACH,OAAOxC,KAAKoJ,UAAUZ,GAExB,KAAK,UACH,OAAOxI,KAAKqJ,YAAYb,GAE1B,KAAK,MAEH,OADAxI,KAAKsJ,eACEtJ,KAAKK,KAAK+B,EAAO,CACtBI,KAAM,QACN7B,MAAOyB,EAAMzB,QAGjB,KAAK,QAEH,OADAX,KAAKsJ,eACEtJ,KAAKK,KAAK+B,EAAO,CACtBI,KAAM,UACN7B,MAAOyB,EAAMzB,QAGjB,KAAK,SACL,KAAK,eACH,OAAOX,KAAKuJ,qBAEd,KAAK,OAGH,OAFAvJ,KAAKsJ,eAEGlH,EAAMzB,OACZ,IAAK,OACH,OAAOX,KAAKK,KAAK+B,EAAO,CACtBI,KAAM,YACN7B,OAAO,IAGX,IAAK,QACH,OAAOX,KAAKK,KAAK+B,EAAO,CACtBI,KAAM,YACN7B,OAAO,IAGX,IAAK,OACH,OAAOX,KAAKK,KAAK+B,EAAO,CACtBI,KAAM,WAGV,QACE,OAAOxC,KAAKK,KAAK+B,EAAO,CACtBI,KAAM,SACN7B,MAAOyB,EAAMzB,QAIrB,KAAK,SACH,GAAI6H,EAAS,CAGX,GAFAxI,KAAKwF,YAAY,UAEbxF,KAAKoF,OAAOhD,MAAMI,OAAS,OAAgB,CAC7C,MAAMgH,EAAUxJ,KAAKoF,OAAOhD,MAAMzB,MAClC,MAAMkB,EACJ7B,KAAKoF,OAAO9I,OACZ8F,EAAM7B,MACN,yBAAyBiJ,wBAE7B,CACE,MAAMxJ,KAAK4G,WAAWxE,EAE1B,CAEA,OAAOpC,KAAKyH,gBAEd,QACE,MAAMzH,KAAK4G,aAEjB,CAEAkB,yBACE,OAAO9H,KAAK4I,mBAAkB,EAChC,CAEAW,qBACE,MAAMnH,EAAQpC,KAAKoF,OAAOhD,MAE1B,OADApC,KAAKsJ,eACEtJ,KAAKK,KAAK+B,EAAO,CACtBI,KAAM,WACN7B,MAAOyB,EAAMzB,MACb8I,MAAOrH,EAAMI,OAAS,gBAE1B,CAOA4G,UAAUZ,GAGR,OAAOxI,KAAKK,KAAKL,KAAKoF,OAAOhD,MAAO,CAClCI,KAAM,SACNkH,OAAQ1J,KAAK2J,IAAI,aAJN,IAAM3J,KAAK4I,kBAAkBJ,IAII,cAEhD,CASAa,YAAYb,GAGV,OAAOxI,KAAKK,KAAKL,KAAKoF,OAAOhD,MAAO,CAClCI,KAAM,WACNoH,OAAQ5J,KAAK2J,IAAI,WAJN,IAAM3J,KAAK6J,iBAAiBrB,IAIG,YAE9C,CAKAqB,iBAAiBrB,GACf,MAAMjI,EAAQP,KAAKoF,OAAOhD,MACpBzE,EAAOqC,KAAKuF,YAElB,OADAvF,KAAKwF,YAAY,SACVxF,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,iBACN7E,OACAgD,MAAOX,KAAK4I,kBAAkBJ,IAElC,CAMApB,gBAAgBoB,GACd,MAAMzB,EAAa,GAEnB,KAAO/G,KAAK6F,KAAK,OACfkB,EAAW1I,KAAK2B,KAAK8J,eAAetB,IAGtC,OAAOzB,CACT,CAEAgB,uBACE,OAAO/H,KAAKoH,iBAAgB,EAC9B,CAOA0C,eAAetB,GACb,MAAMjI,EAAQP,KAAKoF,OAAOhD,MAE1B,OADApC,KAAKwF,YAAY,MACVxF,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,cACN7E,KAAMqC,KAAKuF,YACX+C,UAAWtI,KAAKuI,eAAeC,IAEnC,CASAb,qBACE,MAAMpH,EAAQP,KAAKoF,OAAOhD,MAC1B,IAAIsF,EAEJ,GAAI1H,KAAK6H,oBAAoB,aAAsB,CACjD,MAAMkC,EAAY/J,KAAK2H,qBACvB3H,KAAKwF,YAAY,aACjBkC,EAAO1H,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,cACNkF,KAAMqC,GAEV,MACErC,EAAO1H,KAAKiJ,iBAGd,OAAIjJ,KAAK6H,oBAAoB,QACpB7H,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,kBACNkF,SAIGA,CACT,CAKAuB,iBACE,OAAOjJ,KAAKK,KAAKL,KAAKoF,OAAOhD,MAAO,CAClCI,KAAM,eACN7E,KAAMqC,KAAKuF,aAEf,CAEAS,kBACE,OAAOhG,KAAK6F,KAAK,WAAqB7F,KAAK6F,KAAK,eAClD,CAKAmE,mBACE,GAAIhK,KAAKgG,kBACP,OAAOhG,KAAKuJ,oBAEhB,CAOArD,wBACE,MAAM3F,EAAQP,KAAKoF,OAAOhD,MACpBN,EAAc9B,KAAKgK,mBACzBhK,KAAKkJ,cAAc,UACnB,MAAMnC,EAAa/G,KAAK+H,uBAClBkC,EAAiBjK,KAAK2F,KAC1B,UACA3F,KAAKkK,6BACL,WAEF,OAAOlK,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,sBACNV,cACAiF,aACAkD,kBAEJ,CAKAC,+BACE,MAAM3J,EAAQP,KAAKoF,OAAOhD,MACpByE,EAAY7G,KAAKkH,qBACvBlH,KAAKwF,YAAY,SACjB,MAAMkC,EAAO1H,KAAKiJ,iBAClB,OAAOjJ,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,8BACNqE,YACAa,QAEJ,CAKAvB,4BACE,MAAM5F,EAAQP,KAAKoF,OAAOhD,MACpBN,EAAc9B,KAAKgK,mBACzBhK,KAAKkJ,cAAc,UACnB,MAAMvL,EAAOqC,KAAKuF,YACZwB,EAAa/G,KAAK+H,uBACxB,OAAO/H,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,2BACNV,cACAnE,OACAoJ,cAEJ,CAOAX,4BACE,MAAM7F,EAAQP,KAAKoF,OAAOhD,MACpBN,EAAc9B,KAAKgK,mBACzBhK,KAAKkJ,cAAc,QACnB,MAAMvL,EAAOqC,KAAKuF,YACZ4E,EAAanK,KAAKoK,4BAClBrD,EAAa/G,KAAK+H,uBAClB6B,EAAS5J,KAAKqK,wBACpB,OAAOrK,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,2BACNV,cACAnE,OACAwM,aACApD,aACA6C,UAEJ,CAOAQ,4BACE,OAAOpK,KAAK8I,sBAAsB,cAC9B9I,KAAKsK,cAAc,MAAetK,KAAKiJ,gBACvC,EACN,CAOAoB,wBACE,OAAOrK,KAAKsH,aACV,UACAtH,KAAKuK,qBACL,UAEJ,CAMAA,uBACE,MAAMhK,EAAQP,KAAKoF,OAAOhD,MACpBN,EAAc9B,KAAKgK,mBACnBrM,EAAOqC,KAAKuF,YACZ3F,EAAOI,KAAKwK,oBAClBxK,KAAKwF,YAAY,SACjB,MAAMkC,EAAO1H,KAAK2H,qBACZZ,EAAa/G,KAAK+H,uBACxB,OAAO/H,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,qBACNV,cACAnE,OACA2K,UAAW1I,EACX8H,OACAX,cAEJ,CAKAyD,oBACE,OAAOxK,KAAKsH,aACV,UACAtH,KAAKyK,mBACL,UAEJ,CAMAA,qBACE,MAAMlK,EAAQP,KAAKoF,OAAOhD,MACpBN,EAAc9B,KAAKgK,mBACnBrM,EAAOqC,KAAKuF,YAClBvF,KAAKwF,YAAY,SACjB,MAAMkC,EAAO1H,KAAK2H,qBAClB,IAAIC,EAEA5H,KAAK6H,oBAAoB,YAC3BD,EAAe5H,KAAK8H,0BAGtB,MAAMf,EAAa/G,KAAK+H,uBACxB,OAAO/H,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,2BACNV,cACAnE,OACA+J,OACAE,eACAb,cAEJ,CAMAV,+BACE,MAAM9F,EAAQP,KAAKoF,OAAOhD,MACpBN,EAAc9B,KAAKgK,mBACzBhK,KAAKkJ,cAAc,aACnB,MAAMvL,EAAOqC,KAAKuF,YACZ4E,EAAanK,KAAKoK,4BAClBrD,EAAa/G,KAAK+H,uBAClB6B,EAAS5J,KAAKqK,wBACpB,OAAOrK,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,8BACNV,cACAnE,OACAwM,aACApD,aACA6C,UAEJ,CAMAtD,2BACE,MAAM/F,EAAQP,KAAKoF,OAAOhD,MACpBN,EAAc9B,KAAKgK,mBACzBhK,KAAKkJ,cAAc,SACnB,MAAMvL,EAAOqC,KAAKuF,YACZwB,EAAa/G,KAAK+H,uBAClB2C,EAAQ1K,KAAK2K,wBACnB,OAAO3K,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,0BACNV,cACAnE,OACAoJ,aACA2D,SAEJ,CAOAC,wBACE,OAAO3K,KAAK6H,oBAAoB,UAC5B7H,KAAKsK,cAAc,OAAgBtK,KAAKiJ,gBACxC,EACN,CAMA1C,0BACE,MAAMhG,EAAQP,KAAKoF,OAAOhD,MACpBN,EAAc9B,KAAKgK,mBACzBhK,KAAKkJ,cAAc,QACnB,MAAMvL,EAAOqC,KAAKuF,YACZwB,EAAa/G,KAAK+H,uBAClB2B,EAAS1J,KAAK4K,4BACpB,OAAO5K,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,yBACNV,cACAnE,OACAoJ,aACA2C,UAEJ,CAOAkB,4BACE,OAAO5K,KAAKsH,aACV,UACAtH,KAAK6K,yBACL,UAEJ,CAKAA,2BACE,MAAMtK,EAAQP,KAAKoF,OAAOhD,MACpBN,EAAc9B,KAAKgK,mBACnBrM,EAAOqC,KAAK8K,qBACZ/D,EAAa/G,KAAK+H,uBACxB,OAAO/H,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,0BACNV,cACAnE,OACAoJ,cAEJ,CAKA+D,qBACE,GAC8B,SAA5B9K,KAAKoF,OAAOhD,MAAMzB,OACU,UAA5BX,KAAKoF,OAAOhD,MAAMzB,OACU,SAA5BX,KAAKoF,OAAOhD,MAAMzB,MAElB,MAAMkB,EACJ7B,KAAKoF,OAAO9I,OACZ0D,KAAKoF,OAAOhD,MAAM7B,MAClB,GAAGwK,EACD/K,KAAKoF,OAAOhD,4DAKlB,OAAOpC,KAAKuF,WACd,CAMAiB,iCACE,MAAMjG,EAAQP,KAAKoF,OAAOhD,MACpBN,EAAc9B,KAAKgK,mBACzBhK,KAAKkJ,cAAc,SACnB,MAAMvL,EAAOqC,KAAKuF,YACZwB,EAAa/G,KAAK+H,uBAClB6B,EAAS5J,KAAKgL,6BACpB,OAAOhL,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,iCACNV,cACAnE,OACAoJ,aACA6C,UAEJ,CAOAoB,6BACE,OAAOhL,KAAKsH,aACV,UACAtH,KAAKyK,mBACL,UAEJ,CAeA9D,2BACE,MAAMV,EAAejG,KAAKoF,OAAO7C,YAEjC,GAAI0D,EAAazD,OAAS,OACxB,OAAQyD,EAAatF,OACnB,IAAK,SACH,OAAOX,KAAKiL,uBAEd,IAAK,SACH,OAAOjL,KAAKkL,2BAEd,IAAK,OACH,OAAOlL,KAAKmL,2BAEd,IAAK,YACH,OAAOnL,KAAKoL,8BAEd,IAAK,QACH,OAAOpL,KAAKqL,0BAEd,IAAK,OACH,OAAOrL,KAAKsL,yBAEd,IAAK,QACH,OAAOtL,KAAKuL,gCAIlB,MAAMvL,KAAK4G,WAAWX,EACxB,CASAgF,uBACE,MAAM1K,EAAQP,KAAKoF,OAAOhD,MAC1BpC,KAAKkJ,cAAc,UACnBlJ,KAAKkJ,cAAc,UACnB,MAAMnC,EAAa/G,KAAK+H,uBAClBkC,EAAiBjK,KAAKsH,aAC1B,UACAtH,KAAKkK,6BACL,WAGF,GAA0B,IAAtBnD,EAAWjK,QAA0C,IAA1BmN,EAAenN,OAC5C,MAAMkD,KAAK4G,aAGb,OAAO5G,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,qBACNuE,aACAkD,kBAEJ,CAMAiB,2BACE,MAAM3K,EAAQP,KAAKoF,OAAOhD,MAC1BpC,KAAKkJ,cAAc,UACnBlJ,KAAKkJ,cAAc,UACnB,MAAMvL,EAAOqC,KAAKuF,YACZwB,EAAa/G,KAAK+H,uBAExB,GAA0B,IAAtBhB,EAAWjK,OACb,MAAMkD,KAAK4G,aAGb,OAAO5G,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,0BACN7E,OACAoJ,cAEJ,CAQAoE,2BACE,MAAM5K,EAAQP,KAAKoF,OAAOhD,MAC1BpC,KAAKkJ,cAAc,UACnBlJ,KAAKkJ,cAAc,QACnB,MAAMvL,EAAOqC,KAAKuF,YACZ4E,EAAanK,KAAKoK,4BAClBrD,EAAa/G,KAAK+H,uBAClB6B,EAAS5J,KAAKqK,wBAEpB,GACwB,IAAtBF,EAAWrN,QACW,IAAtBiK,EAAWjK,QACO,IAAlB8M,EAAO9M,OAEP,MAAMkD,KAAK4G,aAGb,OAAO5G,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,0BACN7E,OACAwM,aACApD,aACA6C,UAEJ,CAQAwB,8BACE,MAAM7K,EAAQP,KAAKoF,OAAOhD,MAC1BpC,KAAKkJ,cAAc,UACnBlJ,KAAKkJ,cAAc,aACnB,MAAMvL,EAAOqC,KAAKuF,YACZ4E,EAAanK,KAAKoK,4BAClBrD,EAAa/G,KAAK+H,uBAClB6B,EAAS5J,KAAKqK,wBAEpB,GACwB,IAAtBF,EAAWrN,QACW,IAAtBiK,EAAWjK,QACO,IAAlB8M,EAAO9M,OAEP,MAAMkD,KAAK4G,aAGb,OAAO5G,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,6BACN7E,OACAwM,aACApD,aACA6C,UAEJ,CAOAyB,0BACE,MAAM9K,EAAQP,KAAKoF,OAAOhD,MAC1BpC,KAAKkJ,cAAc,UACnBlJ,KAAKkJ,cAAc,SACnB,MAAMvL,EAAOqC,KAAKuF,YACZwB,EAAa/G,KAAK+H,uBAClB2C,EAAQ1K,KAAK2K,wBAEnB,GAA0B,IAAtB5D,EAAWjK,QAAiC,IAAjB4N,EAAM5N,OACnC,MAAMkD,KAAK4G,aAGb,OAAO5G,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,yBACN7E,OACAoJ,aACA2D,SAEJ,CAOAY,yBACE,MAAM/K,EAAQP,KAAKoF,OAAOhD,MAC1BpC,KAAKkJ,cAAc,UACnBlJ,KAAKkJ,cAAc,QACnB,MAAMvL,EAAOqC,KAAKuF,YACZwB,EAAa/G,KAAK+H,uBAClB2B,EAAS1J,KAAK4K,4BAEpB,GAA0B,IAAtB7D,EAAWjK,QAAkC,IAAlB4M,EAAO5M,OACpC,MAAMkD,KAAK4G,aAGb,OAAO5G,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,wBACN7E,OACAoJ,aACA2C,UAEJ,CAOA6B,gCACE,MAAMhL,EAAQP,KAAKoF,OAAOhD,MAC1BpC,KAAKkJ,cAAc,UACnBlJ,KAAKkJ,cAAc,SACnB,MAAMvL,EAAOqC,KAAKuF,YACZwB,EAAa/G,KAAK+H,uBAClB6B,EAAS5J,KAAKgL,6BAEpB,GAA0B,IAAtBjE,EAAWjK,QAAkC,IAAlB8M,EAAO9M,OACpC,MAAMkD,KAAK4G,aAGb,OAAO5G,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,gCACN7E,OACAoJ,aACA6C,UAEJ,CAQAnD,2BACE,MAAMlG,EAAQP,KAAKoF,OAAOhD,MACpBN,EAAc9B,KAAKgK,mBACzBhK,KAAKkJ,cAAc,aACnBlJ,KAAKwF,YAAY,MACjB,MAAM7H,EAAOqC,KAAKuF,YACZ3F,EAAOI,KAAKwK,oBACZgB,EAAaxL,KAAK8I,sBAAsB,cAC9C9I,KAAKkJ,cAAc,MACnB,MAAM1I,EAAYR,KAAKyL,0BACvB,OAAOzL,KAAKK,KAAKE,EAAO,CACtBiC,KAAM,yBACNV,cACAnE,OACA2K,UAAW1I,EACX4L,aACAhL,aAEJ,CAOAiL,0BACE,OAAOzL,KAAKsK,cAAc,OAAgBtK,KAAK0L,uBACjD,CA6BAA,yBACE,MAAMnL,EAAQP,KAAKoF,OAAOhD,MACpBzE,EAAOqC,KAAKuF,YAElB,GAAI3E,OAAO+K,UAAUC,eAAeC,KAAK9J,EAAmBpE,EAAKgD,OAC/D,OAAOhD,EAGT,MAAMqC,KAAK4G,WAAWrG,EACxB,CAQAF,KAAKyL,EAAYzL,GASf,OARiC,IAA7BL,KAAKqF,SAAS0G,aAChB1L,EAAKC,IAAM,IAAI,KACbwL,EACA9L,KAAKoF,OAAOjD,UACZnC,KAAKoF,OAAO9I,SAIT+D,CACT,CAKAwF,KAAKrD,GACH,OAAOxC,KAAKoF,OAAOhD,MAAMI,OAASA,CACpC,CAMAgD,YAAYhD,GACV,MAAMJ,EAAQpC,KAAKoF,OAAOhD,MAE1B,GAAIA,EAAMI,OAASA,EAEjB,OADAxC,KAAKsJ,eACElH,EAGT,MAAMP,EACJ7B,KAAKoF,OAAO9I,OACZ8F,EAAM7B,MACN,YAAYyL,EAAiBxJ,aAAgBuI,EAAa3I,MAE9D,CAMAyF,oBAAoBrF,GAGlB,OAFcxC,KAAKoF,OAAOhD,MAEhBI,OAASA,IACjBxC,KAAKsJ,gBACE,EAIX,CAMAJ,cAAcvI,GACZ,MAAMyB,EAAQpC,KAAKoF,OAAOhD,MAE1B,GAAIA,EAAMI,OAAS,QAAkBJ,EAAMzB,QAAUA,EAGnD,MAAMkB,EACJ7B,KAAKoF,OAAO9I,OACZ8F,EAAM7B,MACN,aAAaI,aAAiBoK,EAAa3I,OAL7CpC,KAAKsJ,cAQT,CAMAR,sBAAsBnI,GACpB,MAAMyB,EAAQpC,KAAKoF,OAAOhD,MAE1B,OAAIA,EAAMI,OAAS,QAAkBJ,EAAMzB,QAAUA,IACnDX,KAAKsJ,gBACE,EAIX,CAKA1C,WAAWqF,GACT,MAAM7J,EACJ6J,QAAyCA,EAAUjM,KAAKoF,OAAOhD,MACjE,OAAOP,EACL7B,KAAKoF,OAAO9I,OACZ8F,EAAM7B,MACN,cAAcwK,EAAa3I,MAE/B,CAOAuH,IAAIuC,EAAUC,EAASC,GACrBpM,KAAKwF,YAAY0G,GACjB,MAAM3M,EAAQ,GAEd,MAAQS,KAAK6H,oBAAoBuE,IAC/B7M,EAAMlB,KAAK8N,EAAQN,KAAK7L,OAG1B,OAAOT,CACT,CAQA+H,aAAa4E,EAAUC,EAASC,GAC9B,GAAIpM,KAAK6H,oBAAoBqE,GAAW,CACtC,MAAM3M,EAAQ,GAEd,GACEA,EAAMlB,KAAK8N,EAAQN,KAAK7L,cAChBA,KAAK6H,oBAAoBuE,IAEnC,OAAO7M,CACT,CAEA,MAAO,EACT,CAOAoG,KAAKuG,EAAUC,EAASC,GACtBpM,KAAKwF,YAAY0G,GACjB,MAAM3M,EAAQ,GAEd,GACEA,EAAMlB,KAAK8N,EAAQN,KAAK7L,cAChBA,KAAK6H,oBAAoBuE,IAEnC,OAAO7M,CACT,CAOA+K,cAAc+B,EAAeF,GAC3BnM,KAAK6H,oBAAoBwE,GACzB,MAAM9M,EAAQ,GAEd,GACEA,EAAMlB,KAAK8N,EAAQN,KAAK7L,aACjBA,KAAK6H,oBAAoBwE,IAElC,OAAO9M,CACT,CAEA+J,eACE,MAAM,UAAEgD,GAActM,KAAKqF,SAErBjD,EAAQpC,KAAKoF,OAAO9C,UAE1B,QAAkBzD,IAAdyN,GAA2BlK,EAAMI,OAAS,UAC1CxC,KAAKsF,cAEHtF,KAAKsF,cAAgBgH,GACvB,MAAMzK,EACJ7B,KAAKoF,OAAO9I,OACZ8F,EAAM7B,MACN,+BAA+B+L,6BAIvC,EAMF,SAASvB,EAAa3I,GACpB,MAAMzB,EAAQyB,EAAMzB,MACpB,OAAOqL,EAAiB5J,EAAMI,OAAkB,MAAT7B,EAAgB,KAAKA,KAAW,GACzE,CAKA,SAASqL,EAAiBxJ,GACxB,ODh6CK,SAA+BA,GACpC,OACEA,IAAS,QACTA,IAAS,UACTA,IAAS,OACTA,IAAS,WACTA,IAAS,WACTA,IAAS,UACTA,IAAS,SACTA,IAAS,UACTA,IAAS,MACTA,IAAS,aACTA,IAAS,aACTA,IAAS,WACTA,IAAS,QACTA,IAAS,SAEb,CC+4CS+J,CAAsB/J,GAAQ,IAAIA,KAAUA,CACrD,CCj/CA,IAAIgK,EAAW,IAAIC,IACfC,EAAoB,IAAID,IACxBE,GAAwB,EACxBC,GAAgC,EACpC,SAASC,EAAUC,GACf,OAAOA,EAAOC,QAAQ,UAAW,KAAKC,MAC1C,CAIA,SAASC,EAAiBC,GACtB,IAAIC,EAAW,IAAIC,IACf1H,EAAc,GA0BlB,OAzBAwH,EAAIxH,YAAY2H,SAAQ,SAAUC,GAC9B,GAAgC,uBAA5BA,EAAmB9K,KAA+B,CAClD,IAAI+K,EAAeD,EAAmB3P,KAAKgD,MACvC6M,EARLX,GADcvM,EASmBgN,EAAmBhN,KARtChE,OAAOK,KAAK8Q,UAAUnN,EAAIC,MAAOD,EAAIsC,MAS9C8K,EAAehB,EAAkBiB,IAAIJ,GACrCG,IAAiBA,EAAaE,IAAIJ,GAC9Bb,GACAkB,QAAQC,KAAK,+BAAiCP,EAAjC,iMAKXG,GACNhB,EAAkBqB,IAAIR,EAAcG,EAAe,IAAIN,KAE3DM,EAAaM,IAAIR,GACZL,EAASS,IAAIJ,KACdL,EAASa,IAAIR,GACb9H,EAAYrH,KAAKiP,GAEzB,MAEI5H,EAAYrH,KAAKiP,GA5B7B,IAAyBhN,CA8BrB,KACO,IAAA2N,WAAS,IAAAA,UAAS,CAAC,EAAGf,GAAM,CAAExH,YAAaA,GACtD,CAoBA,SAASD,EAAcnJ,GACnB,IAAI4R,EAAWrB,EAAUvQ,GACzB,IAAKkQ,EAASoB,IAAIM,GAAW,CACzB,IAAIC,EDjDL,SAAe7R,EAAQ4I,GAE5B,OADe,IAAID,EAAO3I,EAAQ4I,GACpBO,eAChB,CC8CqB2I,CAAM9R,EAAQ,CACvBsQ,8BAA+BA,EAC/BzD,6BAA8ByD,IAElC,IAAKuB,GAA0B,aAAhBA,EAAO3L,KAClB,MAAM,IAAIrG,MAAM,iCAEpBqQ,EAASuB,IAAIG,EA7BrB,SAAkBG,GACd,IAAIC,EAAU,IAAIlB,IAAIiB,EAAI3I,aAC1B4I,EAAQjB,SAAQ,SAAUhN,GAClBA,EAAKC,YACED,EAAKC,IAChBM,OAAOe,KAAKtB,GAAMgN,SAAQ,SAAUkB,GAChC,IAAI5N,EAAQN,EAAKkO,GACb5N,GAA0B,iBAAVA,GAChB2N,EAAQN,IAAIrN,EAEpB,GACJ,IACA,IAAIL,EAAM+N,EAAI/N,IAKd,OAJIA,WACOA,EAAIwL,kBACJxL,EAAIkO,UAERH,CACX,CAW+BI,CAASxB,EAAiBkB,IACrD,CACA,OAAO3B,EAASmB,IAAIO,EACxB,CACO,SAASQ,EAAIC,GAEhB,IADA,IAAI/O,EAAO,GACFgP,EAAK,EAAGA,EAAKtG,UAAUxL,OAAQ8R,IACpChP,EAAKgP,EAAK,GAAKtG,UAAUsG,GAEL,iBAAbD,IACPA,EAAW,CAACA,IAEhB,IAAIE,EAASF,EAAS,GAUtB,OATA/O,EAAKyN,SAAQ,SAAUyB,EAAK1Q,GACpB0Q,GAAoB,aAAbA,EAAItM,KACXqM,GAAUC,EAAIxO,IAAIhE,OAAOK,KAGzBkS,GAAUC,EAEdD,GAAUF,EAASvQ,EAAI,EAC3B,IACOqH,EAAcoJ,EACzB,CAcA,IAOWE,EAPPC,EACKN,EADLM,EAbG,WACHxC,EAASyC,QACTvC,EAAkBuC,OACtB,EAUID,EATG,WACHrC,GAAwB,CAC5B,EAOIqC,EANG,WACHpC,GAAgC,CACpC,EAIIoC,GAHG,WACHpC,GAAgC,CACpC,GAQWmC,EAERL,IAAQA,EAAM,CAAC,IADRA,IAAMM,EAAYD,EAAMG,YAAcF,EAAoBD,EAAMI,wBAA0BH,EAAgCD,EAAMK,oCAAsCJ,EAA4CD,EAAMM,qCAAuCL,GAEzQN,EAAa,QAAIA,C,4DCrHNY,E,6EACX,SAAWA,GACPA,EAAaA,EAAoB,MAAI,GAAK,QAC1CA,EAAaA,EAAuB,SAAI,GAAK,WAC7CA,EAAaA,EAA2B,aAAI,GAAK,cACpD,CAJD,CAIGA,IAAiBA,EAAe,CAAC,IACpC,IAAIC,EAAQ,IAAI9C,IACT,SAAS+C,EAAc9H,GAC1B,IAAI/J,EACJ,OAAQ+J,GACJ,KAAK4H,EAAaG,MACd9R,EAAO,QACP,MACJ,KAAK2R,EAAaI,SACd/R,EAAO,WACP,MACJ,KAAK2R,EAAaK,aACdhS,EAAO,eAGf,OAAOA,CACX,CAkDO,SAASiS,EAAmBC,EAAUnI,GACzC,IAAIb,EAlDD,SAAgBgJ,GACnB,IAGIC,EAAWpI,EAHXqI,EAASR,EAAM5B,IAAIkC,GACvB,GAAIE,EACA,OAAOA,EAEXC,SAAU,UAAYH,KAAcA,EAASrN,KAAM,eAAeyN,OAAOJ,EAAU,8CAAhC,gHAEA,UAAYA,KAAcA,EAASrN,KAAM,IAC5F,IAAI0N,EAAYL,EAASnK,YAAY/G,QAAO,SAAUwR,GAAK,MAAkB,uBAAXA,EAAE3N,IAA+B,IAC/F4N,EAAUP,EAASnK,YAAY/G,QAAO,SAAUwR,GAChD,MAAkB,wBAAXA,EAAE3N,MAAkD,UAAhB2N,EAAEtJ,SACjD,IACIwJ,EAAYR,EAASnK,YAAY/G,QAAO,SAAUwR,GAClD,MAAkB,wBAAXA,EAAE3N,MAAkD,aAAhB2N,EAAEtJ,SACjD,IACIyJ,EAAgBT,EAASnK,YAAY/G,QAAO,SAAUwR,GACtD,MAAkB,wBAAXA,EAAE3N,MAAkD,iBAAhB2N,EAAEtJ,SACjD,IACAmJ,SAAU,SAAWE,EAAUpT,QAC1BsT,EAAQtT,QAAUuT,EAAUvT,QAAUwT,EAAcxT,OAAS,0HACE,SAAWoT,EAAUpT,QACpFsT,EAAQtT,QAAUuT,EAAUvT,QAAUwT,EAAcxT,OAAS,IAClEkT,SAAU,QAAUI,EAAQtT,OAASuT,EAAUvT,OAASwT,EAAcxT,QAAU,EAAG,4EAC/E,GAAGmT,OAAOJ,EAAU,SAASI,OAAOG,EAAQtT,OAAQ,cAAcmT,OAAOK,EAAcxT,OAAQ,KAC/F,qBAAqBmT,OAAOI,EAAUvT,OAAQ,gBAC9C,0EAA2E,QAAUsT,EAAQtT,OAASuT,EAAUvT,OAASwT,EAAcxT,QAAU,EAAG,IACxJ4K,EAAO0I,EAAQtT,OAASwS,EAAaG,MAAQH,EAAaI,SACrDU,EAAQtT,QAAWuT,EAAUvT,SAC9B4K,EAAO4H,EAAaK,cACxB,IAAIjK,EAAc0K,EAAQtT,OACpBsT,EACAC,EAAUvT,OACNuT,EACAC,EACVN,SAAU,QAAiC,IAAvBtK,EAAY5I,OAAc,sDAAsDmT,OAAOJ,EAAU,SACjH,GAAGI,OAAOvK,EAAY5I,OAAQ,kBAC9B,0EAA2E,QAAiC,IAAvB4I,EAAY5I,OAAc,IACnH,IAAIyT,EAAa7K,EAAY,GAC7BoK,EAAYS,EAAWzJ,qBAAuB,GAO9C,IAAI0J,EAAU,CAAE7S,KANZ4S,EAAW5S,MAAiC,SAAzB4S,EAAW5S,KAAK6E,KAC5B+N,EAAW5S,KAAKgD,MAGhB,OAEiB+G,KAAMA,EAAMoI,UAAWA,GAEnD,OADAP,EAAMxB,IAAI8B,EAAUW,GACbA,CACX,CAEoBC,CAAOZ,GACnBa,EAAwBlB,EAAc9H,GACtCiJ,EAAoBnB,EAAc3I,EAAUa,MAChDsI,SAAU,QAAUnJ,EAAUa,OAASA,EAAM,aAAauI,OAAOS,EAAuB,wBACpF,GAAGT,OAAOS,EAAuB,YAAYT,OAAOU,EAAmB,wBAAyB,QAAU9J,EAAUa,OAASA,EAAM,GAC3I,CCtEO,SAASkJ,EAASC,EAAO3L,GAC5B,IAAI4L,EACAC,GAAU,IAAAC,aAAW,UACrBC,ECRD,SAAyBC,GAC5B,IAAIH,GAAU,IAAAC,aAAW,UACrBC,EAASC,GAAYH,EAAQE,OAIjC,OAHAjB,SAAU,UAAYiB,EAAQ,mLAEiB,UAAYA,EAAQ,IAC5DA,CACX,CDCiBE,CAAgBjM,aAAyC,EAASA,EAAQ+L,QACvFrB,EAAmBiB,EAAOvB,EAAaG,OACvC,IAgJI2B,EAhJAC,GAAK,IAAA9X,WAAS,WACd,IAAI+X,EAAoBC,EAAwBV,EAAO3L,GACnDsM,EAAW,KAmCf,OAlCIT,EAAQU,iBACRD,EAAWT,EAAQU,eAAeC,iBAAiBJ,IAElDE,IACDA,EAAWP,EAAOU,WAAWL,GACzBP,EAAQU,gBACRV,EAAQU,eAAeG,sBAAsBJ,EAAUF,IAG3DP,EAAQU,iBAC4D,KAAnEvM,aAAyC,EAASA,EAAQ2M,QACzD3M,aAAyC,EAASA,EAAQ4M,OAC5DN,EAASO,mBAAmBC,SAC5BjB,EAAQU,eAAeQ,gBAAgB,CACnCC,WAAY,WAAc,OAAOX,EAAwBV,EAAO3L,EAAU,EAC1EiN,UAAW,WAAc,OAAO,IAAIC,SAAQ,SAAUC,GAClD,IAAIC,EAAMd,EAASe,UAAU,CACzB9P,KAAM,SAAUoM,GACPA,EAAOmD,UACRK,IACAC,EAAIE,cAEZ,EACAC,MAAO,WACHJ,IACAC,EAAIE,aACR,EACAE,SAAU,WACNL,GACJ,GAER,GAAI,IACL,WAAc,OAAO,IAAM,IAE3Bb,CACX,IAAIA,EAAWH,EAAG,GAAIsB,EAActB,EAAG,GACnCuB,GAAK,IAAArZ,WAAS,WACd,IAAIuX,EAAIO,EACJxC,EAAS2C,EAASO,mBAStB,OARKlD,EAAOmD,SAAW9M,IACf2J,EAAO4D,MACoB,QAA1B3B,EAAK5L,EAAQ2N,eAA4B,IAAP/B,GAAyBA,EAAGjF,KAAK3G,EAAS2J,EAAO4D,OAE/E5D,EAAOiE,OACmB,QAA9BzB,EAAKnM,EAAQ6N,mBAAgC,IAAP1B,GAAyBA,EAAGxF,KAAK3G,EAAS2J,EAAOiE,QAGzFjE,CACX,IAAIA,EAAS+D,EAAG,GAAII,EAAYJ,EAAG,GAC/BK,GAAM,IAAAC,QAAO,CACbjC,OAAQA,EACRJ,MAAOA,EACP3L,QAASA,EACT2J,OAAQA,EACRsE,kBAAc,EACd7B,kBAAmBC,EAAwBV,EAAO3L,MAEtD,IAAAkO,YAAU,WACN,IAAItC,EAAIO,EAEJgC,EADA/B,EAAoBC,EAAwBV,EAAO3L,GAEvD,GAAI+N,EAAIK,QAAQrC,SAAWA,IAAW,OAAMgC,EAAIK,QAAQzC,MAAOA,IAKrD,OAAMoC,EAAIK,QAAQhC,kBAAmBA,KAC3CE,EAAS+B,WAAWjC,GAAmBkC,OAAM,WAAc,IAC3DH,EAAa7B,EAASO,mBACtBkB,EAAIK,QAAQhC,kBAAoBA,OARmC,CACnE,IAAImC,EAAaxC,EAAOU,WAAWL,GACnCqB,EAAYc,GACZJ,EAAaI,EAAW1B,kBAC5B,CAMA,GAAIsB,EAAY,CACZ,IAAIK,EAAiBT,EAAIK,QAAQzE,OAC7B6E,EAAeZ,OACfG,EAAIK,QAAQH,aAAeO,EAAeZ,MAE9CE,EAAUC,EAAIK,QAAQzE,OAASwE,IAC1BA,EAAWrB,SAAW9M,IAClB2J,EAAOmD,UACJnD,EAAO4D,MACoB,QAA1B3B,EAAK5L,EAAQ2N,eAA4B,IAAP/B,GAAyBA,EAAGjF,KAAK3G,EAAS2J,EAAO4D,OAE/E5D,EAAOiE,OACmB,QAA9BzB,EAAKnM,EAAQ6N,mBAAgC,IAAP1B,GAAyBA,EAAGxF,KAAK3G,EAAS2J,EAAOiE,QAIxG,CACAlS,OAAO+S,OAAOV,EAAIK,QAAS,CAAErC,OAAQA,EAAQJ,MAAOA,GACxD,GAAG,CAACW,EAAUP,EAAQJ,EAAO3L,KAC7B,IAAAkO,YAAU,WACN,IAAIrC,EAAQU,eAAZ,CAGA,IAAImC,EAAepC,EAASe,UAAUsB,GAmBtC,SAAShB,EAAQJ,GACb,IAAI3B,EAAIO,EACJyC,EAAOtC,EAAe,KAC1BoC,EAAapB,cACb,IACIhB,EAASuC,mBACTH,EAAepC,EAASe,UAAUsB,EAAQhB,EAI9C,CAFA,QACIrB,EAAe,KAAIsC,CACvB,CACA,IAAKrB,EAAM7G,eAAe,iBACtB,MAAM6G,EAEV,IAAIiB,EAAiBT,EAAIK,QAAQzE,QAC5B6E,GAAkBA,EAAe1B,WACjC,OAAMS,EAAOiB,EAAejB,UAC7BO,EAAUC,EAAIK,QAAQzE,OAAS,CAC3BiE,KAAMY,EAAeZ,KACrBL,MAAOA,EACPT,SAAS,EACTgC,cAAe,YAEmE,QAArF3C,EAAoC,QAA9BP,EAAKmC,EAAIK,QAAQpO,eAA4B,IAAP4L,OAAgB,EAASA,EAAG+B,eAA4B,IAAPxB,GAAyBA,EAAGxF,KAAKiF,EAAI2B,GAE3I,IACA,OAAO,WAAc,OAAOmB,EAAapB,aAAe,CA9CxD,CAEA,SAASqB,IACL,IAAI/C,EAAIO,EACJqC,EAAiBT,EAAIK,QAAQzE,OAC7BA,EAAS2C,EAASO,mBAClB2B,GACAA,EAAe1B,UAAYnD,EAAOmD,SAClC0B,EAAeM,gBAAkBnF,EAAOmF,gBACxC,OAAMN,EAAeZ,KAAMjE,EAAOiE,QAGlCY,EAAeZ,OACfG,EAAIK,QAAQH,aAAeO,EAAeZ,MAE9CE,EAAUC,EAAIK,QAAQzE,OAASA,GAC1BA,EAAOmD,SACkF,QAAzFX,EAAoC,QAA9BP,EAAKmC,EAAIK,QAAQpO,eAA4B,IAAP4L,OAAgB,EAASA,EAAGiC,mBAAgC,IAAP1B,GAAyBA,EAAGxF,KAAKiF,EAAIjC,EAAOiE,MAEtJ,CA4BJ,GAAG,CAACtB,EAAUT,EAAQU,eAAgBR,EAAOgD,wBAE/B7C,GAAbN,EAAKjC,GAAqBuC,QAASvC,GAAS,IAAAqF,QAAOpD,EAAI,CAAC,aAEjDM,KACClM,aAAyC,EAASA,EAAQiP,iBAC1DtF,EAAOmD,SACNnD,EAAOiE,MAA4C,IAApClS,OAAOe,KAAKkN,EAAOiE,MAAMhW,QACT,eAAjC0U,EAAStM,QAAQkP,cACjBvF,GAAS,IAAAZ,WAAS,IAAAA,UAAS,CAAC,EAAGY,GAAS,CAAEmD,SAAS,EAAMgC,cAAe,cACxExC,EAAS6C,WAETtD,EAAQU,iBAC4D,KAAnEvM,aAAyC,EAASA,EAAQ2M,QACzD3M,aAAyC,EAASA,EAAQ4M,OAC5DjD,EAAOmD,SACPR,EAAS+B,WAAWhC,EAAwBV,EAAO3L,IAAUsO,OAAM,WAAc,IAErF5S,OAAO+S,OAAOV,EAAIK,QAAS,CAAEpO,QAASA,KAErC6L,EAAQU,gBAAkBR,EAAOgD,yBACkC,KAAnE/O,aAAyC,EAASA,EAAQ2M,KAC3DhD,EAASoE,EAAIK,QAAQzE,OAAS,CAC1BmD,SAAS,EACTc,UAAM,EACNL,WAAO,EACPuB,cAAe,eAGb9O,aAAyC,EAASA,EAAQ4M,OAAqF,aAA3E5M,aAAyC,EAASA,EAAQkP,gBACpIvF,EAAS,CACLmD,SAAS,EACTc,UAAM,EACNL,WAAO,EACPuB,cAAe,YAGnBnF,EAAOyF,QAAUzF,EAAOyF,OAAOxX,SAC/B+R,GAAS,IAAAZ,WAAS,IAAAA,UAAS,CAAC,EAAGY,GAAS,CAAE4D,MAAO5D,EAAO4D,OAAS,IAAI,IAAY,CAAE8B,cAAe1F,EAAOyF,YAE7G,IAAIE,GAAiB,IAAAC,UAAQ,WAAc,MAAO,CAC9CJ,QAAS7C,EAAS6C,QAAQK,KAAKlD,GAC/BmD,UAAWnD,EAASmD,UAAUD,KAAKlD,GACnCoD,YAAapD,EAASoD,YAAYF,KAAKlD,GACvCqD,aAAcrD,EAASqD,aAAaH,KAAKlD,GACzCsD,YAAatD,EAASsD,YAAYJ,KAAKlD,GACvCuD,gBAAiBvD,EAASuD,gBAAgBL,KAAKlD,GAC/C,GAAG,CAACA,IACR,OAAO,IAAAvD,WAAS,IAAAA,WAAS,IAAAA,UAAS,CAAC,EAAGuG,GAAiB,CAAE1E,UAAWyB,EAAwBV,EAAO3L,GAAS4K,UAAWmB,OAAQA,EAAQ+D,QAAQ,EAAM7B,aAAcF,EAAIK,QAAQH,eAAiBtE,EACpM,CACA,SAAS0C,EAAwBV,EAAO3L,GACpC,IAAI4L,OACY,IAAZ5L,IAAsBA,EAAU,CAAC,GACrC,IAAI4M,EAAO5M,EAAQ4M,KAA0HR,GAA9GpM,EAAQ2M,IAAmB3M,EAAQ6N,YAAuB7N,EAAQ2N,QAAuB3N,EAAQ+P,aAAiC,IAAAf,QAAOhP,EAAS,CAAC,OAAQ,MAAO,cAAe,UAAW,iBAe3N,OAdI4M,EACAR,EAAkB8C,YAAc,aAEW,QAApCtD,EAAKQ,EAAkBP,eAA4B,IAAPD,OAAgB,EAASA,EAAGW,iBAC5C,iBAAlCH,EAAkB8C,aACmB,sBAAlC9C,EAAkB8C,cAGhB9C,EAAkB8C,cAFxB9C,EAAkB8C,YAAc,eAK/B9C,EAAkBxB,YACnBwB,EAAkBxB,UAAY,CAAC,IAE5B,IAAA7B,UAAS,CAAE4C,MAAOA,GAASS,EACtC,C,wBEjOe,SAAS4D,EAA4BC,EAASC,GAK3D,OAJKA,IACHA,EAAMD,EAAQ7W,MAAM,IAEtB6W,EAAQC,IAAMA,EACPD,CACT,C","sources":["webpack://ethereum-org-website/./src/components/Button/index.tsx","webpack://ethereum-org-website/./src/components/FeedbackCard.tsx","webpack://ethereum-org-website/./node_modules/graphql/jsutils/invariant.mjs","webpack://ethereum-org-website/./node_modules/graphql/language/location.mjs","webpack://ethereum-org-website/./node_modules/graphql/language/printLocation.mjs","webpack://ethereum-org-website/./node_modules/graphql/error/GraphQLError.mjs","webpack://ethereum-org-website/./node_modules/graphql/jsutils/isObjectLike.mjs","webpack://ethereum-org-website/./node_modules/graphql/error/syntaxError.mjs","webpack://ethereum-org-website/./node_modules/graphql/language/directiveLocation.mjs","webpack://ethereum-org-website/./node_modules/graphql/language/tokenKind.mjs","webpack://ethereum-org-website/./node_modules/graphql/language/lexer.mjs","webpack://ethereum-org-website/./node_modules/graphql/language/parser.mjs","webpack://ethereum-org-website/./node_modules/graphql-tag/lib/index.js","webpack://ethereum-org-website/./node_modules/@apollo/client/react/parser/index.js","webpack://ethereum-org-website/./node_modules/@apollo/client/react/hooks/useQuery.js","webpack://ethereum-org-website/./node_modules/@apollo/client/react/hooks/useApolloClient.js","webpack://ethereum-org-website/./node_modules/gatsby/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteralLoose.js"],"sourcesContent":["import React from \"react\"\nimport { Button as ChakraButton, ButtonProps } from \"@chakra-ui/react\"\n\nimport { scrollIntoView } from \"../../utils/scrollIntoView\"\n\nexport interface IProps extends ButtonProps {\n  toId?: string\n}\n\nconst Button: React.FC<IProps> = ({ toId, children, ...props }) => {\n  const handleOnClick = () => {\n    if (!toId) {\n      return\n    }\n\n    scrollIntoView(toId)\n  }\n\n  return (\n    <ChakraButton onClick={handleOnClick} {...props}>\n      {children}\n    </ChakraButton>\n  )\n}\n\nexport default Button\n","// Library imports\nimport React, { ReactNode, useState } from \"react\"\nimport { Flex, FlexProps, Heading } from \"@chakra-ui/react\"\n// Component imports\nimport Button from \"./Button\"\nimport Translation from \"./Translation\"\n// SVG imports\nimport { FeedbackThumbsUpIcon } from \"./icons\"\n// Utility imports\nimport { trackCustomEvent } from \"../utils/matomo\"\n// Hook imports\nimport { useSurvey } from \"../hooks/useSurvey\"\n\nexport interface IProps extends FlexProps {\n  prompt?: string\n  isArticle?: boolean\n}\n\nconst FeedbackCard: React.FC<IProps> = ({\n  prompt,\n  isArticle = false,\n  ...props\n}) => {\n  const [feedbackSubmitted, setFeedbackSubmitted] = useState(false)\n  const surveyUrl = useSurvey(feedbackSubmitted)\n\n  const location = typeof window !== \"undefined\" ? window.location.href : \"\"\n  const isTutorial = location.includes(\"tutorials\")\n\n  const getTitle = (feedbackSubmitted: boolean): ReactNode => {\n    if (!feedbackSubmitted) {\n      if (prompt) return prompt\n      if (isTutorial) return <Translation id=\"feedback-card-prompt-tutorial\" />\n      if (isArticle) return <Translation id=\"feedback-card-prompt-article\" />\n      return <Translation id=\"feedback-card-prompt-page\" />\n    }\n    return <Translation id=\"feedback-widget-thank-you-title\" />\n  }\n\n  const handleSubmit = (choice: boolean): void => {\n    trackCustomEvent({\n      eventCategory: `Page is helpful feedback`,\n      eventAction: `Clicked`,\n      eventName: String(choice),\n    })\n    setFeedbackSubmitted(true)\n  }\n  const handleSurveyOpen = (): void => {\n    trackCustomEvent({\n      eventCategory: `Feedback survey opened`,\n      eventAction: `Clicked`,\n      eventName: \"Feedback survey opened\",\n    })\n    window && surveyUrl && window.open(surveyUrl, \"_blank\")\n  }\n  return (\n    <Flex\n      border=\"1px\"\n      borderColor=\"border\"\n      bg=\"feedbackGradient\"\n      borderRadius=\"base\"\n      p={6}\n      direction=\"column\"\n      mb={4}\n      mt={8}\n      w=\"full\"\n      {...props}\n    >\n      <Flex direction=\"column\" gap={4}>\n        <Heading as=\"h3\" m={0} mb={2} fontSize=\"1.375rem\" fontWeight=\"bold\">\n          {getTitle(feedbackSubmitted)}\n        </Heading>\n        {feedbackSubmitted && (\n          <p>\n            <Translation id=\"feedback-widget-thank-you-subtitle\" />{\" \"}\n            <Translation id=\"feedback-widget-thank-you-subtitle-ext\" />\n          </p>\n        )}\n        <Flex gap={4}>\n          {!feedbackSubmitted ? (\n            <>\n              <Button\n                variant=\"outline-color\"\n                leftIcon={<FeedbackThumbsUpIcon />}\n                onClick={() => handleSubmit(true)}\n              >\n                <Translation id=\"yes\" />\n              </Button>\n              <Button\n                variant=\"outline-color\"\n                leftIcon={<FeedbackThumbsUpIcon transform=\"scaleY(-1)\" />}\n                onClick={() => handleSubmit(false)}\n              >\n                <Translation id=\"no\" />\n              </Button>\n            </>\n          ) : (\n            <Button variant=\"outline-color\" onClick={handleSurveyOpen}>\n              <Translation id=\"feedback-widget-thank-you-cta\" />\n            </Button>\n          )}\n        </Flex>\n      </Flex>\n    </Flex>\n  )\n}\n\nexport default FeedbackCard\n","export function invariant(condition, message) {\n  const booleanCondition = Boolean(condition);\n\n  if (!booleanCondition) {\n    throw new Error(\n      message != null ? message : 'Unexpected invariant triggered.',\n    );\n  }\n}\n","import { invariant } from '../jsutils/invariant.mjs';\nconst LineRegExp = /\\r\\n|[\\n\\r]/g;\n/**\n * Represents a location in a Source.\n */\n\n/**\n * Takes a Source and a UTF-8 character offset, and returns the corresponding\n * line and column as a SourceLocation.\n */\nexport function getLocation(source, position) {\n  let lastLineStart = 0;\n  let line = 1;\n\n  for (const match of source.body.matchAll(LineRegExp)) {\n    typeof match.index === 'number' || invariant(false);\n\n    if (match.index >= position) {\n      break;\n    }\n\n    lastLineStart = match.index + match[0].length;\n    line += 1;\n  }\n\n  return {\n    line,\n    column: position + 1 - lastLineStart,\n  };\n}\n","import { getLocation } from './location.mjs';\n\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\nexport function printLocation(location) {\n  return printSourceLocation(\n    location.source,\n    getLocation(location.source, location.start),\n  );\n}\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\nexport function printSourceLocation(source, sourceLocation) {\n  const firstLineColumnOffset = source.locationOffset.column - 1;\n  const body = ''.padStart(firstLineColumnOffset) + source.body;\n  const lineIndex = sourceLocation.line - 1;\n  const lineOffset = source.locationOffset.line - 1;\n  const lineNum = sourceLocation.line + lineOffset;\n  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;\n  const columnNum = sourceLocation.column + columnOffset;\n  const locationStr = `${source.name}:${lineNum}:${columnNum}\\n`;\n  const lines = body.split(/\\r\\n|[\\n\\r]/g);\n  const locationLine = lines[lineIndex]; // Special case for minified documents\n\n  if (locationLine.length > 120) {\n    const subLineIndex = Math.floor(columnNum / 80);\n    const subLineColumnNum = columnNum % 80;\n    const subLines = [];\n\n    for (let i = 0; i < locationLine.length; i += 80) {\n      subLines.push(locationLine.slice(i, i + 80));\n    }\n\n    return (\n      locationStr +\n      printPrefixedLines([\n        [`${lineNum} |`, subLines[0]],\n        ...subLines.slice(1, subLineIndex + 1).map((subLine) => ['|', subLine]),\n        ['|', '^'.padStart(subLineColumnNum)],\n        ['|', subLines[subLineIndex + 1]],\n      ])\n    );\n  }\n\n  return (\n    locationStr +\n    printPrefixedLines([\n      // Lines specified like this: [\"prefix\", \"string\"],\n      [`${lineNum - 1} |`, lines[lineIndex - 1]],\n      [`${lineNum} |`, locationLine],\n      ['|', '^'.padStart(columnNum)],\n      [`${lineNum + 1} |`, lines[lineIndex + 1]],\n    ])\n  );\n}\n\nfunction printPrefixedLines(lines) {\n  const existingLines = lines.filter(([_, line]) => line !== undefined);\n  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));\n  return existingLines\n    .map(([prefix, line]) => prefix.padStart(padLen) + (line ? ' ' + line : ''))\n    .join('\\n');\n}\n","import { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { getLocation } from '../language/location.mjs';\nimport {\n  printLocation,\n  printSourceLocation,\n} from '../language/printLocation.mjs';\n\nfunction toNormalizedOptions(args) {\n  const firstArg = args[0];\n\n  if (firstArg == null || 'kind' in firstArg || 'length' in firstArg) {\n    return {\n      nodes: firstArg,\n      source: args[1],\n      positions: args[2],\n      path: args[3],\n      originalError: args[4],\n      extensions: args[5],\n    };\n  }\n\n  return firstArg;\n}\n/**\n * A GraphQLError describes an Error found during the parse, validate, or\n * execute phases of performing a GraphQL operation. In addition to a message\n * and stack trace, it also includes information about the locations in a\n * GraphQL document and/or execution result that correspond to the Error.\n */\n\nexport class GraphQLError extends Error {\n  /**\n   * An array of `{ line, column }` locations within the source GraphQL document\n   * which correspond to this error.\n   *\n   * Errors during validation often contain multiple locations, for example to\n   * point out two things with the same name. Errors during execution include a\n   * single location, the field which produced the error.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n\n  /**\n   * An array describing the JSON-path into the execution response which\n   * corresponds to this error. Only included for errors during execution.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n\n  /**\n   * An array of GraphQL AST Nodes corresponding to this error.\n   */\n\n  /**\n   * The source GraphQL document for the first location of this error.\n   *\n   * Note that if this Error represents more than one node, the source may not\n   * represent nodes after the first node.\n   */\n\n  /**\n   * An array of character offsets within the source GraphQL document\n   * which correspond to this error.\n   */\n\n  /**\n   * The original error thrown from a field resolver during execution.\n   */\n\n  /**\n   * Extension fields to add to the formatted error.\n   */\n\n  /**\n   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.\n   */\n  constructor(message, ...rawArgs) {\n    var _this$nodes, _nodeLocations$, _ref;\n\n    const { nodes, source, positions, path, originalError, extensions } =\n      toNormalizedOptions(rawArgs);\n    super(message);\n    this.name = 'GraphQLError';\n    this.path = path !== null && path !== void 0 ? path : undefined;\n    this.originalError =\n      originalError !== null && originalError !== void 0\n        ? originalError\n        : undefined; // Compute list of blame nodes.\n\n    this.nodes = undefinedIfEmpty(\n      Array.isArray(nodes) ? nodes : nodes ? [nodes] : undefined,\n    );\n    const nodeLocations = undefinedIfEmpty(\n      (_this$nodes = this.nodes) === null || _this$nodes === void 0\n        ? void 0\n        : _this$nodes.map((node) => node.loc).filter((loc) => loc != null),\n    ); // Compute locations in the source for the given nodes/positions.\n\n    this.source =\n      source !== null && source !== void 0\n        ? source\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : (_nodeLocations$ = nodeLocations[0]) === null ||\n          _nodeLocations$ === void 0\n        ? void 0\n        : _nodeLocations$.source;\n    this.positions =\n      positions !== null && positions !== void 0\n        ? positions\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : nodeLocations.map((loc) => loc.start);\n    this.locations =\n      positions && source\n        ? positions.map((pos) => getLocation(source, pos))\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : nodeLocations.map((loc) => getLocation(loc.source, loc.start));\n    const originalExtensions = isObjectLike(\n      originalError === null || originalError === void 0\n        ? void 0\n        : originalError.extensions,\n    )\n      ? originalError === null || originalError === void 0\n        ? void 0\n        : originalError.extensions\n      : undefined;\n    this.extensions =\n      (_ref =\n        extensions !== null && extensions !== void 0\n          ? extensions\n          : originalExtensions) !== null && _ref !== void 0\n        ? _ref\n        : Object.create(null); // Only properties prescribed by the spec should be enumerable.\n    // Keep the rest as non-enumerable.\n\n    Object.defineProperties(this, {\n      message: {\n        writable: true,\n        enumerable: true,\n      },\n      name: {\n        enumerable: false,\n      },\n      nodes: {\n        enumerable: false,\n      },\n      source: {\n        enumerable: false,\n      },\n      positions: {\n        enumerable: false,\n      },\n      originalError: {\n        enumerable: false,\n      },\n    }); // Include (non-enumerable) stack trace.\n\n    /* c8 ignore start */\n    // FIXME: https://github.com/graphql/graphql-js/issues/2317\n\n    if (\n      originalError !== null &&\n      originalError !== void 0 &&\n      originalError.stack\n    ) {\n      Object.defineProperty(this, 'stack', {\n        value: originalError.stack,\n        writable: true,\n        configurable: true,\n      });\n    } else if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, GraphQLError);\n    } else {\n      Object.defineProperty(this, 'stack', {\n        value: Error().stack,\n        writable: true,\n        configurable: true,\n      });\n    }\n    /* c8 ignore stop */\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLError';\n  }\n\n  toString() {\n    let output = this.message;\n\n    if (this.nodes) {\n      for (const node of this.nodes) {\n        if (node.loc) {\n          output += '\\n\\n' + printLocation(node.loc);\n        }\n      }\n    } else if (this.source && this.locations) {\n      for (const location of this.locations) {\n        output += '\\n\\n' + printSourceLocation(this.source, location);\n      }\n    }\n\n    return output;\n  }\n\n  toJSON() {\n    const formattedError = {\n      message: this.message,\n    };\n\n    if (this.locations != null) {\n      formattedError.locations = this.locations;\n    }\n\n    if (this.path != null) {\n      formattedError.path = this.path;\n    }\n\n    if (this.extensions != null && Object.keys(this.extensions).length > 0) {\n      formattedError.extensions = this.extensions;\n    }\n\n    return formattedError;\n  }\n}\n\nfunction undefinedIfEmpty(array) {\n  return array === undefined || array.length === 0 ? undefined : array;\n}\n/**\n * See: https://spec.graphql.org/draft/#sec-Errors\n */\n\n/**\n * Prints a GraphQLError to a string, representing useful location information\n * about the error's position in the source.\n *\n * @deprecated Please use `error.toString` instead. Will be removed in v17\n */\nexport function printError(error) {\n  return error.toString();\n}\n/**\n * Given a GraphQLError, format it according to the rules described by the\n * Response Format, Errors section of the GraphQL Specification.\n *\n * @deprecated Please use `error.toJSON` instead. Will be removed in v17\n */\n\nexport function formatError(error) {\n  return error.toJSON();\n}\n","/**\n * Return true if `value` is object-like. A value is object-like if it's not\n * `null` and has a `typeof` result of \"object\".\n */\nexport function isObjectLike(value) {\n  return typeof value == 'object' && value !== null;\n}\n","import { GraphQLError } from './GraphQLError.mjs';\n/**\n * Produces a GraphQLError representing a syntax error, containing useful\n * descriptive information about the syntax error's position in the source.\n */\n\nexport function syntaxError(source, position, description) {\n  return new GraphQLError(`Syntax Error: ${description}`, {\n    source,\n    positions: [position],\n  });\n}\n","/**\n * The set of allowed directive location values.\n */\nvar DirectiveLocation;\n\n(function (DirectiveLocation) {\n  DirectiveLocation['QUERY'] = 'QUERY';\n  DirectiveLocation['MUTATION'] = 'MUTATION';\n  DirectiveLocation['SUBSCRIPTION'] = 'SUBSCRIPTION';\n  DirectiveLocation['FIELD'] = 'FIELD';\n  DirectiveLocation['FRAGMENT_DEFINITION'] = 'FRAGMENT_DEFINITION';\n  DirectiveLocation['FRAGMENT_SPREAD'] = 'FRAGMENT_SPREAD';\n  DirectiveLocation['INLINE_FRAGMENT'] = 'INLINE_FRAGMENT';\n  DirectiveLocation['VARIABLE_DEFINITION'] = 'VARIABLE_DEFINITION';\n  DirectiveLocation['SCHEMA'] = 'SCHEMA';\n  DirectiveLocation['SCALAR'] = 'SCALAR';\n  DirectiveLocation['OBJECT'] = 'OBJECT';\n  DirectiveLocation['FIELD_DEFINITION'] = 'FIELD_DEFINITION';\n  DirectiveLocation['ARGUMENT_DEFINITION'] = 'ARGUMENT_DEFINITION';\n  DirectiveLocation['INTERFACE'] = 'INTERFACE';\n  DirectiveLocation['UNION'] = 'UNION';\n  DirectiveLocation['ENUM'] = 'ENUM';\n  DirectiveLocation['ENUM_VALUE'] = 'ENUM_VALUE';\n  DirectiveLocation['INPUT_OBJECT'] = 'INPUT_OBJECT';\n  DirectiveLocation['INPUT_FIELD_DEFINITION'] = 'INPUT_FIELD_DEFINITION';\n})(DirectiveLocation || (DirectiveLocation = {}));\n\nexport { DirectiveLocation };\n/**\n * The enum type representing the directive location values.\n *\n * @deprecated Please use `DirectiveLocation`. Will be remove in v17.\n */\n","/**\n * An exported enum describing the different kinds of tokens that the\n * lexer emits.\n */\nvar TokenKind;\n\n(function (TokenKind) {\n  TokenKind['SOF'] = '<SOF>';\n  TokenKind['EOF'] = '<EOF>';\n  TokenKind['BANG'] = '!';\n  TokenKind['DOLLAR'] = '$';\n  TokenKind['AMP'] = '&';\n  TokenKind['PAREN_L'] = '(';\n  TokenKind['PAREN_R'] = ')';\n  TokenKind['SPREAD'] = '...';\n  TokenKind['COLON'] = ':';\n  TokenKind['EQUALS'] = '=';\n  TokenKind['AT'] = '@';\n  TokenKind['BRACKET_L'] = '[';\n  TokenKind['BRACKET_R'] = ']';\n  TokenKind['BRACE_L'] = '{';\n  TokenKind['PIPE'] = '|';\n  TokenKind['BRACE_R'] = '}';\n  TokenKind['NAME'] = 'Name';\n  TokenKind['INT'] = 'Int';\n  TokenKind['FLOAT'] = 'Float';\n  TokenKind['STRING'] = 'String';\n  TokenKind['BLOCK_STRING'] = 'BlockString';\n  TokenKind['COMMENT'] = 'Comment';\n})(TokenKind || (TokenKind = {}));\n\nexport { TokenKind };\n/**\n * The enum type representing the token kinds values.\n *\n * @deprecated Please use `TokenKind`. Will be remove in v17.\n */\n","import { syntaxError } from '../error/syntaxError.mjs';\nimport { Token } from './ast.mjs';\nimport { dedentBlockStringLines } from './blockString.mjs';\nimport { isDigit, isNameContinue, isNameStart } from './characterClasses.mjs';\nimport { TokenKind } from './tokenKind.mjs';\n/**\n * Given a Source object, creates a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\n\nexport class Lexer {\n  /**\n   * The previously focused non-ignored token.\n   */\n\n  /**\n   * The currently focused non-ignored token.\n   */\n\n  /**\n   * The (1-indexed) line containing the current token.\n   */\n\n  /**\n   * The character offset at which the current line begins.\n   */\n  constructor(source) {\n    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);\n    this.source = source;\n    this.lastToken = startOfFileToken;\n    this.token = startOfFileToken;\n    this.line = 1;\n    this.lineStart = 0;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Lexer';\n  }\n  /**\n   * Advances the token stream to the next non-ignored token.\n   */\n\n  advance() {\n    this.lastToken = this.token;\n    const token = (this.token = this.lookahead());\n    return token;\n  }\n  /**\n   * Looks ahead and returns the next non-ignored token, but does not change\n   * the state of Lexer.\n   */\n\n  lookahead() {\n    let token = this.token;\n\n    if (token.kind !== TokenKind.EOF) {\n      do {\n        if (token.next) {\n          token = token.next;\n        } else {\n          // Read the next token and form a link in the token linked-list.\n          const nextToken = readNextToken(this, token.end); // @ts-expect-error next is only mutable during parsing.\n\n          token.next = nextToken; // @ts-expect-error prev is only mutable during parsing.\n\n          nextToken.prev = token;\n          token = nextToken;\n        }\n      } while (token.kind === TokenKind.COMMENT);\n    }\n\n    return token;\n  }\n}\n/**\n * @internal\n */\n\nexport function isPunctuatorTokenKind(kind) {\n  return (\n    kind === TokenKind.BANG ||\n    kind === TokenKind.DOLLAR ||\n    kind === TokenKind.AMP ||\n    kind === TokenKind.PAREN_L ||\n    kind === TokenKind.PAREN_R ||\n    kind === TokenKind.SPREAD ||\n    kind === TokenKind.COLON ||\n    kind === TokenKind.EQUALS ||\n    kind === TokenKind.AT ||\n    kind === TokenKind.BRACKET_L ||\n    kind === TokenKind.BRACKET_R ||\n    kind === TokenKind.BRACE_L ||\n    kind === TokenKind.PIPE ||\n    kind === TokenKind.BRACE_R\n  );\n}\n/**\n * A Unicode scalar value is any Unicode code point except surrogate code\n * points. In other words, the inclusive ranges of values 0x0000 to 0xD7FF and\n * 0xE000 to 0x10FFFF.\n *\n * SourceCharacter ::\n *   - \"Any Unicode scalar value\"\n */\n\nfunction isUnicodeScalarValue(code) {\n  return (\n    (code >= 0x0000 && code <= 0xd7ff) || (code >= 0xe000 && code <= 0x10ffff)\n  );\n}\n/**\n * The GraphQL specification defines source text as a sequence of unicode scalar\n * values (which Unicode defines to exclude surrogate code points). However\n * JavaScript defines strings as a sequence of UTF-16 code units which may\n * include surrogates. A surrogate pair is a valid source character as it\n * encodes a supplementary code point (above U+FFFF), but unpaired surrogate\n * code points are not valid source characters.\n */\n\nfunction isSupplementaryCodePoint(body, location) {\n  return (\n    isLeadingSurrogate(body.charCodeAt(location)) &&\n    isTrailingSurrogate(body.charCodeAt(location + 1))\n  );\n}\n\nfunction isLeadingSurrogate(code) {\n  return code >= 0xd800 && code <= 0xdbff;\n}\n\nfunction isTrailingSurrogate(code) {\n  return code >= 0xdc00 && code <= 0xdfff;\n}\n/**\n * Prints the code point (or end of file reference) at a given location in a\n * source for use in error messages.\n *\n * Printable ASCII is printed quoted, while other points are printed in Unicode\n * code point form (ie. U+1234).\n */\n\nfunction printCodePointAt(lexer, location) {\n  const code = lexer.source.body.codePointAt(location);\n\n  if (code === undefined) {\n    return TokenKind.EOF;\n  } else if (code >= 0x0020 && code <= 0x007e) {\n    // Printable ASCII\n    const char = String.fromCodePoint(code);\n    return char === '\"' ? \"'\\\"'\" : `\"${char}\"`;\n  } // Unicode code point\n\n  return 'U+' + code.toString(16).toUpperCase().padStart(4, '0');\n}\n/**\n * Create a token with line and column location information.\n */\n\nfunction createToken(lexer, kind, start, end, value) {\n  const line = lexer.line;\n  const col = 1 + start - lexer.lineStart;\n  return new Token(kind, start, end, line, col, value);\n}\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace until it finds the next lexable token, then lexes\n * punctuators immediately or calls the appropriate helper function for more\n * complicated tokens.\n */\n\nfunction readNextToken(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // SourceCharacter\n\n    switch (code) {\n      // Ignored ::\n      //   - UnicodeBOM\n      //   - WhiteSpace\n      //   - LineTerminator\n      //   - Comment\n      //   - Comma\n      //\n      // UnicodeBOM :: \"Byte Order Mark (U+FEFF)\"\n      //\n      // WhiteSpace ::\n      //   - \"Horizontal Tab (U+0009)\"\n      //   - \"Space (U+0020)\"\n      //\n      // Comma :: ,\n      case 0xfeff: // <BOM>\n\n      case 0x0009: // \\t\n\n      case 0x0020: // <space>\n\n      case 0x002c:\n        // ,\n        ++position;\n        continue;\n      // LineTerminator ::\n      //   - \"New Line (U+000A)\"\n      //   - \"Carriage Return (U+000D)\" [lookahead != \"New Line (U+000A)\"]\n      //   - \"Carriage Return (U+000D)\" \"New Line (U+000A)\"\n\n      case 0x000a:\n        // \\n\n        ++position;\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n\n      case 0x000d:\n        // \\r\n        if (body.charCodeAt(position + 1) === 0x000a) {\n          position += 2;\n        } else {\n          ++position;\n        }\n\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n      // Comment\n\n      case 0x0023:\n        // #\n        return readComment(lexer, position);\n      // Token ::\n      //   - Punctuator\n      //   - Name\n      //   - IntValue\n      //   - FloatValue\n      //   - StringValue\n      //\n      // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }\n\n      case 0x0021:\n        // !\n        return createToken(lexer, TokenKind.BANG, position, position + 1);\n\n      case 0x0024:\n        // $\n        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);\n\n      case 0x0026:\n        // &\n        return createToken(lexer, TokenKind.AMP, position, position + 1);\n\n      case 0x0028:\n        // (\n        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);\n\n      case 0x0029:\n        // )\n        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);\n\n      case 0x002e:\n        // .\n        if (\n          body.charCodeAt(position + 1) === 0x002e &&\n          body.charCodeAt(position + 2) === 0x002e\n        ) {\n          return createToken(lexer, TokenKind.SPREAD, position, position + 3);\n        }\n\n        break;\n\n      case 0x003a:\n        // :\n        return createToken(lexer, TokenKind.COLON, position, position + 1);\n\n      case 0x003d:\n        // =\n        return createToken(lexer, TokenKind.EQUALS, position, position + 1);\n\n      case 0x0040:\n        // @\n        return createToken(lexer, TokenKind.AT, position, position + 1);\n\n      case 0x005b:\n        // [\n        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);\n\n      case 0x005d:\n        // ]\n        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);\n\n      case 0x007b:\n        // {\n        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);\n\n      case 0x007c:\n        // |\n        return createToken(lexer, TokenKind.PIPE, position, position + 1);\n\n      case 0x007d:\n        // }\n        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);\n      // StringValue\n\n      case 0x0022:\n        // \"\n        if (\n          body.charCodeAt(position + 1) === 0x0022 &&\n          body.charCodeAt(position + 2) === 0x0022\n        ) {\n          return readBlockString(lexer, position);\n        }\n\n        return readString(lexer, position);\n    } // IntValue | FloatValue (Digit | -)\n\n    if (isDigit(code) || code === 0x002d) {\n      return readNumber(lexer, position, code);\n    } // Name\n\n    if (isNameStart(code)) {\n      return readName(lexer, position);\n    }\n\n    throw syntaxError(\n      lexer.source,\n      position,\n      code === 0x0027\n        ? 'Unexpected single quote character (\\'), did you mean to use a double quote (\")?'\n        : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position)\n        ? `Unexpected character: ${printCodePointAt(lexer, position)}.`\n        : `Invalid character: ${printCodePointAt(lexer, position)}.`,\n    );\n  }\n\n  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);\n}\n/**\n * Reads a comment token from the source file.\n *\n * ```\n * Comment :: # CommentChar* [lookahead != CommentChar]\n *\n * CommentChar :: SourceCharacter but not LineTerminator\n * ```\n */\n\nfunction readComment(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // LineTerminator (\\n | \\r)\n\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(\n    lexer,\n    TokenKind.COMMENT,\n    start,\n    position,\n    body.slice(start + 1, position),\n  );\n}\n/**\n * Reads a number token from the source file, either a FloatValue or an IntValue\n * depending on whether a FractionalPart or ExponentPart is encountered.\n *\n * ```\n * IntValue :: IntegerPart [lookahead != {Digit, `.`, NameStart}]\n *\n * IntegerPart ::\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit Digit*\n *\n * NegativeSign :: -\n *\n * NonZeroDigit :: Digit but not `0`\n *\n * FloatValue ::\n *   - IntegerPart FractionalPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\n *   - IntegerPart FractionalPart [lookahead != {Digit, `.`, NameStart}]\n *   - IntegerPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\n *\n * FractionalPart :: . Digit+\n *\n * ExponentPart :: ExponentIndicator Sign? Digit+\n *\n * ExponentIndicator :: one of `e` `E`\n *\n * Sign :: one of + -\n * ```\n */\n\nfunction readNumber(lexer, start, firstCode) {\n  const body = lexer.source.body;\n  let position = start;\n  let code = firstCode;\n  let isFloat = false; // NegativeSign (-)\n\n  if (code === 0x002d) {\n    code = body.charCodeAt(++position);\n  } // Zero (0)\n\n  if (code === 0x0030) {\n    code = body.charCodeAt(++position);\n\n    if (isDigit(code)) {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid number, unexpected digit after 0: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  } else {\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // Full stop (.)\n\n  if (code === 0x002e) {\n    isFloat = true;\n    code = body.charCodeAt(++position);\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // E e\n\n  if (code === 0x0045 || code === 0x0065) {\n    isFloat = true;\n    code = body.charCodeAt(++position); // + -\n\n    if (code === 0x002b || code === 0x002d) {\n      code = body.charCodeAt(++position);\n    }\n\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // Numbers cannot be followed by . or NameStart\n\n  if (code === 0x002e || isNameStart(code)) {\n    throw syntaxError(\n      lexer.source,\n      position,\n      `Invalid number, expected digit but got: ${printCodePointAt(\n        lexer,\n        position,\n      )}.`,\n    );\n  }\n\n  return createToken(\n    lexer,\n    isFloat ? TokenKind.FLOAT : TokenKind.INT,\n    start,\n    position,\n    body.slice(start, position),\n  );\n}\n/**\n * Returns the new position in the source after reading one or more digits.\n */\n\nfunction readDigits(lexer, start, firstCode) {\n  if (!isDigit(firstCode)) {\n    throw syntaxError(\n      lexer.source,\n      start,\n      `Invalid number, expected digit but got: ${printCodePointAt(\n        lexer,\n        start,\n      )}.`,\n    );\n  }\n\n  const body = lexer.source.body;\n  let position = start + 1; // +1 to skip first firstCode\n\n  while (isDigit(body.charCodeAt(position))) {\n    ++position;\n  }\n\n  return position;\n}\n/**\n * Reads a single-quote string token from the source file.\n *\n * ```\n * StringValue ::\n *   - `\"\"` [lookahead != `\"`]\n *   - `\"` StringCharacter+ `\"`\n *\n * StringCharacter ::\n *   - SourceCharacter but not `\"` or `\\` or LineTerminator\n *   - `\\u` EscapedUnicode\n *   - `\\` EscapedCharacter\n *\n * EscapedUnicode ::\n *   - `{` HexDigit+ `}`\n *   - HexDigit HexDigit HexDigit HexDigit\n *\n * EscapedCharacter :: one of `\"` `\\` `/` `b` `f` `n` `r` `t`\n * ```\n */\n\nfunction readString(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n  let chunkStart = position;\n  let value = '';\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // Closing Quote (\")\n\n    if (code === 0x0022) {\n      value += body.slice(chunkStart, position);\n      return createToken(lexer, TokenKind.STRING, start, position + 1, value);\n    } // Escape Sequence (\\)\n\n    if (code === 0x005c) {\n      value += body.slice(chunkStart, position);\n      const escape =\n        body.charCodeAt(position + 1) === 0x0075 // u\n          ? body.charCodeAt(position + 2) === 0x007b // {\n            ? readEscapedUnicodeVariableWidth(lexer, position)\n            : readEscapedUnicodeFixedWidth(lexer, position)\n          : readEscapedCharacter(lexer, position);\n      value += escape.value;\n      position += escape.size;\n      chunkStart = position;\n      continue;\n    } // LineTerminator (\\n | \\r)\n\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid character within String: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  }\n\n  throw syntaxError(lexer.source, position, 'Unterminated string.');\n} // The string value and lexed size of an escape sequence.\n\nfunction readEscapedUnicodeVariableWidth(lexer, position) {\n  const body = lexer.source.body;\n  let point = 0;\n  let size = 3; // Cannot be larger than 12 chars (\\u{00000000}).\n\n  while (size < 12) {\n    const code = body.charCodeAt(position + size++); // Closing Brace (})\n\n    if (code === 0x007d) {\n      // Must be at least 5 chars (\\u{0}) and encode a Unicode scalar value.\n      if (size < 5 || !isUnicodeScalarValue(point)) {\n        break;\n      }\n\n      return {\n        value: String.fromCodePoint(point),\n        size,\n      };\n    } // Append this hex digit to the code point.\n\n    point = (point << 4) | readHexDigit(code);\n\n    if (point < 0) {\n      break;\n    }\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid Unicode escape sequence: \"${body.slice(\n      position,\n      position + size,\n    )}\".`,\n  );\n}\n\nfunction readEscapedUnicodeFixedWidth(lexer, position) {\n  const body = lexer.source.body;\n  const code = read16BitHexCode(body, position + 2);\n\n  if (isUnicodeScalarValue(code)) {\n    return {\n      value: String.fromCodePoint(code),\n      size: 6,\n    };\n  } // GraphQL allows JSON-style surrogate pair escape sequences, but only when\n  // a valid pair is formed.\n\n  if (isLeadingSurrogate(code)) {\n    // \\u\n    if (\n      body.charCodeAt(position + 6) === 0x005c &&\n      body.charCodeAt(position + 7) === 0x0075\n    ) {\n      const trailingCode = read16BitHexCode(body, position + 8);\n\n      if (isTrailingSurrogate(trailingCode)) {\n        // JavaScript defines strings as a sequence of UTF-16 code units and\n        // encodes Unicode code points above U+FFFF using a surrogate pair of\n        // code units. Since this is a surrogate pair escape sequence, just\n        // include both codes into the JavaScript string value. Had JavaScript\n        // not been internally based on UTF-16, then this surrogate pair would\n        // be decoded to retrieve the supplementary code point.\n        return {\n          value: String.fromCodePoint(code, trailingCode),\n          size: 12,\n        };\n      }\n    }\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid Unicode escape sequence: \"${body.slice(position, position + 6)}\".`,\n  );\n}\n/**\n * Reads four hexadecimal characters and returns the positive integer that 16bit\n * hexadecimal string represents. For example, \"000f\" will return 15, and \"dead\"\n * will return 57005.\n *\n * Returns a negative number if any char was not a valid hexadecimal digit.\n */\n\nfunction read16BitHexCode(body, position) {\n  // readHexDigit() returns -1 on error. ORing a negative value with any other\n  // value always produces a negative value.\n  return (\n    (readHexDigit(body.charCodeAt(position)) << 12) |\n    (readHexDigit(body.charCodeAt(position + 1)) << 8) |\n    (readHexDigit(body.charCodeAt(position + 2)) << 4) |\n    readHexDigit(body.charCodeAt(position + 3))\n  );\n}\n/**\n * Reads a hexadecimal character and returns its positive integer value (0-15).\n *\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 if the provided character code was not a valid hexadecimal digit.\n *\n * HexDigit :: one of\n *   - `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`\n *   - `A` `B` `C` `D` `E` `F`\n *   - `a` `b` `c` `d` `e` `f`\n */\n\nfunction readHexDigit(code) {\n  return code >= 0x0030 && code <= 0x0039 // 0-9\n    ? code - 0x0030\n    : code >= 0x0041 && code <= 0x0046 // A-F\n    ? code - 0x0037\n    : code >= 0x0061 && code <= 0x0066 // a-f\n    ? code - 0x0057\n    : -1;\n}\n/**\n * | Escaped Character | Code Point | Character Name               |\n * | ----------------- | ---------- | ---------------------------- |\n * | `\"`               | U+0022     | double quote                 |\n * | `\\`               | U+005C     | reverse solidus (back slash) |\n * | `/`               | U+002F     | solidus (forward slash)      |\n * | `b`               | U+0008     | backspace                    |\n * | `f`               | U+000C     | form feed                    |\n * | `n`               | U+000A     | line feed (new line)         |\n * | `r`               | U+000D     | carriage return              |\n * | `t`               | U+0009     | horizontal tab               |\n */\n\nfunction readEscapedCharacter(lexer, position) {\n  const body = lexer.source.body;\n  const code = body.charCodeAt(position + 1);\n\n  switch (code) {\n    case 0x0022:\n      // \"\n      return {\n        value: '\\u0022',\n        size: 2,\n      };\n\n    case 0x005c:\n      // \\\n      return {\n        value: '\\u005c',\n        size: 2,\n      };\n\n    case 0x002f:\n      // /\n      return {\n        value: '\\u002f',\n        size: 2,\n      };\n\n    case 0x0062:\n      // b\n      return {\n        value: '\\u0008',\n        size: 2,\n      };\n\n    case 0x0066:\n      // f\n      return {\n        value: '\\u000c',\n        size: 2,\n      };\n\n    case 0x006e:\n      // n\n      return {\n        value: '\\u000a',\n        size: 2,\n      };\n\n    case 0x0072:\n      // r\n      return {\n        value: '\\u000d',\n        size: 2,\n      };\n\n    case 0x0074:\n      // t\n      return {\n        value: '\\u0009',\n        size: 2,\n      };\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid character escape sequence: \"${body.slice(\n      position,\n      position + 2,\n    )}\".`,\n  );\n}\n/**\n * Reads a block string token from the source file.\n *\n * ```\n * StringValue ::\n *   - `\"\"\"` BlockStringCharacter* `\"\"\"`\n *\n * BlockStringCharacter ::\n *   - SourceCharacter but not `\"\"\"` or `\\\"\"\"`\n *   - `\\\"\"\"`\n * ```\n */\n\nfunction readBlockString(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let lineStart = lexer.lineStart;\n  let position = start + 3;\n  let chunkStart = position;\n  let currentLine = '';\n  const blockLines = [];\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // Closing Triple-Quote (\"\"\")\n\n    if (\n      code === 0x0022 &&\n      body.charCodeAt(position + 1) === 0x0022 &&\n      body.charCodeAt(position + 2) === 0x0022\n    ) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n      const token = createToken(\n        lexer,\n        TokenKind.BLOCK_STRING,\n        start,\n        position + 3, // Return a string of the lines joined with U+000A.\n        dedentBlockStringLines(blockLines).join('\\n'),\n      );\n      lexer.line += blockLines.length - 1;\n      lexer.lineStart = lineStart;\n      return token;\n    } // Escaped Triple-Quote (\\\"\"\")\n\n    if (\n      code === 0x005c &&\n      body.charCodeAt(position + 1) === 0x0022 &&\n      body.charCodeAt(position + 2) === 0x0022 &&\n      body.charCodeAt(position + 3) === 0x0022\n    ) {\n      currentLine += body.slice(chunkStart, position);\n      chunkStart = position + 1; // skip only slash\n\n      position += 4;\n      continue;\n    } // LineTerminator\n\n    if (code === 0x000a || code === 0x000d) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n\n      if (code === 0x000d && body.charCodeAt(position + 1) === 0x000a) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      currentLine = '';\n      chunkStart = position;\n      lineStart = position;\n      continue;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid character within String: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  }\n\n  throw syntaxError(lexer.source, position, 'Unterminated string.');\n}\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * ```\n * Name ::\n *   - NameStart NameContinue* [lookahead != NameContinue]\n * ```\n */\n\nfunction readName(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position);\n\n    if (isNameContinue(code)) {\n      ++position;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(\n    lexer,\n    TokenKind.NAME,\n    start,\n    position,\n    body.slice(start, position),\n  );\n}\n","import { syntaxError } from '../error/syntaxError.mjs';\nimport { Location, OperationTypeNode } from './ast.mjs';\nimport { DirectiveLocation } from './directiveLocation.mjs';\nimport { Kind } from './kinds.mjs';\nimport { isPunctuatorTokenKind, Lexer } from './lexer.mjs';\nimport { isSource, Source } from './source.mjs';\nimport { TokenKind } from './tokenKind.mjs';\n/**\n * Configuration options to control parser behavior\n */\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nexport function parse(source, options) {\n  const parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nexport function parseValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Similar to parseValue(), but raises a parse error if it encounters a\n * variable. The return type will be a constant value.\n */\n\nexport function parseConstValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseConstValueLiteral();\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nexport function parseType(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n/**\n * This class is exported only to assist people in implementing their own parsers\n * without duplicating too much code and should be used only as last resort for cases\n * such as experimental syntax or if certain features could not be contributed upstream.\n *\n * It is still part of the internal API and is versioned, so any changes to it are never\n * considered breaking changes. If you still need to support multiple versions of the\n * library, please use the `versionInfo` variable for version detection.\n *\n * @internal\n */\n\nexport class Parser {\n  constructor(source, options = {}) {\n    const sourceObj = isSource(source) ? source : new Source(source);\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n    this._tokenCounter = 0;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n  parseName() {\n    const token = this.expectToken(TokenKind.NAME);\n    return this.node(token, {\n      kind: Kind.NAME,\n      value: token.value,\n    });\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n\n  parseDocument() {\n    return this.node(this._lexer.token, {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(\n        TokenKind.SOF,\n        this.parseDefinition,\n        TokenKind.EOF,\n      ),\n    });\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   *\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n\n  parseDefinition() {\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } // Many definitions begin with a description and require a lookahead.\n\n    const hasDescription = this.peekDescription();\n    const keywordToken = hasDescription\n      ? this._lexer.lookahead()\n      : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n\n      if (hasDescription) {\n        throw syntaxError(\n          this._lexer.source,\n          this._lexer.token.start,\n          'Unexpected description, descriptions are supported only on type definitions.',\n        );\n      }\n\n      switch (keywordToken.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n\n  parseOperationDefinition() {\n    const start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.node(start, {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: OperationTypeNode.QUERY,\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    const operation = this.parseOperationType();\n    let name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return this.node(start, {\n      kind: Kind.OPERATION_DEFINITION,\n      operation,\n      name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n\n  parseOperationType() {\n    const operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return OperationTypeNode.QUERY;\n\n      case 'mutation':\n        return OperationTypeNode.MUTATION;\n\n      case 'subscription':\n        return OperationTypeNode.SUBSCRIPTION;\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n\n  parseVariableDefinitions() {\n    return this.optionalMany(\n      TokenKind.PAREN_L,\n      this.parseVariableDefinition,\n      TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n\n  parseVariableDefinition() {\n    return this.node(this._lexer.token, {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS)\n        ? this.parseConstValueLiteral()\n        : undefined,\n      directives: this.parseConstDirectives(),\n    });\n  }\n  /**\n   * Variable : $ Name\n   */\n\n  parseVariable() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return this.node(start, {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n    });\n  }\n  /**\n   * ```\n   * SelectionSet : { Selection+ }\n   * ```\n   */\n\n  parseSelectionSet() {\n    return this.node(this._lexer.token, {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(\n        TokenKind.BRACE_L,\n        this.parseSelection,\n        TokenKind.BRACE_R,\n      ),\n    });\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n\n  parseSelection() {\n    return this.peek(TokenKind.SPREAD)\n      ? this.parseFragment()\n      : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n\n  parseField() {\n    const start = this._lexer.token;\n    const nameOrAlias = this.parseName();\n    let alias;\n    let name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return this.node(start, {\n      kind: Kind.FIELD,\n      alias,\n      name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L)\n        ? this.parseSelectionSet()\n        : undefined,\n    });\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n\n  parseArguments(isConst) {\n    const item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n\n  parseArgument(isConst = false) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.ARGUMENT,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  }\n\n  parseConstArgument() {\n    return this.parseArgument(true);\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n\n  parseFragment() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    const hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n\n  parseFragmentDefinition() {\n    const start = this._lexer.token;\n    this.expectKeyword('fragment'); // Legacy support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (this._options.allowLegacyFragmentVariables === true) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n\n  parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseValueLiteral(isConst) {\n    const token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this.advanceLexer();\n        return this.node(token, {\n          kind: Kind.INT,\n          value: token.value,\n        });\n\n      case TokenKind.FLOAT:\n        this.advanceLexer();\n        return this.node(token, {\n          kind: Kind.FLOAT,\n          value: token.value,\n        });\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        this.advanceLexer();\n\n        switch (token.value) {\n          case 'true':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: true,\n            });\n\n          case 'false':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: false,\n            });\n\n          case 'null':\n            return this.node(token, {\n              kind: Kind.NULL,\n            });\n\n          default:\n            return this.node(token, {\n              kind: Kind.ENUM,\n              value: token.value,\n            });\n        }\n\n      case TokenKind.DOLLAR:\n        if (isConst) {\n          this.expectToken(TokenKind.DOLLAR);\n\n          if (this._lexer.token.kind === TokenKind.NAME) {\n            const varName = this._lexer.token.value;\n            throw syntaxError(\n              this._lexer.source,\n              token.start,\n              `Unexpected variable \"$${varName}\" in constant value.`,\n            );\n          } else {\n            throw this.unexpected(token);\n          }\n        }\n\n        return this.parseVariable();\n\n      default:\n        throw this.unexpected();\n    }\n  }\n\n  parseConstValueLiteral() {\n    return this.parseValueLiteral(true);\n  }\n\n  parseStringLiteral() {\n    const token = this._lexer.token;\n    this.advanceLexer();\n    return this.node(token, {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n    });\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n\n  parseList(isConst) {\n    const item = () => this.parseValueLiteral(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n    });\n  }\n  /**\n   * ```\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   * ```\n   */\n\n  parseObject(isConst) {\n    const item = () => this.parseObjectField(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n    });\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n\n  parseObjectField(isConst) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.OBJECT_FIELD,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n\n  parseDirectives(isConst) {\n    const directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n\n  parseConstDirectives() {\n    return this.parseDirectives(true);\n  }\n  /**\n   * ```\n   * Directive[Const] : @ Name Arguments[?Const]?\n   * ```\n   */\n\n  parseDirective(isConst) {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return this.node(start, {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n    });\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n\n  parseTypeReference() {\n    const start = this._lexer.token;\n    let type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      const innerType = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = this.node(start, {\n        kind: Kind.LIST_TYPE,\n        type: innerType,\n      });\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return this.node(start, {\n        kind: Kind.NON_NULL_TYPE,\n        type,\n      });\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n\n  parseNamedType() {\n    return this.node(this._lexer.token, {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n    });\n  } // Implements the parsing rules in the Type Definition section.\n\n  peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n\n  parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * ```\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   * ```\n   */\n\n  parseSchemaDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.many(\n      TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      TokenKind.BRACE_R,\n    );\n    return this.node(start, {\n      kind: Kind.SCHEMA_DEFINITION,\n      description,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n\n  parseOperationTypeDefinition() {\n    const start = this._lexer.token;\n    const operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseNamedType();\n    return this.node(start, {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation,\n      type,\n    });\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n\n  parseScalarTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n\n  parseObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n\n  parseImplementsInterfaces() {\n    return this.expectOptionalKeyword('implements')\n      ? this.delimitedMany(TokenKind.AMP, this.parseNamedType)\n      : [];\n  }\n  /**\n   * ```\n   * FieldsDefinition : { FieldDefinition+ }\n   * ```\n   */\n\n  parseFieldsDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseFieldDefinition,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n\n  parseFieldDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.FIELD_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      type,\n      directives,\n    });\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n\n  parseArgumentDefs() {\n    return this.optionalMany(\n      TokenKind.PAREN_L,\n      this.parseInputValueDef,\n      TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n\n  parseInputValueDef() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    let defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseConstValueLiteral();\n    }\n\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description,\n      name,\n      type,\n      defaultValue,\n      directives,\n    });\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n\n  parseInterfaceTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n\n  parseUnionTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n\n  parseUnionMemberTypes() {\n    return this.expectOptionalToken(TokenKind.EQUALS)\n      ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType)\n      : [];\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n\n  parseEnumTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * ```\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   * ```\n   */\n\n  parseEnumValuesDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseEnumValueDefinition,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   */\n\n  parseEnumValueDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseEnumValueName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseEnumValueName() {\n    if (\n      this._lexer.token.value === 'true' ||\n      this._lexer.token.value === 'false' ||\n      this._lexer.token.value === 'null'\n    ) {\n      throw syntaxError(\n        this._lexer.source,\n        this._lexer.token.start,\n        `${getTokenDesc(\n          this._lexer.token,\n        )} is reserved and cannot be used for an enum value.`,\n      );\n    }\n\n    return this.parseName();\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n\n  parseInputObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   * ```\n   */\n\n  parseInputFieldsDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseInputValueDef,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n\n  parseTypeSystemExtension() {\n    const keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * ```\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   * ```\n   */\n\n  parseSchemaExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      TokenKind.BRACE_R,\n    );\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n\n  parseScalarTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n\n  parseObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n\n  parseInterfaceTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n\n  parseUnionTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n\n  parseEnumTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n\n  parseInputObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   * ```\n   */\n\n  parseDirectiveDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    const repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    const locations = this.parseDirectiveLocations();\n    return this.node(start, {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      repeatable,\n      locations,\n    });\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n\n  parseDirectiveLocations() {\n    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n\n  parseDirectiveLocation() {\n    const start = this._lexer.token;\n    const name = this.parseName();\n\n    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a node that, if configured to do so, sets a \"loc\" field as a\n   * location object, used to identify the place in the source that created a\n   * given parsed object.\n   */\n\n  node(startToken, node) {\n    if (this._options.noLocation !== true) {\n      node.loc = new Location(\n        startToken,\n        this._lexer.lastToken,\n        this._lexer.source,\n      );\n    }\n\n    return node;\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n\n  peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this.advanceLexer();\n      return token;\n    }\n\n    throw syntaxError(\n      this._lexer.source,\n      token.start,\n      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * If the next token is of the given kind, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this.advanceLexer();\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this.advanceLexer();\n    } else {\n      throw syntaxError(\n        this._lexer.source,\n        token.start,\n        `Expected \"${value}\", found ${getTokenDesc(token)}.`,\n      );\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this.advanceLexer();\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token is encountered.\n   */\n\n  unexpected(atToken) {\n    const token =\n      atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError(\n      this._lexer.source,\n      token.start,\n      `Unexpected ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      const nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\n   * Advances the parser to the next lex token after last item in the list.\n   */\n\n  delimitedMany(delimiterKind, parseFn) {\n    this.expectOptionalToken(delimiterKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n\n    return nodes;\n  }\n\n  advanceLexer() {\n    const { maxTokens } = this._options;\n\n    const token = this._lexer.advance();\n\n    if (maxTokens !== undefined && token.kind !== TokenKind.EOF) {\n      ++this._tokenCounter;\n\n      if (this._tokenCounter > maxTokens) {\n        throw syntaxError(\n          this._lexer.source,\n          token.start,\n          `Document contains more that ${maxTokens} tokens. Parsing aborted.`,\n        );\n      }\n    }\n  }\n}\n/**\n * A helper function to describe a token as a string for debugging.\n */\n\nfunction getTokenDesc(token) {\n  const value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? ` \"${value}\"` : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging.\n */\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? `\"${kind}\"` : kind;\n}\n","import { __assign } from \"tslib\";\nimport { parse } from 'graphql';\nvar docCache = new Map();\nvar fragmentSourceMap = new Map();\nvar printFragmentWarnings = true;\nvar experimentalFragmentVariables = false;\nfunction normalize(string) {\n    return string.replace(/[\\s,]+/g, ' ').trim();\n}\nfunction cacheKeyFromLoc(loc) {\n    return normalize(loc.source.body.substring(loc.start, loc.end));\n}\nfunction processFragments(ast) {\n    var seenKeys = new Set();\n    var definitions = [];\n    ast.definitions.forEach(function (fragmentDefinition) {\n        if (fragmentDefinition.kind === 'FragmentDefinition') {\n            var fragmentName = fragmentDefinition.name.value;\n            var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n            var sourceKeySet = fragmentSourceMap.get(fragmentName);\n            if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n                if (printFragmentWarnings) {\n                    console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n                        + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n                        + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n                }\n            }\n            else if (!sourceKeySet) {\n                fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);\n            }\n            sourceKeySet.add(sourceKey);\n            if (!seenKeys.has(sourceKey)) {\n                seenKeys.add(sourceKey);\n                definitions.push(fragmentDefinition);\n            }\n        }\n        else {\n            definitions.push(fragmentDefinition);\n        }\n    });\n    return __assign(__assign({}, ast), { definitions: definitions });\n}\nfunction stripLoc(doc) {\n    var workSet = new Set(doc.definitions);\n    workSet.forEach(function (node) {\n        if (node.loc)\n            delete node.loc;\n        Object.keys(node).forEach(function (key) {\n            var value = node[key];\n            if (value && typeof value === 'object') {\n                workSet.add(value);\n            }\n        });\n    });\n    var loc = doc.loc;\n    if (loc) {\n        delete loc.startToken;\n        delete loc.endToken;\n    }\n    return doc;\n}\nfunction parseDocument(source) {\n    var cacheKey = normalize(source);\n    if (!docCache.has(cacheKey)) {\n        var parsed = parse(source, {\n            experimentalFragmentVariables: experimentalFragmentVariables,\n            allowLegacyFragmentVariables: experimentalFragmentVariables\n        });\n        if (!parsed || parsed.kind !== 'Document') {\n            throw new Error('Not a valid GraphQL document.');\n        }\n        docCache.set(cacheKey, stripLoc(processFragments(parsed)));\n    }\n    return docCache.get(cacheKey);\n}\nexport function gql(literals) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    if (typeof literals === 'string') {\n        literals = [literals];\n    }\n    var result = literals[0];\n    args.forEach(function (arg, i) {\n        if (arg && arg.kind === 'Document') {\n            result += arg.loc.source.body;\n        }\n        else {\n            result += arg;\n        }\n        result += literals[i + 1];\n    });\n    return parseDocument(result);\n}\nexport function resetCaches() {\n    docCache.clear();\n    fragmentSourceMap.clear();\n}\nexport function disableFragmentWarnings() {\n    printFragmentWarnings = false;\n}\nexport function enableExperimentalFragmentVariables() {\n    experimentalFragmentVariables = true;\n}\nexport function disableExperimentalFragmentVariables() {\n    experimentalFragmentVariables = false;\n}\nvar extras = {\n    gql: gql,\n    resetCaches: resetCaches,\n    disableFragmentWarnings: disableFragmentWarnings,\n    enableExperimentalFragmentVariables: enableExperimentalFragmentVariables,\n    disableExperimentalFragmentVariables: disableExperimentalFragmentVariables\n};\n(function (gql_1) {\n    gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;\n})(gql || (gql = {}));\ngql[\"default\"] = gql;\nexport default gql;\n//# sourceMappingURL=index.js.map","import { invariant } from \"../../utilities/globals/index.js\";\nexport var DocumentType;\n(function (DocumentType) {\n    DocumentType[DocumentType[\"Query\"] = 0] = \"Query\";\n    DocumentType[DocumentType[\"Mutation\"] = 1] = \"Mutation\";\n    DocumentType[DocumentType[\"Subscription\"] = 2] = \"Subscription\";\n})(DocumentType || (DocumentType = {}));\nvar cache = new Map();\nexport function operationName(type) {\n    var name;\n    switch (type) {\n        case DocumentType.Query:\n            name = 'Query';\n            break;\n        case DocumentType.Mutation:\n            name = 'Mutation';\n            break;\n        case DocumentType.Subscription:\n            name = 'Subscription';\n            break;\n    }\n    return name;\n}\nexport function parser(document) {\n    var cached = cache.get(document);\n    if (cached)\n        return cached;\n    var variables, type, name;\n    __DEV__ ? invariant(!!document && !!document.kind, \"Argument of \".concat(document, \" passed to parser was not a valid GraphQL \") +\n        \"DocumentNode. You may need to use 'graphql-tag' or another method \" +\n        \"to convert your operation into a document\") : invariant(!!document && !!document.kind, 30);\n    var fragments = document.definitions.filter(function (x) { return x.kind === 'FragmentDefinition'; });\n    var queries = document.definitions.filter(function (x) {\n        return x.kind === 'OperationDefinition' && x.operation === 'query';\n    });\n    var mutations = document.definitions.filter(function (x) {\n        return x.kind === 'OperationDefinition' && x.operation === 'mutation';\n    });\n    var subscriptions = document.definitions.filter(function (x) {\n        return x.kind === 'OperationDefinition' && x.operation === 'subscription';\n    });\n    __DEV__ ? invariant(!fragments.length ||\n        (queries.length || mutations.length || subscriptions.length), \"Passing only a fragment to 'graphql' is not yet supported. \" +\n        \"You must include a query, subscription or mutation as well\") : invariant(!fragments.length ||\n        (queries.length || mutations.length || subscriptions.length), 31);\n    __DEV__ ? invariant(queries.length + mutations.length + subscriptions.length <= 1, \"react-apollo only supports a query, subscription, or a mutation per HOC. \" +\n        \"\".concat(document, \" had \").concat(queries.length, \" queries, \").concat(subscriptions.length, \" \") +\n        \"subscriptions and \".concat(mutations.length, \" mutations. \") +\n        \"You can use 'compose' to join multiple operation types to a component\") : invariant(queries.length + mutations.length + subscriptions.length <= 1, 32);\n    type = queries.length ? DocumentType.Query : DocumentType.Mutation;\n    if (!queries.length && !mutations.length)\n        type = DocumentType.Subscription;\n    var definitions = queries.length\n        ? queries\n        : mutations.length\n            ? mutations\n            : subscriptions;\n    __DEV__ ? invariant(definitions.length === 1, \"react-apollo only supports one definition per HOC. \".concat(document, \" had \") +\n        \"\".concat(definitions.length, \" definitions. \") +\n        \"You can use 'compose' to join multiple operation types to a component\") : invariant(definitions.length === 1, 33);\n    var definition = definitions[0];\n    variables = definition.variableDefinitions || [];\n    if (definition.name && definition.name.kind === 'Name') {\n        name = definition.name.value;\n    }\n    else {\n        name = 'data';\n    }\n    var payload = { name: name, type: type, variables: variables };\n    cache.set(document, payload);\n    return payload;\n}\nexport function verifyDocumentType(document, type) {\n    var operation = parser(document);\n    var requiredOperationName = operationName(type);\n    var usedOperationName = operationName(operation.type);\n    __DEV__ ? invariant(operation.type === type, \"Running a \".concat(requiredOperationName, \" requires a graphql \") +\n        \"\".concat(requiredOperationName, \", but a \").concat(usedOperationName, \" was used instead.\")) : invariant(operation.type === type, 34);\n}\n//# sourceMappingURL=index.js.map","import { __assign, __rest } from \"tslib\";\nimport { useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { equal } from '@wry/equality';\nimport { getApolloContext } from \"../context/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport { NetworkStatus, } from \"../../core/index.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nexport function useQuery(query, options) {\n    var _a;\n    var context = useContext(getApolloContext());\n    var client = useApolloClient(options === null || options === void 0 ? void 0 : options.client);\n    verifyDocumentType(query, DocumentType.Query);\n    var _b = useState(function () {\n        var watchQueryOptions = createWatchQueryOptions(query, options);\n        var obsQuery = null;\n        if (context.renderPromises) {\n            obsQuery = context.renderPromises.getSSRObservable(watchQueryOptions);\n        }\n        if (!obsQuery) {\n            obsQuery = client.watchQuery(watchQueryOptions);\n            if (context.renderPromises) {\n                context.renderPromises.registerSSRObservable(obsQuery, watchQueryOptions);\n            }\n        }\n        if (context.renderPromises &&\n            (options === null || options === void 0 ? void 0 : options.ssr) !== false &&\n            !(options === null || options === void 0 ? void 0 : options.skip) &&\n            obsQuery.getCurrentResult().loading) {\n            context.renderPromises.addQueryPromise({\n                getOptions: function () { return createWatchQueryOptions(query, options); },\n                fetchData: function () { return new Promise(function (resolve) {\n                    var sub = obsQuery.subscribe({\n                        next: function (result) {\n                            if (!result.loading) {\n                                resolve();\n                                sub.unsubscribe();\n                            }\n                        },\n                        error: function () {\n                            resolve();\n                            sub.unsubscribe();\n                        },\n                        complete: function () {\n                            resolve();\n                        },\n                    });\n                }); },\n            }, function () { return null; });\n        }\n        return obsQuery;\n    }), obsQuery = _b[0], setObsQuery = _b[1];\n    var _c = useState(function () {\n        var _a, _b;\n        var result = obsQuery.getCurrentResult();\n        if (!result.loading && options) {\n            if (result.error) {\n                (_a = options.onError) === null || _a === void 0 ? void 0 : _a.call(options, result.error);\n            }\n            else if (result.data) {\n                (_b = options.onCompleted) === null || _b === void 0 ? void 0 : _b.call(options, result.data);\n            }\n        }\n        return result;\n    }), result = _c[0], setResult = _c[1];\n    var ref = useRef({\n        client: client,\n        query: query,\n        options: options,\n        result: result,\n        previousData: void 0,\n        watchQueryOptions: createWatchQueryOptions(query, options),\n    });\n    useEffect(function () {\n        var _a, _b;\n        var watchQueryOptions = createWatchQueryOptions(query, options);\n        var nextResult;\n        if (ref.current.client !== client || !equal(ref.current.query, query)) {\n            var obsQuery_1 = client.watchQuery(watchQueryOptions);\n            setObsQuery(obsQuery_1);\n            nextResult = obsQuery_1.getCurrentResult();\n        }\n        else if (!equal(ref.current.watchQueryOptions, watchQueryOptions)) {\n            obsQuery.setOptions(watchQueryOptions).catch(function () { });\n            nextResult = obsQuery.getCurrentResult();\n            ref.current.watchQueryOptions = watchQueryOptions;\n        }\n        if (nextResult) {\n            var previousResult = ref.current.result;\n            if (previousResult.data) {\n                ref.current.previousData = previousResult.data;\n            }\n            setResult(ref.current.result = nextResult);\n            if (!nextResult.loading && options) {\n                if (!result.loading) {\n                    if (result.error) {\n                        (_a = options.onError) === null || _a === void 0 ? void 0 : _a.call(options, result.error);\n                    }\n                    else if (result.data) {\n                        (_b = options.onCompleted) === null || _b === void 0 ? void 0 : _b.call(options, result.data);\n                    }\n                }\n            }\n        }\n        Object.assign(ref.current, { client: client, query: query });\n    }, [obsQuery, client, query, options]);\n    useEffect(function () {\n        if (context.renderPromises) {\n            return;\n        }\n        var subscription = obsQuery.subscribe(onNext, onError);\n        function onNext() {\n            var _a, _b;\n            var previousResult = ref.current.result;\n            var result = obsQuery.getCurrentResult();\n            if (previousResult &&\n                previousResult.loading === result.loading &&\n                previousResult.networkStatus === result.networkStatus &&\n                equal(previousResult.data, result.data)) {\n                return;\n            }\n            if (previousResult.data) {\n                ref.current.previousData = previousResult.data;\n            }\n            setResult(ref.current.result = result);\n            if (!result.loading) {\n                (_b = (_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onCompleted) === null || _b === void 0 ? void 0 : _b.call(_a, result.data);\n            }\n        }\n        function onError(error) {\n            var _a, _b;\n            var last = obsQuery[\"last\"];\n            subscription.unsubscribe();\n            try {\n                obsQuery.resetLastResults();\n                subscription = obsQuery.subscribe(onNext, onError);\n            }\n            finally {\n                obsQuery[\"last\"] = last;\n            }\n            if (!error.hasOwnProperty('graphQLErrors')) {\n                throw error;\n            }\n            var previousResult = ref.current.result;\n            if ((previousResult && previousResult.loading) ||\n                !equal(error, previousResult.error)) {\n                setResult(ref.current.result = {\n                    data: previousResult.data,\n                    error: error,\n                    loading: false,\n                    networkStatus: NetworkStatus.error,\n                });\n                (_b = (_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onError) === null || _b === void 0 ? void 0 : _b.call(_a, error);\n            }\n        }\n        return function () { return subscription.unsubscribe(); };\n    }, [obsQuery, context.renderPromises, client.disableNetworkFetches]);\n    var partial;\n    (_a = result, partial = _a.partial, result = __rest(_a, [\"partial\"]));\n    {\n        if (partial &&\n            (options === null || options === void 0 ? void 0 : options.partialRefetch) &&\n            !result.loading &&\n            (!result.data || Object.keys(result.data).length === 0) &&\n            obsQuery.options.fetchPolicy !== 'cache-only') {\n            result = __assign(__assign({}, result), { loading: true, networkStatus: NetworkStatus.refetch });\n            obsQuery.refetch();\n        }\n        if (context.renderPromises &&\n            (options === null || options === void 0 ? void 0 : options.ssr) !== false &&\n            !(options === null || options === void 0 ? void 0 : options.skip) &&\n            result.loading) {\n            obsQuery.setOptions(createWatchQueryOptions(query, options)).catch(function () { });\n        }\n        Object.assign(ref.current, { options: options });\n    }\n    if ((context.renderPromises || client.disableNetworkFetches) &&\n        (options === null || options === void 0 ? void 0 : options.ssr) === false) {\n        result = ref.current.result = {\n            loading: true,\n            data: void 0,\n            error: void 0,\n            networkStatus: NetworkStatus.loading,\n        };\n    }\n    else if ((options === null || options === void 0 ? void 0 : options.skip) || (options === null || options === void 0 ? void 0 : options.fetchPolicy) === 'standby') {\n        result = {\n            loading: false,\n            data: void 0,\n            error: void 0,\n            networkStatus: NetworkStatus.ready,\n        };\n    }\n    if (result.errors && result.errors.length) {\n        result = __assign(__assign({}, result), { error: result.error || new ApolloError({ graphQLErrors: result.errors }) });\n    }\n    var obsQueryFields = useMemo(function () { return ({\n        refetch: obsQuery.refetch.bind(obsQuery),\n        fetchMore: obsQuery.fetchMore.bind(obsQuery),\n        updateQuery: obsQuery.updateQuery.bind(obsQuery),\n        startPolling: obsQuery.startPolling.bind(obsQuery),\n        stopPolling: obsQuery.stopPolling.bind(obsQuery),\n        subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),\n    }); }, [obsQuery]);\n    return __assign(__assign(__assign({}, obsQueryFields), { variables: createWatchQueryOptions(query, options).variables, client: client, called: true, previousData: ref.current.previousData }), result);\n}\nfunction createWatchQueryOptions(query, options) {\n    var _a;\n    if (options === void 0) { options = {}; }\n    var skip = options.skip, ssr = options.ssr, onCompleted = options.onCompleted, onError = options.onError, displayName = options.displayName, watchQueryOptions = __rest(options, [\"skip\", \"ssr\", \"onCompleted\", \"onError\", \"displayName\"]);\n    if (skip) {\n        watchQueryOptions.fetchPolicy = 'standby';\n    }\n    else if (((_a = watchQueryOptions.context) === null || _a === void 0 ? void 0 : _a.renderPromises) &&\n        (watchQueryOptions.fetchPolicy === 'network-only' ||\n            watchQueryOptions.fetchPolicy === 'cache-and-network')) {\n        watchQueryOptions.fetchPolicy = 'cache-first';\n    }\n    else if (!watchQueryOptions.fetchPolicy) {\n        watchQueryOptions.fetchPolicy = 'cache-first';\n    }\n    if (!watchQueryOptions.variables) {\n        watchQueryOptions.variables = {};\n    }\n    return __assign({ query: query }, watchQueryOptions);\n}\n//# sourceMappingURL=useQuery.js.map","import { invariant } from \"../../utilities/globals/index.js\";\nimport { useContext } from 'react';\nimport { getApolloContext } from \"../context/index.js\";\nexport function useApolloClient(override) {\n    var context = useContext(getApolloContext());\n    var client = override || context.client;\n    __DEV__ ? invariant(!!client, 'Could not find \"client\" in the context or passed in as an option. ' +\n        'Wrap the root component in an <ApolloProvider>, or pass an ApolloClient' +\n        'ApolloClient instance in via options.') : invariant(!!client, 29);\n    return client;\n}\n//# sourceMappingURL=useApolloClient.js.map","export default function _taggedTemplateLiteralLoose(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n  strings.raw = raw;\n  return strings;\n}"],"names":["_ref","toId","children","props","___EmotionJSX","ChakraButton","onClick","scrollIntoView","prompt","isArticle","feedbackSubmitted","setFeedbackSubmitted","useState","surveyUrl","useSurvey","isTutorial","window","location","href","includes","handleSubmit","choice","trackCustomEvent","eventCategory","eventAction","eventName","String","Flex","border","borderColor","bg","borderRadius","p","direction","mb","mt","w","gap","Heading","as","m","fontSize","fontWeight","Translation","id","getTitle","Button","variant","open","leftIcon","FeedbackThumbsUpIcon","transform","invariant","condition","message","Boolean","Error","LineRegExp","getLocation","source","position","lastLineStart","line","match","body","matchAll","index","length","column","printSourceLocation","sourceLocation","firstLineColumnOffset","locationOffset","padStart","lineIndex","lineOffset","lineNum","columnOffset","columnNum","locationStr","name","lines","split","locationLine","subLineIndex","Math","floor","subLineColumnNum","subLines","i","push","slice","printPrefixedLines","map","subLine","existingLines","filter","_","undefined","padLen","max","prefix","join","GraphQLError","constructor","rawArgs","_this$nodes","_nodeLocations$","nodes","positions","path","originalError","extensions","args","firstArg","toNormalizedOptions","super","this","undefinedIfEmpty","Array","isArray","nodeLocations","node","loc","start","locations","pos","originalExtensions","value","Object","create","defineProperties","writable","enumerable","stack","defineProperty","configurable","captureStackTrace","toStringTag","Symbol","toString","output","toJSON","formattedError","keys","array","syntaxError","description","DirectiveLocation","TokenKind","Lexer","startOfFileToken","lastToken","token","lineStart","advance","lookahead","kind","next","nextToken","readNextToken","end","prev","isUnicodeScalarValue","code","isSupplementaryCodePoint","isLeadingSurrogate","charCodeAt","isTrailingSurrogate","printCodePointAt","lexer","codePointAt","char","fromCodePoint","toUpperCase","createToken","col","bodyLength","readComment","readBlockString","readString","readNumber","readName","firstCode","isFloat","readDigits","chunkStart","escape","readEscapedUnicodeVariableWidth","readEscapedUnicodeFixedWidth","readEscapedCharacter","size","point","readHexDigit","read16BitHexCode","trailingCode","currentLine","blockLines","Parser","options","sourceObj","_lexer","_options","_tokenCounter","parseName","expectToken","parseDocument","definitions","many","parseDefinition","peek","parseOperationDefinition","hasDescription","peekDescription","keywordToken","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","parseFragmentDefinition","parseTypeSystemExtension","unexpected","operation","variableDefinitions","directives","selectionSet","parseSelectionSet","parseOperationType","parseVariableDefinitions","parseDirectives","operationToken","optionalMany","parseVariableDefinition","variable","parseVariable","type","parseTypeReference","defaultValue","expectOptionalToken","parseConstValueLiteral","parseConstDirectives","selections","parseSelection","parseFragment","parseField","nameOrAlias","alias","arguments","parseArguments","isConst","item","parseConstArgument","parseArgument","parseValueLiteral","hasTypeCondition","expectOptionalKeyword","parseFragmentName","typeCondition","parseNamedType","expectKeyword","allowLegacyFragmentVariables","parseList","parseObject","advanceLexer","parseStringLiteral","varName","block","values","any","fields","parseObjectField","parseDirective","innerType","parseDescription","operationTypes","parseOperationTypeDefinition","interfaces","parseImplementsInterfaces","parseFieldsDefinition","delimitedMany","parseFieldDefinition","parseArgumentDefs","parseInputValueDef","types","parseUnionMemberTypes","parseEnumValuesDefinition","parseEnumValueDefinition","parseEnumValueName","getTokenDesc","parseInputFieldsDefinition","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","repeatable","parseDirectiveLocations","parseDirectiveLocation","prototype","hasOwnProperty","call","startToken","noLocation","getTokenKindDesc","atToken","openKind","parseFn","closeKind","delimiterKind","maxTokens","isPunctuatorTokenKind","docCache","Map","fragmentSourceMap","printFragmentWarnings","experimentalFragmentVariables","normalize","string","replace","trim","processFragments","ast","seenKeys","Set","forEach","fragmentDefinition","fragmentName","sourceKey","substring","sourceKeySet","get","has","console","warn","set","add","__assign","cacheKey","parsed","parse","doc","workSet","key","endToken","stripLoc","gql","literals","_i","result","arg","gql_1","extras","clear","resetCaches","disableFragmentWarnings","enableExperimentalFragmentVariables","disableExperimentalFragmentVariables","DocumentType","cache","operationName","Query","Mutation","Subscription","verifyDocumentType","document","variables","cached","__DEV__","concat","fragments","x","queries","mutations","subscriptions","definition","payload","parser","requiredOperationName","usedOperationName","useQuery","query","_a","context","useContext","client","override","useApolloClient","partial","_b","watchQueryOptions","createWatchQueryOptions","obsQuery","renderPromises","getSSRObservable","watchQuery","registerSSRObservable","ssr","skip","getCurrentResult","loading","addQueryPromise","getOptions","fetchData","Promise","resolve","sub","subscribe","unsubscribe","error","complete","setObsQuery","_c","onError","data","onCompleted","setResult","ref","useRef","previousData","useEffect","nextResult","current","setOptions","catch","obsQuery_1","previousResult","assign","subscription","onNext","last","resetLastResults","networkStatus","disableNetworkFetches","__rest","partialRefetch","fetchPolicy","refetch","errors","graphQLErrors","obsQueryFields","useMemo","bind","fetchMore","updateQuery","startPolling","stopPolling","subscribeToMore","called","displayName","_taggedTemplateLiteralLoose","strings","raw"],"sourceRoot":""}